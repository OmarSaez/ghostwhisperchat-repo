DOCUMENTACIÓN TÉCNICA Y MODULAR DEL SISTEMA (v41.1)
=====================================================
Fecha: 14 de Diciembre de 2025

Esta documentación describe la arquitectura modular completa de GhostWhisperChat, construida para ofrecer escalabilidad, robustez y una experiencia de usuario moderna en terminal.

0. EL CEREBRO PRINCIPAL
-----------------------
ghostwhisperchat (Executable / Entry Point)
  - Rol: Orquestador Principal y Lobby.
  - Función: Es el punto de entrada de la aplicación. Su responsabilidad no es "hacerlo todo", sino "conectar todo".
  - Tareas Críticas:
    - Inicialización del Entorno: Carga configuraciones, detecta el SO y prepara los manejadores de señales.
    - Bucle Principal del Lobby: Mantiene la consola interactiva donde el usuario gestiona sus conexiones.
    - Gestión de Hilos (Listeners): Levanta los servidores TCP (Chat/Archivos) y UDP (Descubrimiento) usando `gw_comm`.
    - Integración de Módulos: Instancia y coordina a `gw_display`, `gw_complete` y `gw_pop` para que trabajen juntos.
    - Lógica de Protocolo V2: Procesa los paquetes entrantes (INVITE, WHOIS, IAM_HERE) y decide qué acción tomar.

1. NÚCLEO Y UTILIDADES
----------------------
gw_shared.py (Definiciones Globales)
  - Detalle: Actúa como la "memoria compartida" estática del proyecto.
  - Clave: Almacena las estructuras de datos críticas como el diccionario de comandos (`COMMAND_DEFS`) y sus alias, asegurando que si se cambia un comando ahí, se actualiza en el autocompletado y en la ayuda automáticamente.
  - Extras: Gestiona la carga segura de `config.json` y define la paleta de colores ANSI para la estética de la app.

gw_comm.py (Motor de Red)
  - Detalle: Abstracción de bajo nivel de Sockets.
  - Protocolo: Implementa el empaquetado y desempaquetado de mensajes usando separadores personalizados, evitando errores comunes de concatenación de TCP.
  - Seguridad: Genera los códigos hash para verificación de archivos y construye los paquetes MPP (My Peer Protocol) que identifican a cada nodo en la red con su Versión, Nick y Estado.

2. LÓGICA DE NEGOCIO Y PROCESOS
-------------------------------
gw_child.py (Proceso de Chat Independiente)
  - Detalle: Es el código que corre cuando se abre una "Nueva Ventana".
  - Aislamiento: Funciona como un programa separado del Lobby. Si una ventana de chat se cuelga o cierra, el Lobby ni se entera.
  - Comunicación IPC: Recibe instrucciones del Lobby (como "te están hablando") a través de un puerto UDP local efímero, permitiendo control remoto entre procesos padre-hijo.

gw_cmd.py (Despachador de Comandos)
  - Detalle: El cerebro lógico de la interacción textual.
  - Patrón Adapter: Diseñado para ser agnóstico. Recibe un "Adapter" (ya sea del Lobby o del Hijo) y ejecuta acciones abstractas como `create_group` o `scan_network`. Esto permite que el comando `--ls` funcione diferente en el Lobby (resumen global) que en un Chat (lista de miembros) usando el mismo código base.

3. INTERFAZ Y EXPERIENCIA DE USUARIO (UX)
-----------------------------------------
gw_pop.py (Gestor de Alertas Asíncronas)
  - Detalle: Módulo especializado en interrumpir visualmente al usuario de forma segura.
  - Tecnología: Encapsula llamadas a `zenity` (Linux) o scripts VBS (Windows) dentro de hilos de Python. Esto es vital para que un popup esperando "Aceptar/Cancelar" no congele la recepción de mensajes en el chat de fondo.

gw_display.py (Gestor de Estado y Persistencia)
  - Detalle: Resuelve la limitación de las consolas de texto donde "limpiar pantalla" implica perder información.
  - Mecanismo: Mantiene un "Buffer Fantasma" de todo el historial. Cuando el estado cambia (ej: llega un mensaje nuevo o cambia la IP), limpia la pantalla real y reconstruye instantáneamente la interfaz: primero el Banner actualizado (vía Callbacks) y luego todo el historial guardado.

gw_complete.py (Autocompletado Probabilístico)
  - Detalle: Lleva la experiencia de terminal al siguiente nivel usando `readline`.
  - Inteligencia: No solo completa texto, sino que "entiende" el contexto. Si escribes `--invite`, el módulo sabe que lo siguiente debe ser un usuario, y busca dinámicamente en tu memoria RAM (Contactos), en la caché de red (Peers) e incluso en el buffer visual de escaneos recientes para sugerirte nombres. Usa el algoritmo `difflib` para corregir errores tipográficos en tiempo real.
