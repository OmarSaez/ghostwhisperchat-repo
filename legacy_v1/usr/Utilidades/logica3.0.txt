# Documentación de Arquitectura GhostWhisperChat v42.x - "Lógica 3.0"
# ==========================================================================

Esta documentación detalla la evolución mayor de la arquitectura hacia un modelo **Daemonizado (Servicio)**, abandonando el modelo de aplicación de consola modular/microservicios para integrarse profundamente con el sistema operativo Linux.

## 1. Visión General: Arquitectura Cliente-Servidor Local

El sistema ahora opera bajo un paradigma de **Servicio Continuo (Daemon)** y **Cliente Liviano (CLI)**.

### A. El Daemon (Servicio Fantasma)
- **Rol**: Servidor Background (Demonio).
- **Proceso**: Se ejecuta silenciosamente al arrancar el sistema (gestionado por systemd).
- **Responsabilidad**:
  - Mantiene la conexión a la red P2P (UDP 44495 / TCP 44494).
  - Escucha invitaciones y mensajes las 24/7.
  - Gestiona el estado AFK (Away From Keyboard) automáticamente.
  - Genera notificaciones visuales (Zenity) integradas en el escritorio del usuario.
  - **No tiene interfaz (TUI)**: Su salida estándar se redirige a logs o systemd journal.

### B. El Cliente (CLI)
- **Rol**: Interfaz de Mando.
- **Proceso**: Efímero. Se lanza cuando el usuario escribe `gwc` en la terminal.
- **Responsabilidad**:
  - Conecta con el Daemon via IPC (UDP Localhost).
  - Envía comandos (`scan`, `status`, `chat`).
  - Imprime respuestas formateadas y colores recibidos del Daemon.
  - Se cierra inmediatamente tras ejecutar el comando, dejando al Daemon intacto.

---

## 2. Integración con el Sistema Operativo

### A. Systemd User Service (`ghostwhisperchat.service`)
- El núcleo de la persistencia.
- **Ubicación**: `~/.config/systemd/user/ghostwhisperchat.service`.
- **Comportamiento**:
  - `Autostart`: Se inicia al login gráfico del usuario.
  - `Restart`: Se reinicia automáticamente si crashea o tras una actualización (`gwc update`).
  - `Environment`: Tiene acceso a `:0` (Display) para lanzar ventanas (Pops).

### B. Gestión de Paquetes y Actualizaciones
- **Instalación (`postinst`)**:
  - Configura automáticamente el Firewall (UFW/IPTables) para abrir puertos 44494-44496.
  - Habilita el servicio systemd (`systemctl --user enable --now`).
- **Actualización (`perform_system_update`)**:
  - Descarga e instala `.deb` desde APT.
  - **Auto-Restart**: Al detectar nueva versión, reinicia el servicio systemd para cargar el nuevo código en memoria sin intervención del usuario.

### C. Firewall Automático
- El paquete `.deb` asegura que la red esté abierta:
  - `ufw allow 44494:44496/proto`
  - Reglas `iptables` persistentes para garantizar conectividad P2P entrante.

---

## 3. Nuevos Módulos y Lógica Refinada

### A. Sistema AFK (Event-Driven)
**Objetivo**: Marcar al usuario como "Ausente" si ignora invitaciones, limpiando el estado pendiente.
**Lógica**:
1.  **Trigger**: Llega una invitación (`INVITE`).
2.  **Acción**:
    - El Daemon lanza un subproceso visual (`gw_pop`) con un **Timer de 30s** gestionado por Zenity.
    - El Daemon sigue trabajando (no se bloquea).
3.  **Resolución**:
    - **Si el usuario acepta/rechaza**: Zenity retorna `0` o `1`. El Daemon procesa inmediatamente.
    - **Si el tiempo expira**: Zenity se cierra y retorna código `5`.
    - **Callback AFK**: El Daemon captura el código `5`, cambia el estado global a `Ausente-AFK`, limpia la invitación de memoria y envía un paquete `INVITE_REJ` al remitente por cortesía.
4.  **Restauración**:
    - Cualquier interacción con el Cliente CLI (`gwc status`, `gwc scan`) o aceptar una nueva invitación llama a `restore_from_afk()`, devolviendo el estado a "En línea".

### B. Sistema de Notificaciones Persistente
- **gw_pop.py**: Reescrito para ser robusto.
    - Soporta callbacks (`on_timeout`).
    - Maneja la concurrencia con Hilos Demonios para no congelar el networking.
- **Feedback**:
    - Invitaciones Rechazadas (por AFK o manual) envían comando `INVITE_REJ`.
    - El remitente recibe este comando y muestra una notificación visual indicando la razón ("Ausente (AFK)").

---

## 4. Comparativa: v2.0 vs v3.0

| Característica | Lógica 2.0 (App Consola) | Lógica 3.0 (Servicio Daemon) |
| :--- | :--- | :--- |
| **Ejecución** | Manual (abrir terminal) | Automática (Systemd boot) |
| **Persistencia** | Muere al cerrar terminal | Siempre vivo (24/7) |
| **Interfaz** | TUI (Text User Interface) | CLI (Comandos Puros) + Pops GUI |
| **Invitaciones** | Solo visible si miras la terminal | Popup visual sobre cualquier ventana |
| **Updates** | Manual + Reinicio manual | `gwc update` + Auto-Restart |
| **Network** | Depende de la ventana abierta | Independiente del UI |

---

## 5. Protocolos Nuevos (v3.0)

### A. Control del Daemon (IPC Local Mejorado)
- **CLI_CMD**: Protocolo texto plano sobre UDP Local.
- Estructura: `CLI_CMD | ReturnIP | ReturnPort | --argumentos`
- El Daemon procesa el argumento como si fuera input de usuario y devuelve la respuesta renderizada (con colores ANSI) al puerto efímero del cliente CLI para ser impresa.

### B. Etiqueta de Rechazo (P2P)
- **INVITE_REJ**:
    - **Args**: `[MPP Encabezado]`, `Razón (String)`.
    - **Uso**: Notificar explícitamente que una invitación falló o fue ignorada por AFK, cerrando el ciclo de incertidumbre UX en el remitente.


### ===== Descripcion de modulos =====

### 0. `ghostwhisperchat` (Módulo Core / Daemon Service)
- **Tipo**: Ejecutable principal (Entry Point).
- **Ubicación**: `/usr/bin/ghostwhisperchat`.
- **Responsabilidad (Nuevo Rol v3.0)**:
  - **Servicio Systemd**: Se ejecuta en background como daemon del usuario (`--daemon`).
  - **Orquestación**: Mantiene la red P2P viva 24/7 sin interfaz gráfica propia.
  - **Auto-Update**: Reinicia su propio servicio (`systemctl`) tras actualizarse.
  - **Gestión AFK**: Implementa la lógica `handle_afk_timeout` conectada a Zenity.
  - **Modo Cliente**: Si se invoca sin argumentos (`gwc`), actúa como cliente ligero que envía comandos IPC al Daemon.

### 1. `gw_comm.py` (Capa de Comunicación)
- **Propósito**: Motor de networking de bajo nivel.
- **Funciones**:
  - `build_packet / parse_packet`: Protocolo de serialización (Header|Len|Payload).
  - `start_tcp_listener / start_udp_listener`: Hilos demonio que escuchan en los puertos 44494/44495/44496.
  - `send_cmd`: Facade para enviar comandos de forma agnóstica (elije TCP o UDP según el caso).
  - `Secure Sockets`: Maneja timeouts, reconexiones básicas y errores de socket.

### 2. `gw_shared.py` (Configuración y Constantes)
- **Propósito**: "Fuente de la Verdad" compartida.
- **Contenido**:
  - **Configuración Global**: Puertos, Versión (`APP_VER_NUM`), Constantes de Tiempo (Pop Timeout).
  - **Definiciones de Comandos**: Diccionario `COMMAND_DEFS` que mapea alias (`--ayuda`, `-h`) a acciones internas.
  - **Utilidades Puras**: `normalize_str`, `calculate_file_hash`, `get_ip`.

### 3. `gw_cmd.py` (Lógica de Comandos)
- **Propósito**: Controlador de Comandos de Usuario.
- **Patrón Diseño**: Usa Inyección de Dependencia (`adapter`).
- **Flujo**:
  1. El usuario escribe `/nick Batman`.
  2. `gw_cmd.process` recibe el string.
  3. Identifica la acción `NICK`.
  4. Llama a `adapter.set_config('nick', 'Batman')`.
  - Si el adapter es el **Lobby**, cambia la config global y notifica a la red.
  - Si el adapter es un **Hijo**, envía una señal IPC al Lobby para que haga el cambio.

### 4. `gw_child.py` (Adaptador de Hijo)
- **Propósito**: Módulo de Sesión de Chat Aislada.
- **Responsabilidad**:
  - Mantiene el estado de UNA conversación (`PEERS` locales del grupo).
  - Dibuja la interfaz del chat (Prompt, Mensajes entrantes coloreados).
  - Maneja la lógica **Mesh** para grupos: Al enviar, itera sobre sus peers y hace N envíos TCP.
  - `ChildAdapter`: Implementa la interfaz requerida por `gw_cmd` para ejecutar comandos locales (`cls`, `exit`).

### 5. `gw_pop.py` (Gestor de Notificaciones Avanzado)
- **Propósito**: Interfaz con el sistema de ventanas del OS (`zenity`).
- **Novedades v3.0**:
  - **Event-Driven**: Soporta callbacks para eventos de cierre (`on_no`) y expiración de tiempo (`on_timeout`).
  - **Timeout Nativo**: Pasa la bandera `--timeout` a Zenity para que la ventana se gestione sola.
  - **Manejo de Errores**: Captura códigos de salida específicos (0=Sí, 1=No, 5=TimeOut).
- **API**:
  - `show(title, msg, duration)`: Lanza notificación efímera ("burbuja").
  - `show_question(title, text, on_yes, on_no, on_timeout, timeout)`: Diálogo modal con temporizador.

### 6. `gw_display.py` (Gestor de Interfaz / Buffer)
- **Propósito**: Manejo avanzado de la salida en terminal (TUI).
- **Problema que resuelve**: En el Lobby, llegan logs asíncronos (scans, debug) que romperían el prompt de entrada `Lobby >`.
- **Solución**: Mantiene un buffer de líneas y redibuja la pantalla limpiamente (`cls` + reimpresión) cada vez que hay nueva información, manteniendo el input del usuario intacto abajo.

### 7. `gw_complete.py` (Autocompletado)
- **Propósito**: Inteligencia de entrada (Tab-Completion).
- **Funciones**:
  - Se conecta con `readline` (librería estándar).
  - Sugiere comandos (`--...`) y, más importante, **Nicks e IPs**.
  - Contextual: Si escribes `--chatprivado `, te sugiere IPs de la lista de `KNOWN_USERS`.

---

## 3. Protocolos de Comunicación

El sistema utiliza tres capas de comunicación simultáneas:

### A. Capa Externa (Red LAN - Entre PCs)

1.  **UDP 44495 (Discovery Channel)**:
    -   **Uso**: Encontrar usuarios y grupos.
    -   **Comandos**:
        -   `WHOIS`: "Hola, ¿quién está ahí?".
        -   `I_EXIST`: "Aquí estoy" (Respuesta).
        -   `SEARCH_GROUP`: "¿Existe el grupo X?".
        -   `STATUS_UPDATE`: Notificar cambio de Nick/Estado.

2.  **TCP 44494 (Control & Private Data)**:
    -   **Uso**: Protocolo fiable para comandos críticos y chat 1-a-1.
    -   **Comandos**:
        -   `INVITE`: Iniciar una sesión.
        -   `CLOSE_PRIV`: Cerrar sesión formalmente (Protocolo Robustez).
        -   `FILE_TRANSFER`: Envío de flujo de bytes (Archivos).
        -   Mensajes de Chat Privado (Texto plano o encapsulado).

3.  **TCP 44496 (Group Mesh)**:
    -   **Uso**: Chat Grupal Descentralizado.
    -   **Lógica**: Cada miembro del grupo tiene la lista de IPs de los demás (`PEERS`). Al enviar un mensaje, el Hijo itera y envía copias Unicast TCP a cada miembro activo. No hay servidor central.
