#!/usr/bin/env python3
import os
import sys
import platform
import subprocess
import threading
import time
import socket
import json
import uuid
import re
import signal
import shutil
import unicodedata
import atexit
import ctypes
import urllib.request as request

# ... Imports ...
try:
    import gw_comm
    import gw_shared
    import gw_child
    import gw_pop
except ImportError:
    # Logic for manual path resolution
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. Check system install
    if os.path.exists("/usr/lib/ghostwhisperchat"):
        sys.path.append("/usr/lib/ghostwhisperchat")
    
    # 2. Check repo structure (../lib/ghostwhisperchat relative to bin)
    # script_dir is ".../usr/bin"
    # we want ".../usr/lib/ghostwhisperchat"
    repo_lib = os.path.join(os.path.dirname(script_dir), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
        sys.path.insert(0, repo_lib)

    # 3. Check CWD fallback (Dev root)
    if os.path.exists("ghostwhisperchat_pkg/usr/lib/ghostwhisperchat"):
        sys.path.insert(0, "ghostwhisperchat_pkg/usr/lib/ghostwhisperchat")
        
    try:
        import gw_comm
        import gw_shared
        import gw_child
        import gw_pop
        import gw_display
        import gw_complete
    except ImportError as e:
        print(f"CRITICAL ERROR: Could not import gw_comm/gw_shared module. Paths tried: {sys.path}")
        print(f"Error detail: {e}")
        # Log to file for child process visibility (Desktop)
        dsk = os.path.join(os.path.expanduser("~"), "Desktop")
        if not os.path.exists(dsk): dsk = os.path.join(os.path.expanduser("~"), "Escritorio")
        
        try:
            with open(os.path.join(dsk, "gwc_import_crash.log"), "a") as f:
                f.write(f"[{time.time()}] CRITICAL: Modules import failed. Env: {os.environ.get('PATH')}\n")
                f.write(f"Error: {e}\n")
        except: pass
        sys.exit(1)

# Aliases for compatibility
from gw_shared import Colors, COMMAND_DEFS, resolve_cmd, IPC_PORT, get_ip, calculate_file_hash, APP_VERSION, APP_VER_NUM, APP_VER_TAG, Loader, get_desktop_path, CMD_MAP
SEP = gw_comm.SEP
UDP_PORT = gw_comm.UDP_PORT
TCP_PORT = gw_comm.TCP_PORT
build_packet = gw_comm.build_packet
parse_packet = gw_comm.parse_packet

# ... (Rest of globals) ...

# ... (Functions like spawn_child_process need to use gw_shared vars) ...

def main():
    # ...
    if "--child" in sys.argv:
        try:
            # ... Parse args ...
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            port = sys.argv[sys.argv.index("--port")+1]
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Delegate to Module
            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

# --- CONFIGURACIN ---


multicast_group = ('224.0.0.1', 44496) # Multicast opcional (futuro)
BUFFER, LOG_FILE, CONFIG_FILE = 4096, "cyberdei_history.log", "cyberdei_config.json"



def find_free_port(start_port=5001, max_tries=50):
    for p in range(start_port, start_port + max_tries):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', p))
                return p
        except: continue
    return start_port # Fallback

DL_ROOT = get_desktop_path()
DL_DIR = os.path.join(DL_ROOT, "GhostWhisper_Recibidos")
if not os.path.exists(DL_DIR):
    try: os.makedirs(DL_DIR)
    except: pass
TIMERS = {'PRIV': 60, 'GROUP': 120, 'MANUAL': 300, 'INVITE': 15, 'BAN': 60}

# --- ESTADO PROCESOS ---
IS_CHILD = False
MY_CHILD_ID = None
PARENT_PID = None
CHILD_PROCESSES = {} # {ChatID: {'pid': PID, 'port': Port}} for Parent logic

# --- PILAS DE DATOS ---
PEERS = {}              # CONECTADOS: {IP: {'nick': Nick, 'chats': [ChatID1, ...]}}
PEER_STATUSES = {}      # ESTADOS CONECTADOS: {IP: Status}
KNOWN_USERS = {}        # HISTORIAL: {IP: {'nick': Nick, 'status': Status, 't': time}}
ACTIVE_CHATS = {}       # {ChatID: {'type': 'PRIV'/'GROUP', 'remote_id': ..., 'pass': ..., 'created_at': time}}
CURRENT_CHAT_ID = None

# GROUP_ID, GROUP_PASS = None, None # MOVIDO A ACTIVE_CHATS
MY_IP, MY_NICK, MY_STATUS = "", "An贸nimo", "En l铆nea"
DISC_TEMP, SCAN_RESULTS, PENDING_INVITE = [], [], None
POPUP_ON, USER_OFF, LAST_ACT = True, False, 0
HAS_ZENITY = False

def ensure_dependencies():
    """Instala zenity si falta en Linux (Debian/Kali/Ubuntu)"""
    if platform.system() == "Linux" and shutil.which("zenity") is None:
        try:
            print("\033[93m[!] Zenity no detectado. Instalando dependencias visuales...\033[0m")
            # Intentar apt-get silencioso
            subprocess.run(["sudo", "apt-get", "update", "-qq"], check=False)
            subprocess.run(["sudo", "apt-get", "install", "zenity", "-y", "-qq"], check=False)
        except: pass

ensure_dependencies()
HAS_ZENITY = shutil.which("zenity") is not None
AUTO_DL, LOG_ON, PENDING_FILES = True, False, []
VISIBLE_IN_SCAN = True 
SCANNING_NOW = False
SCAN_BUFFER = []
IS_AFK = False 


PROMPT = f"\001{Colors.B}\002Lobby > \001{Colors.E}\002"
print_lock = threading.Lock()

# --- UTILS ---
def set_terminal_title(title):
    """Establece el t铆tulo de la ventana de la terminal usando secuencias ANSI."""
    if platform.system() == "Windows":
        os.system(f"title {title}")
    else:
        # Secuencia est谩ndar XTerm (funciona en gnome, konsole, xfce, etc)
        sys.stdout.write(f"\x1b]2;{title}\x07")
        sys.stdout.flush()

def normalize_str(s):
    # Quita acentos y pasa a minusculas (ej: S谩ez -> saez)
    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn').lower()

def raw_print(s):
    # Imprime SIN guardar en historial
    # Si es hilo secundario (Async), restauramos el prompt visualmente.
    # Si es Main Thread (Sync), solo imprimimos (el input loop pondr谩 el prompt).
    with print_lock:
        if threading.current_thread() is threading.main_thread():
             print(s)
        else:
             try:
                 sys.stdout.write(f'\r\033[K{s}\n' + PROMPT + (readline.get_line_buffer() if 'readline' in sys.modules else ""))
                 sys.stdout.flush()
             except:
                 print(s)

def safe_print(s):
    # Imprime Y guarda en historial (Eventos publicos)
    if gw_display.DISPLAY: gw_display.DISPLAY.add(s)
    raw_print(s)

def reply_print(msg, target_cid=None):
    """
    Imprime en el destino correcto:
    - Si target_cid es None -> Imprime en Lobby (safe_print).
    - Si target_cid existe -> Env铆a IPC al hijo para que lo muestre.
    """
    if target_cid and target_cid in ACTIVE_CHATS:
        # Enviar al hijo
        cdata = ACTIVE_CHATS[target_cid]
        port = cdata.get('port')
        if port:
            # Usamos MSG_IN con 'Sistema' como remitente
            # Limpiamos colores para IPC? No, el hijo soporta colores.
            send_ipc(f"MSG_IN{SEP}Sistema{SEP}{msg}{SEP}{Colors.C}", port)
        else:
            safe_print(msg) # Fallback
    else:
        safe_print(msg)

def send_ipc(msg, port=IPC_PORT):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(msg.encode(), ('127.0.0.1', int(port)))
    except: pass





def write_log(txt, type="MSG"):
    if LOG_ON:
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                f.write(f"[{datetime.datetime.now().strftime('%F %T')}] [{type}] {txt}\n")
        except: pass

KNOWN_USERS = {} # {ip: {nick, status, t}}
DEBUG_MODE = False # v36.8

# --- UTILS VISUALES ---

def debug_log(msg):
    if DEBUG_MODE:
        s = f"{Colors.M}[DEBUG] {msg}{Colors.E}"
        safe_print(s)
        # v37.13: Persist debug to file
        try:
             dsk = get_desktop_path()
             path = os.path.join(dsk, "gwc_lobby_debug.log")
             with open(path, "a", encoding="utf-8") as f:
                 f.write(f"[{time.time()}] {msg}\n")
        except Exception as e:
             safe_print(f"{Colors.F}[!] Error escribiendo log en disco: {e}{Colors.E}")

# --- PROTOCOLO (Delegado a gw_comm) ---
# --- PROTOCOLO (Delegado a gw_comm) ---
# Funciones redirigidas totalmente al m贸dulo
def send_cmd(ip, cmd, *args):
    if LOG_ON:
         debug_log(f"[TX] CMD={cmd} DST={ip if ip else 'BCAST'} ARGS={args}")
    gw_comm.send_cmd(ip, cmd, *args)

def send_cmd_all(cmd, *args):
    gw_comm.send_cmd_all(cmd, *args)

def send_raw(ip, d):
    gw_comm.send_tcp_packet(ip, d)

# Popup Logic Delegated to gw_pop
def get_col(n): return Colors.PALETTE[sum(ord(c) for c in n) % len(Colors.PALETTE)] if n else Colors.WH

# --- CONFIG & STATE ---
    


# --- CONFIG & STATE ---
CONFIG_FILE = "inter_chat.json"
KNOWN_USERS = {} # {ip: {nick, status, t}}
TRUSTED_PEERS = set() # IPs de gente con chat privado exitoso {ip}
TRUSTED_NETS = {} # {network_id: {'trusted': bool, 'last_seen': ts, 'name': str}}
MY_NICK = socket.gethostname()
# ... rest of vars ...
ACTIVE_CHATS = {} # cid -> {type, remote_id, pass, process_handle, port}
PEERS = {} # ip -> {nick, chats: {cid1, cid2}}
PEER_STATUSES = {} # ip -> status_str
# SILENT_UPDATES_ALLOWED removed



def load_config():
    global KNOWN_USERS, MY_NICK, MY_STATUS, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, TRUSTED_NETS, TRUSTED_PEERS
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                d = json.load(f)
                KNOWN_USERS = d.get('known_users', {})
                MY_NICK = d.get('nick', MY_NICK)
                MY_STATUS = d.get('status', "En l铆nea")
                VISIBLE_IN_SCAN = d.get('visible', True)
                LOG_ON = d.get('log_on', True)
                gw_pop.POP.set_active(d.get('pop_on', True))
                gw_pop.POP.set_active(d.get('pop_on', True))
                AUTO_DL = d.get('auto_dl', True)
                return True
        except: pass
    return False

def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump({
                'known_users': KNOWN_USERS,
                'nick': MY_NICK,
                'status': MY_STATUS,
                'visible': VISIBLE_IN_SCAN,
                'log_on': LOG_ON,
                'pop_on': gw_pop.POP.pop_on,
                'log_on': LOG_ON,
                'pop_on': gw_pop.POP.pop_on,
                'auto_dl': AUTO_DL
            }, f, indent=4)
    except: pass

# --- NETWORK IDENTIFICATION ---
# Funciones get_network_id y check_network_trust ELIMINADAS por solicitud.
# La aplicaci贸n asume un entorno seguro o gestionado por el usuario.

def show_help(target_cid=None):
    lines = []
    lines.append(f" {Colors.BO}--- AYUDA Y COMANDOS ---{Colors.E}")
    
    cats = {
        "GESTIN DE CHATS": [
            ("--chatpersonal (Nick y/o IP)", "Crear un chat privado con un usuario."),
            ("--chatgrupal ID CLAVE", "Unirse/Crear sala."), 
            ("--invite (Nick1, Nick2...) y/o IPs", "Invitar gente al grupo actual."),
            ("--aceptar / --rechazar", "Responder a invitaciones pendientes."),
            ("--ls", "Listar usuarios CONECTADOS en el chat."), 
            ("--salir", "Desconectar de la sesi贸n.")
        ],
        "RED Y CONTACTOS": [
            ("--quienes", "Escanear red (驴Qui茅n est谩 online?)."),
            ("--contactos", "Ver historial de gente vista."),
            ("--quienes-si / --quienes-no", "Visibilidad en esc谩ner.")
        ],
        "UTILIDADES Y ARCHIVOS": [
            ("--archivo (Ruta)", "Enviar archivo."),
            ("--nombre (NuevoNick)", "Cambiar tu nombre visible."),
            ("--estado (Texto)", "Cambiar estado."),
            ("--estados-globales", "Ver resumen de configuraci贸n."),
            ("--abreviaciones", "Ver todos los formatos aceptados por cada comando."),
            ("--limpiar", "Limpiar pantalla.")
        ],
        "SISTEMA Y CONFIGURACIN": [
             ("--log on / off", "Guardar historial."),
             ("--descarga-si / --descarga-no", "Control descarga autom谩tica.")
        ]
    }

    for cat_name, cmds in cats.items():
        lines.append(f"\n {Colors.C}:: {cat_name} ::{Colors.E}")
        for c, d in cmds: 
            lines.append(f"   {Colors.BO}{c:<35}{Colors.E} : {d}")

    lines.append("-" * 60)
    
    full_msg = "\n".join(lines)
    if target_cid: reply_print(full_msg, target_cid)
    else: safe_print(full_msg)

def get_peer_name(ip):
    p = PEERS.get(ip)
    if p and isinstance(p, dict):
        return p.get('nick', ip)
    return ip

    """Imprime y guarda en historial para repintado"""
    safe_print(txt)


def get_lobby_status():
    return {
        'ip': MY_IP, 'nick': MY_NICK, 'visible': VISIBLE_IN_SCAN, 
        'status': MY_STATUS, 'chats': len(ACTIVE_CHATS), 
        'contacts': len(KNOWN_USERS),
        'ver': APP_VERSION
    }

def refresh_ui(msg=None):
    if gw_display.DISPLAY: gw_display.DISPLAY.refresh()
    if msg: safe_print(msg)

# --- RED ---
def lazy_import():
    global json, difflib, urllib, unicodedata, request, datetime, uuid
    import json, difflib, datetime, uuid, unicodedata
    import urllib.request as request
    
def get_ip():
    # Optimization: Use a dummy socket to get preferred outgoing IP without actual connection
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            # Google DNS IP (doesn't need to be reachable)
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except:
        return "127.0.0.1"

def fw_cfg():
    if platform.system() == "Linux":
        # 1. Intentar UFW (Ubuntu/Debian standard)
        try:
            for c in [[f"{p}/tcp", f"{p}/udp"] for p in [TCP_PORT, UDP_PORT]]:
                subprocess.run(["sudo", "ufw", "allow"] + c, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
        # 2. Intentar IPTABLES (Kali/RedHat/Arch fallback)
        # sudo iptables -C INPUT -p tcp --dport 44494 -j ACCEPT 2> /dev/null || sudo iptables -A INPUT -p tcp --dport 44494 -j ACCEPT
        try:
            for p, proto in [(TCP_PORT, 'tcp'), (UDP_PORT, 'udp')]:
                rule = ["sudo", "iptables", "-A", "INPUT", "-p", proto, "--dport", str(p), "-j", "ACCEPT"]
                # Check simple para no duplicar (es complejo en python puro, lanzamos el add y que iptables decida si duplica o no)
                # Mejor intentar solo si no existe, pero para simplificar lanzamos append.
                # Si el user no tiene sudo sin pass, fallara silencioso.
                subprocess.run(rule, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
    elif platform.system() == "Windows":
        subprocess.run(["powershell", f"Start-Process cmd -Verb RunAs -ArgumentList '/c netsh advfirewall firewall add rule name=\"CyberDEI\" dir=in action=allow protocol=ANY localport=\"{TCP_PORT},{UDP_PORT}\"'"], shell=True)

# send_raw eliminado (Replaced by alias above)
def send_all(d, targets=None):
    if targets is None:
        # Enviar solo a usuarios del chat actual
        targets = []
        if CURRENT_CHAT_ID:
            for ip, pdata in PEERS.items():
                if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                    targets.append(ip)

    for ip in [i for i in targets if i != MY_IP]: send_raw(ip, d)

# --- DISCOVERY & MEMORY ---
def update_memory(ip, nick, status):
    """Actualiza memoria y guarda en config"""
    global KNOWN_USERS
    now = time.time()
    
    # Detectar cambio de nombre
    old_nick = None
    if ip in KNOWN_USERS:
        old_nick = KNOWN_USERS[ip].get('nick', nick)
    
    KNOWN_USERS[ip] = {'nick': nick, 'status': status, 't': now}
    
    if old_nick and old_nick != nick:
        safe_print(f"{Colors.C}[Info] '{old_nick}' ahora se llama '{nick}'{Colors.E}")
        # Notificar a los hijos (para que en el chat se vea el cambio)
        # Iterar chats activos y enviar mensaje de sistema
        for cid, cdata in ACTIVE_CHATS.items():
            # Si es privado y es con esa IP:
            if cdata['type'] == 'PRIV' and cdata.get('remote_id') == ip:
                 cdata['remote_nick'] = nick # Actualizar metadata interna
                 # Send alert to child
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}El usuario cambio su nombre a {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))
            
            # Si es grupo, avisar tambien (mas complejo filtrar si esta en el grupo, pero avisamos igual si es relevante)
            if cdata['type'] == 'GROUP':
                 # Verificar si IP esta en grupo? Simplificamos: enviamos a todos los grupos activos
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}{old_nick} ahora es {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))

    if ip in PEERS:
        if isinstance(PEERS[ip], dict):
             PEERS[ip]['nick'] = nick
    save_config()

def handle_incoming_udp(d, ip):
    global PEERS, DISC_TEMP, PEER_STATUSES, SCAN_RESULTS
    
    msg = d.decode('utf-8', errors='ignore')
    debug_log(f"[UDP] Recibido de {ip}: {msg[:100]}") # Show first 100 chars
    
    if ip == MY_IP: return

    is_cmd, cmd, args = parse_packet(msg)

    if not is_cmd: return # Ignorar mensajes no estructurados en UDP

    if cmd == "SEARCH_GROUP":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                    send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

                gw_comm.send_udp_cmd(ip, "I_EXIST", gid, gpass, MY_NICK, MY_STATUS)

    elif cmd == "I_EXIST":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                        send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

    elif cmd == "WHOIS":
        # args[0] = target_nick (puede ser vac铆o)
        target = args[0].strip().lower() if args else ""

        # Soy yo?
        if not target or target == MY_NICK.lower():
            gw_comm.send_udp_cmd(ip, "USER_HERE", MY_NICK, MY_STATUS)

    elif cmd == "USER_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            # Check duplicate in DISC_TEMP
            if not any(x[0] == ip for x in DISC_TEMP):
                DISC_TEMP.append((ip, nick, st))
            update_memory(ip, nick, st)

    elif cmd == "WHO_ALL" and VISIBLE_IN_SCAN:
        gw_comm.send_udp_cmd(ip, "IAM_HERE", MY_NICK, MY_STATUS)

    elif cmd == "IAM_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            SCAN_RESULTS.append({'ip': ip, 'nick': nick, 'status': st})
            update_memory(ip, nick, st)

def find_global(t):
    target_clean = normalize_str(t)
    
    # 1. Check known
    for ip, d in KNOWN_USERS.items():
        if normalize_str(d['nick']) == target_clean or ip == t: return ip
        
    for ip, p in PEERS.items():
         if isinstance(p, dict) and normalize_str(p.get('nick', '')) == target_clean: return ip
         
    # 2. Discovery UDP
    safe_print(f"{Colors.W}[*] Buscando '{t}'...{Colors.E}")
    global DISC_TEMP
    DISC_TEMP = [] 
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHOIS", t), ('255.255.255.255', UDP_PORT)); u.close()
    
    time.sleep(2)
    
    for res in DISC_TEMP:
        # res = (ip, nick, status)
        # Check MATCH EXACTO (Insensitive)
        if normalize_str(res[1]) == target_clean:
            safe_print(f"{Colors.G}[+] Encontrado: {res[1]} en {res[0]}{Colors.E}")
            return res[0]
            
    safe_print(f"{Colors.F}[X] Usuario '{t}' no encontrado.{Colors.E}")
    
    # --- FUZZY SEARCH / SUGERENCIAS ---
    suggs = set() # (nick, ip)

    # Helper local
    def check_sim(n, ip):
        n_clean = normalize_str(n)
        if target_clean in n_clean: return True # Contenido exacto
        # Similitud > 55%
        if difflib.SequenceMatcher(None, target_clean, n_clean).ratio() > 0.55: return True
        return False

    # 1. Buscar en Resultados UDP
    for res in DISC_TEMP:
        if check_sim(res[1], res[0]): suggs.add((res[1], res[0]))

    # 2. Buscar en Historial Conocidos
    for ip, data in KNOWN_USERS.items():
        if check_sim(data['nick'], ip): suggs.add((data['nick'], ip))

    if suggs:
        safe_print(f"{Colors.W}驴Quiz谩s quisiste decir?:{Colors.E}")
        for snick, sip in suggs:
            safe_print(f"   > {Colors.BO}{snick}{Colors.E} ({sip})")

    return None

def scan_network(target_cid=None):
    global SCAN_RESULTS
    reply_print(f"{Colors.W}[*] Escaneando red local (1s)...{Colors.E}", target_cid)
    SCAN_RESULTS = []; u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHO_ALL"), ('255.255.255.255', UDP_PORT)); u.close(); time.sleep(1) # Optimizacion 2s -> 1s

    reply_print(f"{Colors.G}[*] Equipos Encontrados ({len(SCAN_RESULTS)}):{Colors.E}", target_cid)
    for res in SCAN_RESULTS:
        reply_print(f"   > {Colors.BO}{res['nick']}{Colors.E} ({res['ip']}) [{res['status']}]", target_cid)
    if not SCAN_RESULTS: reply_print("   (Ninguno visible)", target_cid)

def leave_sess(silent=False, exclude_ip=None, target_cid=None):
    global PEERS, PEER_STATUSES, CURRENT_CHAT_ID
    
    # Si no se especifica CID, usar el global (contexto Lobby)
    cid_to_close = target_cid if target_cid else CURRENT_CHAT_ID
    
    if not cid_to_close or cid_to_close not in ACTIVE_CHATS:
        if not silent: safe_print(f"{Colors.W}[!] Sesi贸n no v谩lida.{Colors.E}")
        return

    if not silent: safe_print(f"{Colors.W}[*] Cerrando sesi贸n {cid_to_close}...{Colors.E}")

    # Send disconnect to peers in THIS chat
    c = ACTIVE_CHATS[cid_to_close]
    to_remove = []

    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and cid_to_close in pdata.get('chats', []):
            if ip != exclude_ip:
                if c['type'] == 'GROUP':
                    send_cmd(ip, "LEAVE_GRP", c['remote_id'], MY_NICK)
                else: # PRIV
                    # Use CLOSE_PRIV instead of DISCONNECT_NOW for safer, granular closing
                    send_cmd(ip, "CLOSE_PRIV", MY_NICK, str(time.time()))
            # Remove chat_id linkage
            pdata['chats'].discard(cid_to_close) # Use discard to be safe
            if not pdata['chats']: # Empty, user gone
                to_remove.append(ip)

    for ip in to_remove:
        if ip in PEERS: del PEERS[ip]
        if ip in PEER_STATUSES: del PEER_STATUSES[ip]

    # Matar proceso hijo si existe y no soy yo mismo el hijo suicid谩ndose
    if 'port' in ACTIVE_CHATS[cid_to_close]:
         # Enviamos kill por si acaso, aunque el hijo ya se haya ido
         send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid_to_close]['port'])

    del ACTIVE_CHATS[cid_to_close]
    
    # Si cerr茅 la sesi贸n activa del Lobby, limpiar variable
    if CURRENT_CHAT_ID == cid_to_close:
        CURRENT_CHAT_ID = None
        
    if not silent: safe_print(f"{Colors.G}[] Sesi贸n {cid_to_close} cerrada.{Colors.E}")
    refresh_ui()

def start_private_chat(ip, nick, status="En l铆nea", send_ack=True):
    global CURRENT_CHAT_ID
    cid = str(uuid.uuid4())[:8]
    ACTIVE_CHATS[cid] = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': nick}
    CURRENT_CHAT_ID = cid

    if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
    if isinstance(PEERS[ip], dict):
        PEERS[ip]['nick'] = nick
        PEERS[ip]['chats'].add(cid)

    PEER_STATUSES[ip] = status
    update_memory(ip, nick, status)
    
    if send_ack:
        # v36.12 CRITICAL FIX: Send acceptance to inviter so they open their window!
        debug_log(f"[PROTOCOLO] Enviando INVITE_ACC (Confirmaci贸n) a {ip}...")
        # V2: INVITE_ACC uses [MPP]
        send_cmd(ip, "INVITE_ACC", get_my_mpp())
    debug_log(f"[PROTOCOLO] INVITE_ACC enviado. Ahora abriendo mi consola...")
    
    spawn_child_process(cid, ACTIVE_CHATS[cid]) # Spawn child immediately
    refresh_ui()
    refresh_ui(f"{Colors.G}[*] Chat privado con {nick} iniciado.{Colors.E}")
    return cid

def join_grp(gid, gp, exclude_ip=None):
    # Ya no salimos de la sesi贸n anterior forzosamente
    # if PEERS: leave_sess(...) <--- REMOVED

    global CURRENT_CHAT_ID
    global PEERS, PEER_STATUSES

    if not CURRENT_CHAT_ID: return # Should not happen in child context

    safe_print(f"{Colors.G}[*] Conectando a '{gid}'...{Colors.E}")

    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("SEARCH_GROUP", gid, gp, MY_NICK, MY_STATUS), ('255.255.255.255', UDP_PORT)); u.close()

    time.sleep(2)
    # Check if peers found in this chat
    found_any = False
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
            found_any = True
            break

    if found_any:
        safe_print(f"{Colors.G}[] Unido.{Colors.E}")
        send_cmd_all("JOINED", MY_NICK, MY_STATUS); write_log(f"Grupo {gid}", "SYS")
    else:
        safe_print(f"{Colors.G}[] Sala creada (esperando peers).{Colors.E}"); write_log(f"Sala {gid}", "SYS")

    # Trigger Update Check on trusted peers in this group
    # Necesitamos la lista de IPs. Si es un join reciente, PEERS se va poblando.
    # Mejor hacerlo tras unos segundos o usar los que ya conocemos que est谩n ah铆.
    # Disparamos un hilo retardado
    # threading.Thread(target=lambda: (time.sleep(5), try_trigger_updates(list(PEERS.keys())))).start()
    pass

def invite_users(targets_str, target_cid=None):
    cid = target_cid if target_cid else CURRENT_CHAT_ID
    if not cid or cid not in ACTIVE_CHATS:
        return safe_print(f"{Colors.F}[!] Debes estar en un chat activo.{Colors.E}")

    chat = ACTIVE_CHATS[cid]
    if chat['type'] != 'GROUP':
        return safe_print(f"{Colors.F}[!] Solo puedes invitar en grupos.{Colors.E}")

    gid = chat['remote_id']
    gpass = chat['pass']

    targets = [t.strip() for t in targets_str.split(',')]

    members_list = ", ".join([d['nick'] for d in PEERS.values() if isinstance(d, dict) and cid in d.get('chats', [])])
    # payload = f"GRP_INVITE_REQ{SEP}{MY_NICK}{SEP}{gid}{SEP}{gpass}{SEP}{members_list}".encode() # Old

    safe_print(f"{Colors.W}[*] Enviando invitaciones...{Colors.E}")
    count = 0
    for t in targets:
        ip = find_global(t)
        if ip:
            pdata = PEERS.get(ip)
            if pdata and isinstance(pdata, dict) and cid in pdata.get('chats', []):
                 safe_print(f"   > {t}: Ya est谩 en el grupo.")
            else:
                send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, members_list)
                safe_print(f"   > {t}: Invitaci贸n enviada.")
                count += 1
        else:
            gw_complete.suggest_user(t) # Added this line

    if count > 0:
        send_cmd_all("GRP_MSG", gid, f"[Grupo] {MY_NICK} ha invitado a {count} usuarios.")

# --- CORE ---
def set_afk_mode(cause_ip=None, cause_nick=None):
    global MY_STATUS, IS_AFK
    IS_AFK = True
    if not MY_STATUS.endswith("-AFK"): MY_STATUS += "-AFK"
    msg = f"{Colors.W}[!] Solicitud de {Colors.BO}{cause_nick}{Colors.E} {Colors.W}({cause_ip}) auto-rechazada. Entrando en AFK.{Colors.E}" if cause_nick else f"{Colors.W}[!] Timeout. Entrando en AFK.{Colors.E}"
    safe_print(msg); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def restore_from_afk():
    global MY_STATUS, IS_AFK
    if not IS_AFK: return
    IS_AFK = False
    if MY_STATUS == "Ausente (AFK)": MY_STATUS = "En l铆nea"
    elif MY_STATUS.endswith("-AFK"): MY_STATUS = MY_STATUS[:-4]
    safe_print(f"{Colors.G}[i] Bienvenido de vuelta. Estado: {MY_STATUS}{Colors.E}"); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def handle_invite_logic(ip, nick, type, extra_data=None):
    global PENDING_INVITE, PEER_STATUSES
    inviter_status = PEER_STATUSES.get(ip, "")

    req_text = ""
    if type == "PRIV": 
        req_text = f" 隆Hey! {nick} ({ip}) quiere iniciar una conversaci贸n contigo.\n\n驴Te gustar铆a aceptar la conexi贸n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat PRIV de {nick} ({ip})")
    else: 
        gid, gpass, members = extra_data
        req_text = f" {nick} quiere que formes parte del grupo \"{gid}\".\n\n驴Te unes a la conversaci贸n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat GROUP {gid} de {nick}")

    # --- GUI HANDLING (v26.1 Style: Popen + Polling) ---
    proc = None
    if platform.system() == "Linux" and HAS_ZENITY:
        try:
            proc = subprocess.Popen(["zenity", "--question", "--title=Invitaci贸n CyberDEI", f"--text={req_text}", "--timeout=30"], stderr=subprocess.DEVNULL)
        except: pass

    elif platform.system() == "Windows":
        # Windows Popen non-blocking
        # Strip emojis for Windows compatibility (PowerShell encoding issues)
        txt_win = req_text.encode('ascii', 'ignore').decode() 
        t_safe = txt_win.replace("\n", "`n").replace("'", "''")
        
        script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        $res = [System.Windows.Forms.MessageBox]::Show('{t_safe}', 'Invitaci贸n', 'YesNo', 'Question')
        if ($res -eq 'Yes') {{ exit 0 }} else {{ exit 1 }}
        """
        try:
             proc = subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", script], stderr=subprocess.DEVNULL)
        except: pass

    # Wait for GUI response if launched
    if proc:
        start_t = time.time()
        answered = False
        while time.time() - start_t < 30: # 30s timeout
            if proc.poll() is not None:
                answered = True
                debug_log(f"[INVITE_LOGIC] GUI process finished (Return Code: {proc.returncode})")
                break
            time.sleep(0.5) # Evitar consumo CPU 100%

        if answered:
            if proc.returncode == 0: # YES
                # Construir dict temporal y llamar yes
                safe_print(f"{Colors.M}[GUI] Aceptando invitaci贸n...{Colors.E}")
                debug_log(f"[INVITE_LOGIC] Usuario acept贸 en GUI. Ejecutando --y")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--y")
            else:
                debug_log(f"[INVITE_LOGIC] Usuario rechaz贸 en GUI. Ejecutando --n")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--n") # NO
            return
        else:
            # Timeout GUI -> AFK PROTOCOL
            try: proc.terminate()
            except: pass
            
            safe_print(f"{Colors.W}[!] Sin respuesta. Entrando en modo AFK.{Colors.E}")
            set_afk_mode(cause_ip=ip, cause_nick=nick)
            send_cmd(ip, "INVITE_REJ", MY_NICK, "Auto-AFK")
            return # Evitar fallback a CLI si ya fall贸 GUI

    # --- CLI FALLBACK (Solo si no hay GUI) ---
    # Set global pending invite DICTIONARY so --y/--n works in Lobby
    PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}

    msg_print(f"\n{Colors.M}**********************************{Colors.E}")
    msg_print(f"{Colors.M}* {req_text.upper()}{Colors.E}")
    msg_print(f"{Colors.M}* Escribe --y para Aceptar o --n para Rechazar{Colors.E}")
    msg_print(f"{Colors.M}**********************************{Colors.E}")
    safe_print("\a") # Beep

    # Loop de espera pasiva para CLI
    start_wait = time.time()
    while time.time() - start_wait < 30:
        if PENDING_INVITE is None: return # Respondido
        time.sleep(1)

    # Timeout CLI
    if PENDING_INVITE and PENDING_INVITE['ip'] == ip:
        msg_print(f"{Colors.F}[!] Invitaci贸n de {nick} expirada.{Colors.E}")
        send_cmd(ip, "INVITE_REJ", MY_NICK, "Timeout")
        PENDING_INVITE = None




# --- UTILS v36.0 ---
def calculate_file_hash(path):
    sha256_hash = hashlib.sha256()
    with open(path, "rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def dl_file(name, size, sock, sender, sender_ip=None, expected_hash=None, file_type='FILE'):
    if not os.path.exists(DL_DIR): os.makedirs(DL_DIR)
    tmp = os.path.join(DL_DIR, f".tmp_{int(time.time())}_{name}")
    try:
        with open(tmp, "wb") as f:
            r = 0
            while r < size:
                ch = sock.recv(min(BUFFER, size-r)); 
                if not ch: break
                f.write(ch); r += len(ch)
    except Exception as e: return safe_print(f"{Colors.F}Error DL: {e}{Colors.E}")

    # v36.0: Integrity Check
    if expected_hash:
        safe_print(f"{Colors.W}[*] Verificando integridad...{Colors.E}")
        cal_hash = calculate_file_hash(tmp)
        if cal_hash != expected_hash:
             safe_print(f"{Colors.F}[X] ERRO INTEGRIDAD: Hash mismatch.{Colors.E}")
             safe_print(f"    Esperado: {expected_hash[:8]}...")
             safe_print(f"    Recibido: {cal_hash[:8]}...")
             os.remove(tmp)
             return
        else:
             safe_print(f"{Colors.G}[] Integridad verificada.{Colors.E}")

    final_path = os.path.join(DL_DIR, name)
    
    # v36.0: Folder Logic (Si es DIR, es un zip que debemos descomprimir)
    is_zip_archive = (file_type == 'DIR')
    
    if AUTO_DL:
        if os.path.exists(final_path): 
            base, ext = os.path.splitext(name)
            final_path = os.path.join(DL_DIR, f"{base}_copy_{int(time.time())}{ext}")
        
        # Rename or Unzip
        if is_zip_archive:
             # Es un directorio comprimido. Le quitamos la extension .zip al nombre final si la tiene
             folder_final_path = final_path.replace('.zip', '')
             shutil.unpack_archive(tmp, folder_final_path)
             os.remove(tmp) # Borrar zip temporal
             final_path = folder_final_path + " (Carpeta)"
        else:
             os.rename(tmp, final_path)

        safe_print(f"{Colors.G}[] Archivo guardado: {final_path}{Colors.E}")
        popup(f"De: {sender}", f"Guardado: {name}", source_ip=sender_ip); write_log(f"Recibido {name}", "FILE")
        
        # Notify Local Chat Windows (Feature Request)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         # Send System Notification to Child
                         tag = f"[{Colors.C}{Colors.E}]"
                         msg = f"{Colors.C}{sender} ha enviado {'una carpeta' if is_zip_archive else 'un archivo'}: {name}{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

    else:
        # pending files logic, store hash/type for later accept? 
        # For simplicity, we assume if we are here we already accepted stream or stream happens anyway.
        # But wait, logic says "Wait for accept" BUT tcp stream ALREADY downloaded to tmp.
        # So we just keep tmp stored in PENDING_FILES with the metadata.
        PENDING_FILES.append({'t': tmp, 'r': final_path, 's': sender, 'hash': expected_hash, 'type': file_type})
        safe_print(f"{Colors.W}[?] '{name}' de {sender} espera (--aceptar/--rechazar).{Colors.E}"); popup("Archivo", f"{sender}: {name}", source_ip=sender_ip)
        
        # Notify Local Chat Windows (Manual Wait)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         tag = f"[{Colors.C}{Colors.E}]"
                         msg = f"{Colors.C}{sender} env铆a archivo: {name}. Escribe --aceptar.{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

def handle_incoming_tcp(c, ip, raw):
    global POPUP_ON, LAST_ACT, USER_OFF, PENDING_INVITE

    try:
        if raw:
            # 1. Intentar parsear como Paquete Estructurado v27
            is_cmd, cmd, args = parse_packet(raw)

            if is_cmd:
                # Auto-add to known if interaction happens
                if ip not in PEERS:
                    if ip in KNOWN_USERS:
                        PEERS[ip] = {'nick': KNOWN_USERS[ip]['nick'], 'chats': set()}
                    else:
                        PEERS[ip] = {'nick': "...", 'chats': set()}

                curr_nick = PEERS[ip]['nick']

                if not USER_OFF:
                    # Simple logic for popup, ignoring PRIVATE_PEER timeout logic for now
                    if not POPUP_ON and (time.time()-LAST_ACT > 30): POPUP_ON = True

                # BLOCK MODULAR DE COMANDOS
                if cmd == "INVITE":
                    # args: NICK, TYPE, (GID, GPASS, MEMBERS if group)
                    debug_log(f"[RED] Recibido INVITE de {ip}")
                    if len(args) >= 2:
                        nick, type = args[0], args[1]
                        extra = None
                        if type == "GROUP" and len(args) >= 5:
                            extra = (args[2], args[3], args[4]) # gid, pass, members

                        PEERS[ip]['nick'] = nick
                        st = args[len(args)-1] if type == "PRIV" and len(args) >= 3 else "?" # Status is last arg for PRIV
                        PEER_STATUSES[ip] = st
                        update_memory(ip, PEERS[ip]['nick'], st) # Sync al recibir
                        
                        debug_log(f"[INVITE_LOGIC] Iniciando logica de invitacion para {nick} (Tipo: {type})")
                        threading.Thread(target=handle_invite_logic, args=(ip, nick, type, extra)).start()

                elif cmd == "INVITE_ACC":
                    # args: R_NICK, R_STATUS
                    debug_log(f"[RED] Recibido INVITE_ACC de {ip}. Procesando aceptaci贸n...")
                    if len(args) >= 2:
                            r_nick, r_stat = args[0], args[1]
                            
                            # Buscar invitacion pendiente mia hacia esa IP?
                            # Asumimos que si llega INVITE_ACC es porque invitamos.
                            # Creamos sala PRIV
                            cid = str(uuid.uuid4())[:8]
                            cdata = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': r_nick}
                            ACTIVE_CHATS[cid] = cdata
                            
                            # LINK ROUTING
                            if ip not in PEERS: PEERS[ip] = {'nick': r_nick, 'chats': set()}
                            if isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].add(cid)
                                debug_log(f"[RED] Vinculada IP {ip} a CID {cid} (INVITE_ACC)")
                            
                            # TRUSTED PEERS (Add logic)
                            TRUSTED_PEERS.add(ip); save_config()

                            # Threading spawn to avoid blocking TCP loop (Fix Slowness)
                            debug_log(f"[PROCESO] Iniciando consola hija para chat confirmado {cid}")
                            threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
                            refresh_ui(f"{Colors.G}[*] {r_nick} acept贸 tu invitaci贸n.{Colors.E}")
                            
                            # TRIGGER UPDATE CHECK (Private)
                            # Esperar un poco para estabilidad TCP
                            # threading.Thread(target=lambda: (time.sleep(3), try_trigger_updates([ip]))).start(); 
                            write_log(f"Privado ok {r_nick}", "SYS")

                elif cmd == "INVITE_REJ":
                    # args: NICK, REASON
                    reason = args[1] if len(args)>1 else "?"
                    safe_print(f"{Colors.F}[X] {args[0]} rechaz贸 la invitaci贸n ({reason}).{Colors.E}")
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    PENDING_INVITE = None

                elif cmd == "INVITE_TOUT":
                    # args: NICK, STATUS
                    n = args[0] if len(args)>0 else curr_nick
                    st = args[1] if len(args)>1 else "AFK"
                    safe_print(f"{Colors.W}[!] {n} no respondi贸 (Timeout). Estado: {st}{Colors.E}")
                    update_memory(ip, n, st)
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]

                elif cmd == "GRP_INVITE_ACC":
                        # args: NICK
                        safe_print(f"{Colors.G}[] {args[0]} se uni贸 al grupo.{Colors.E}")
                        # UDP SEARCH_GROUP will handle the actual peer linkage.

                elif cmd == "JOINED":
                    # args: NICK, STATUS
                    PEERS[ip]['nick'] = args[0]
                    st = args[1] if len(args)>1 else ""
                    PEER_STATUSES[ip] = st
                    update_memory(ip, args[0], st)

                    pdata = PEERS.get(ip)
                    if pdata and isinstance(pdata, dict):
                        for cid in pdata.get('chats', set()):
                            if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                                if ACTIVE_CHATS[cid]['type'] == 'GROUP':
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.G}[+] {args[0]} entr贸 al grupo.{Colors.E}"
                                    send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

                    safe_print(f"{Colors.G}[+] {args[0]} entr贸.{Colors.E}") # Lobby Log

                elif cmd == "CHILD_EXIT":
                    cid = args[0]
                    if cid in ACTIVE_CHATS:
                        # Clean up
                        if 'port' in ACTIVE_CHATS[cid]: del ACTIVE_CHATS[cid]
                        # No borramos de PEERS aqui, solo la sesi贸n activa
                        pass

                    # Usamos safe_print antes del refresh para historial
                    safe_print(f"{Colors.G}[*] Chat cerrado (CID: {cid}).{Colors.E}")
                    refresh_ui()

                elif cmd == "GRP_MSG":
                    # args: GID, MSG
                    if len(args) >= 2:
                        gid, msg_content = args[0], args[1]
                        # Buscar localmente el chat que tiene remote_id == gid_target
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                            curr_nick = PEERS.get(ip, {}).get('nick', '?')
                            tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"
                            send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg_content}", ACTIVE_CHATS[target_cid]['port'])
                            write_log(f"[{curr_nick} @ {gid}]: {msg_content}", "CHAT")

                elif cmd == "STATUS_UPDATE":
                    # args: NICK, STATUS
                    if len(args) >= 2:
                        PEERS[ip]['nick'] = args[0]
                        PEER_STATUSES[ip] = args[1]
                        update_memory(ip, args[0], args[1])
                    elif len(args) == 1:
                        PEER_STATUSES[ip] = args[0]
                        update_memory(ip, curr_nick, args[0])

                elif cmd == "LEAVE_PRIV":
                    # args: NICK
                    safe_print(f"{Colors.W}[!] Un chat privado ha sido cerrado por {args[0]}.{Colors.E}")
                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]
                    refresh_ui()

                elif cmd == "LEAVE_GRP":
                    # args: GID, NICK
                    if len(args) >= 2:
                        gid, nick = args[0], args[1]
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid:
                            tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                            msg = f"{Colors.F}[] {nick} sali贸 del grupo.{Colors.E}"
                            if 'port' in ACTIVE_CHATS[target_cid]:
                                send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[target_cid]['port'])

                            if ip in PEERS and isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].discard(target_cid)
                        refresh_ui()

                elif cmd == "DISCONNECT_NOW":
                    # args: NICK
                    nick_disc = args[0] if args else "?"
                    safe_print(f"{Colors.F}[!] {nick_disc} se desconect贸 globalmente.{Colors.E}")

                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)
                        elif cdata['type'] == 'GROUP':
                            pdata = PEERS.get(ip)
                            if pdata and cid in pdata.get('chats', set()):
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.F}[] {nick_disc} se desconect贸.{Colors.E}"
                                    if 'port' in cdata: send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", cdata['port'])

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]

                    if ip in PEERS: del PEERS[ip]
                    if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    refresh_ui()

                elif cmd == "VER_CHECK" or cmd == "REQ_UPDATE" or cmd == "PUSH_UPDATE" or cmd == "VER_INFO":
                        pass # Deprecated P2P Update Commands
                    
                elif cmd == "WHOIS":
                    debug_log(f"Received WHOIS from {ip}")
                    pass

                elif cmd == "FILE_TRANSFER":
                    # args: FNAME, SIZE, [HASH, TYPE]
                    if len(args) >= 2:
                        fname = args[0]
                        fsize = int(args[1])
                        fhash = args[2] if len(args) > 2 else None
                        ftype = args[3] if len(args) > 3 else 'FILE'

                        target_cid = None
                        pdata = PEERS.get(ip)
                        if pdata and isinstance(pdata, dict):
                            for cid in pdata.get('chats', set()):
                                    if cid in ACTIVE_CHATS: target_cid = cid; break
                        
                        display_name = fname + " (Carpeta)" if ftype == 'DIR' else fname
                        safe_print(f"{Colors.W}[] Recibiendo '{display_name}' ({fsize} bytes)...{Colors.E}")
                        threading.Thread(target=dl_file, args=(fname, fsize, c, get_peer_name(ip), ip, fhash, ftype)).start()
                        return True # Keep socket open for thread

            else:
                # 2. NO ES COMANDO V27 -> Mensaje de Chat Privado (Texto Plano)
                debug_log(f"[TCP_ROUTING] Recibido mensaje plano de {ip}: '{raw[:20]}...'")
                
                target_cid = None
                pdata = PEERS.get(ip)
                if pdata:
                    chats = pdata.get('chats', set())
                    debug_log(f"[TCP_ROUTING] Chats asociados a IP {ip}: {chats}")
                    for cid in chats:
                            if cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'PRIV':
                                target_cid = cid
                                break
                else:
                        debug_log(f"[TCP_ROUTING] IP {ip} no encontrada en PEERS.")
                
                curr_nick = PEERS.get(ip, {}).get('nick', '?')
                tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"

                if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                        debug_log(f"[TCP_ROUTING] Reenviando por IPC a CID {target_cid} (Port {ACTIVE_CHATS[target_cid]['port']})")
                        send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{raw}{SEP}{ip}", ACTIVE_CHATS[target_cid]['port'])
                        write_log(f"[{curr_nick}] (FWD {target_cid}): {raw}", "CHAT")
                else:
                    debug_log(f"[TCP_ROUTING] Fallo de enrutamiento para {ip}: CID={target_cid}")
                    safe_print(f"{tag}: {raw}"); popup(f"MSG: {curr_nick}", raw, source_ip=ip); write_log(f"[{curr_nick}]: {raw}", "CHAT")

    except Exception as e:
        # safe_print(f"Err TCP: {e}")
        pass
    
    return False # Default close

def send_file(arg, target_cid=None):
    path = os.path.expanduser(arg.strip().strip("'\""))
    if not os.path.exists(path): return safe_print(f"{Colors.F}[X] No existe.{Colors.E}") # isfile -> exists (for dirs)
    
    # v36.0: Folder Support
    is_dir = os.path.isdir(path)
    to_send_path = path
    file_type = 'FILE'
    
    if is_dir:
        safe_print(f"{Colors.W}[*] Comprimiendo carpeta '{os.path.basename(path)}'...{Colors.E}")
        # Crear zip temporal
        # make_archive (base_name, format, root_dir)
        # shutil.make_archive generar谩 filename + .zip
        tmp_zip_base = f".gwc_tmp_{int(time.time())}"
        shutil.make_archive(tmp_zip_base, 'zip', path)
        to_send_path = tmp_zip_base + ".zip"
        file_type = 'DIR'
    
    # Calculate integrity
    f_hash = calculate_file_hash(to_send_path)
    n, s = os.path.basename(to_send_path) if not is_dir else os.path.basename(path) + ".zip", os.path.getsize(to_send_path)

    # Target logic same as send_all
    targets = []
    
    # Use explicit target_cid if provided, else rely on global (legacy)
    cid_to_use = target_cid if target_cid else CURRENT_CHAT_ID
    
    if cid_to_use:
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and cid_to_use in pdata.get('chats', []):
                targets.append(ip)

    if not targets: return safe_print(f"{Colors.F}[X] Nadie en el chat actual.{Colors.E}")

    safe_print(f"{Colors.W}[] Enviando '{n}' ({s} bytes, Hash: {f_hash[:8]})...{Colors.E}"); write_log(f"Send {n}", "FILE")

    cnt = 0
    for ip in [i for i in targets if i != MY_IP]:
        try:
            k = socket.socket(socket.AF_INET, socket.SOCK_STREAM); k.settimeout(2); k.connect((ip, TCP_PORT))
            # PACKET v36: FILE_TRANSFER | NAME | SIZE | HASH | TYPE
            k.send(build_packet("FILE_TRANSFER", n, s, f_hash, file_type)); time.sleep(0.1)
            with open(to_send_path, "rb") as f:
                while True:
                    d = f.read(BUFFER);
                    if not d: break
                    k.sendall(d)
            k.close(); cnt += 1
        except Exception as e: safe_print(f"Err Send: {e}")
    safe_print(f"{Colors.G}[] Enviado a {cnt}.{Colors.E}")
    
    # Cleanup tmp zip
    if is_dir and os.path.exists(to_send_path):
        os.remove(to_send_path)

def send_ipc(msg, port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # No necesario para enviar
        s.sendto(msg.encode(), ('127.0.0.1', port))
        s.close()
    except: pass

# --- ACTUALIZACIN DE SISTEMA (REPO APT) ---
VERSION_URL = "https://omarsaez.github.io/ghostwhisperchat-repo/version.txt"

def perform_system_update():
    """Ejecuta los comandos de sistema para actualizar"""
    safe_print(f"{Colors.M}[*] Ejecutando actualizaci贸n de sistema...{Colors.E}")
    try:
        # Encadenamos update e install
        # apt install --only-upgrade asegura que no instale cosas nuevas, solo actualice lo que hay
        cmd = "sudo apt update && sudo apt install ghostwhisperchat --only-upgrade -y"
        
        subprocess.run(cmd, shell=True, check=True)
        
        safe_print(f"{Colors.G}[] Actualizaci贸n lista. Reiniciando servicio...{Colors.E}")
        
        # v42.3: Force Service Restart to load new code
        subprocess.run("systemctl --user restart ghostwhisperchat", shell=True)
        time.sleep(2) # Esperar un poco a que el daemon arranque
        
        # Reiniciar el script autom谩ticamente (CLI)
        os.execv(sys.executable, ['python3'] + sys.argv)
        
    except subprocess.CalledProcessError:
        safe_print(f"{Colors.F}[X] Error en la actualizaci贸n (驴Contrase帽a incorrecta?){Colors.E}")
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error inesperado: {e}{Colors.E}")

def check_repo_update():
    """Verifica silenciosamente si el repo tiene una versi贸n mayor (Daemon safe)"""
    if platform.system() != "Linux": return 
    try:
        with request.urlopen(VERSION_URL, timeout=3) as response:
            content = response.read().decode().strip()
            latest_ver = float(content)
        if latest_ver > APP_VER_NUM:
            # Notify only
            msg = f"Nueva versi贸n disponible: v{latest_ver}. Ejecuta 'ghostwhisperchat --update' para instalar."
            safe_print(f"{Colors.W}[!] {msg}{Colors.E}")
            # Try to show system notification if possible
            try: popup("Sistema", msg)
            except: pass
    except: pass

def trigger_manual_update():
    """Llamado desde CLI --update"""
    safe_print(f"{Colors.M}[*] Verificando 煤ltimas versiones...{Colors.E}")
    try:
        with request.urlopen(VERSION_URL, timeout=5) as response:
            content = response.read().decode().strip()
            server_ver = float(content)
            
        if server_ver > APP_VER_NUM:
            safe_print(f"{Colors.G}[!] Versi贸n {server_ver} encontrada. Actualizando...{Colors.E}")
            perform_system_update()
        else:
            safe_print(f"{Colors.G}[] GhostWhisperChat est谩 actualizado (v{APP_VER_NUM}).{Colors.E}")
            
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error verificando actualizaciones: {e}{Colors.E}")

# ... existing code ...

def toggle_autostart(enable, target_cid=None):
    """Activa o desactiva el inicio autom谩tico en Linux (.config/autostart)"""
    if platform.system() != "Linux":
        return reply_print(f"{Colors.F}[!] Solo disponible en Linux por ahora.{Colors.E}", target_cid)
        
    autostart_dir = os.path.expanduser("~/.config/autostart")
    desktop_file = os.path.join(autostart_dir, "inter_chat_auto.desktop")
    
    if enable:
        try:
            if not os.path.exists(autostart_dir): os.makedirs(autostart_dir)
            
            # Obtener rutas absolutas
            exe = sys.executable
            script = os.path.abspath(sys.argv[0])
            
            content = f"""[Desktop Entry]
Type=Application
Name=InterChat Auto
Exec={exe} "{script}"
Terminal=true
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Comment=Auto-start InterChat Lobby
"""
            with open(desktop_file, "w") as f:
                f.write(content)
            
            # Dar permisos de ejecuci贸n al script por si acaso
            # os.chmod(script, 0o755) # Comentado: Falla en /usr/bin/ si no eres root. Ya deber铆a ser ejecutable.
            
            reply_print(f"{Colors.G}[] Autolevantado ACTIVADO (Inicio de sesi贸n).{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error activando autostart: {e}{Colors.E}", target_cid)
    else:
        try:
            if os.path.exists(desktop_file):
                os.remove(desktop_file)
                reply_print(f"{Colors.W}[] Autolevantado DESACTIVADO.{Colors.E}", target_cid)
            else:
                reply_print(f"{Colors.W}[!] No estaba activado.{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error desactivando: {e}{Colors.E}", target_cid)

# --- COMANDOS LOBBY CENTRALIZADOS ---
def exec_lobby_cmd(inp, origin_cid=None):
    import gw_cmd
    gw_cmd.process(inp, origin_cid, LOBBY_ADAPTER)

class LobbyAdapter:
    def reply(self, msg, cid):
        # Lobby context reply
        if not cid: safe_print(msg)
        else:
             # Support CLI response
             if cid.startswith("CLI:"):
                 try:
                     _, rip, rport = cid.split(":")
                     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                     s.sendto(str(msg).encode(), (rip, int(rport)))
                     s.close()
                 except: pass
                 return

             if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                  # Forward as System Message
                  # Format: MSG_IN | Sender | Text | Color
                  send_ipc(f"MSG_IN{gw_comm.SEP}Sistema{gw_comm.SEP}{msg}{gw_comm.SEP}{Colors.C}", ACTIVE_CHATS[cid]['port'])
             else:
                  safe_print(msg)

    def create_group(self, remote_id, password):
        # UX: Animation "Connecting"
        with Loader(f"{Colors.C}[*] Sincronizando grupo '{remote_id}'{Colors.E}"):
             time.sleep(3.5)
             
             # 1. Create Local Session
             cid = str(uuid.uuid4())[:8]
             cdata = {
                'type': 'GROUP', 'remote_id': remote_id, 'pass': password, 
                'created_at': time.time(), 'remote_nick': f"Grupo {remote_id}"
             }
             ACTIVE_CHATS[cid] = cdata
        
             # 2. Spawn Child
             threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
        
             # 3. Network Discovery (V2)
             gw_comm.send_cmd(None, "SEARCH_GROUP", get_my_mpp(), remote_id, password)
             
        # Restore Prompt
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def find_global(self, args): return find_global(args)

    def join_group(self, cid): pass # Unused, create_group handles join logic

    def invite_priv(self, ip, nick, status):
        # V2 Logic + Loader
        with Loader(f"{Colors.C}[*] Conectando con {nick} ({ip})...{Colors.E}"):
             time.sleep(1.5)
             gw_comm.send_cmd(ip, "INVITE", get_my_mpp(), "PRIV")
        
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def get_chat(self, cid): return ACTIVE_CHATS.get(cid)
    def get_my_info(self): return MY_NICK, MY_IP, MY_STATUS
    def get_mpp(self): return get_my_mpp()
    def get_peers(self): return PEERS
    
    def show_lobby_summary(self):
         safe_print(f"{Colors.G}--- RESUMEN DE RED ---{Colors.E}")
         safe_print(f"Total de Usuarios Conocidos: {len(PEERS) + 1}")
         safe_print(f"{Colors.BO} > {MY_NICK} ({MY_IP}) [Yo]{Colors.E}")
         for ip, d in PEERS.items():
             est = d.get('status','?') # PEERS structure update V40
             # In V40 we use PEERS[ip] = {nick, ver, status?}
             # Fallback to PEER_STATUSES[ip] if simpler
             est = PEER_STATUSES.get(ip, est)
             n = d.get('nick', '?')
             safe_print(f" - {n} ({ip}) [{est}]")
             
         safe_print(f"\n{Colors.G}Sesiones de Chat Activas ({len(ACTIVE_CHATS)}):{Colors.E}")
         for cid, d in ACTIVE_CHATS.items():
             safe_print(f" - [{cid}] {d['type']}: {d.get('remote_nick', d['remote_id'])}")

    def get_known_users(self): 
        # Merge Saved (KNOWN_USERS) + Runtime (PEERS)
        ku = KNOWN_USERS.copy()
        for ip, d in PEERS.items():
            ku[ip] = {
                'nick': d.get('nick','?'), 
                'status': PEER_STATUSES.get(ip, d.get('status', '?')), 
                't': time.time()
            }
        return ku

    def scan_network(self, cid):
        def _scan_task():
            global SCANNING_NOW, SCAN_BUFFER, PEERS
            SCAN_BUFFER = []
            SCANNING_NOW = True
            
            # 1. Purge Ghosts (Fresh Scan Logic)
            # Remove peers not involved in local chats
            to_remove = [ip for ip, d in PEERS.items() if not d.get('chats')]
            for ip in to_remove: 
                if ip in PEERS: del PEERS[ip]

            initial_peers = len(PEERS)
            
            # Send Broadcast
            gw_comm.send_cmd_all("WHOIS", get_my_mpp())
            
            # Animation Wait (3s)
            if not cid:
                with Loader(f"{Colors.C}[*] Escaneando red{Colors.E}"):
                    time.sleep(3)
            else:
                time.sleep(3)
                
            SCANNING_NOW = False
            
            # Flush Buffer
            for m in SCAN_BUFFER:
                if cid: self.reply(m, cid)
                else: safe_print(m)
            
            # SHOW DETAILED LIST
            if PEERS:
                msg_list = [f"{Colors.G}--- RESULTADOS EN RED ({len(PEERS)}) ---{Colors.E}"]
                for ip, d in PEERS.items():
                    msg_list.append(f" - {d.get('nick','?')} ({ip}) [{d.get('status','?')}]")
                final_msg = "\n".join(msg_list)
                self.reply(final_msg, cid)
            else:
                self.reply(f"{Colors.W}[!] No se detectaron nodos activos.{Colors.E}", cid)
            
            # Check delta (Optional Summary)
            final_peers = len(PEERS)
            new_found = final_peers - initial_peers
            if new_found > 0:
                 self.reply(f"{Colors.G}[+] {new_found} nuevos.{Colors.E}", cid)

            # Restore Prompt if in Lobby
            if not cid:
                sys.stdout.write(PROMPT)
                sys.stdout.flush()
        
        threading.Thread(target=_scan_task, daemon=True).start()

    def check_integrity(self, cid):
        report = []
        report.append(f"{Colors.H}=== REPORTE DE INTEGRIDAD ({APP_VERSION}) ==={Colors.E}")
        
        # 1. DEPENDENCIAS
        deps = [("zenity", "Interfaz de Ventanas"), ("python3", "Motor Python"), ("fuser", "Gestor Procesos")]
        report.append(f"\n{Colors.BO}:: Dependencias del Sistema ::{Colors.E}")
        for bin_name, desc in deps:
            found = shutil.which(bin_name)
            st = f"{Colors.G}OK{Colors.E}" if found else f"{Colors.F}锔 FALTA{Colors.E}"
            report.append(f" - {desc} ({bin_name}): {st}")

        # 2. PUERTOS (Daemon Health)
        report.append(f"\n{Colors.BO}:: Estado de Puertos (Daemon) ::{Colors.E}")
        ports = [
            (gw_comm.TCP_PORT_PRIV, "TCP Privado (Mensajer铆a)"),
            (gw_comm.UDP_PORT_DISC, "UDP Discovery (Escaneo)"),
            (gw_comm.TCP_PORT_GRP,  "TCP Mesh (Grupos)")
        ]
        
        for p, d in ports:
             report.append(f" - Puerto {p} ({d}): {Colors.G}EN ESCUCHA{Colors.E}")

        # 3. INTERNALS
        report.append(f"\n{Colors.BO}:: Subsistema IPC & Hijos ::{Colors.E}")
        report.append(f" - IPC Port: {IPC_PORT}")
        
        child_ok_count = 0
        for xcid, xcdata in ACTIVE_CHATS.items():
            if 'pid' in xcdata:
                 try: 
                     os.kill(xcdata['pid'], 0)
                     child_ok_count += 1
                 except: pass
        
        st_child = f"{Colors.G}OK{Colors.E}" if child_ok_count == len(ACTIVE_CHATS) else f"{Colors.W}Mismatch{Colors.E}"
        report.append(f" - Hijos Activos: {len(ACTIVE_CHATS)} (Vivos: {child_ok_count})")
        report.append(f" - Estado General Hijos: {st_child}")

        # 2. SISTEMA DE ARCHIVOS (Nuevo)
        report.append(f"\n{Colors.BO}:: Sistema de Archivos ::{Colors.E}")
        log_dir = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
        
        if not os.path.exists(log_dir):
            try: 
                os.makedirs(log_dir)
                st_fs = f"{Colors.G}OK (Creado){Colors.E}"
            except: st_fs = f"{Colors.F}ERROR (No se pudo crear){Colors.E}"
        else:
            if os.access(log_dir, os.W_OK): st_fs = f"{Colors.G}OK (Escritura permitida){Colors.E}"
            else: st_fs = f"{Colors.F}FALLO (Permisos denegados){Colors.E}"
            
        report.append(f" - Config Folder (~/.ghostwhisperchat): {st_fs}")

        # 3. RED (Nuevo)
        report.append(f"\n{Colors.BO}:: Estado de Red ::{Colors.E}")
        my_ip_detected = get_ip()
        if my_ip_detected == "127.0.0.1": 
             st_net = f"{Colors.W}ALERTA (Loopback - Posiblemente desconectado){Colors.E}"
        else:
             st_net = f"{Colors.G}OK (Interfaz Externa){Colors.E}"
        report.append(f" - IP Detectada: {my_ip_detected} -> {st_net}")

        # 4. ENTORNO GRFICO & TERMINAL
        report.append(f"\n{Colors.BO}:: Entorno Gr谩fico ::{Colors.E}")
        
        # Zenity Test
        try:
             zver = subprocess.check_output(["zenity", "--version"], stderr=subprocess.DEVNULL).decode().strip()
             report.append(f" - Zenity: {Colors.G}OK (v{zver}){Colors.E}")
        except:
             report.append(f" - Zenity: {Colors.F}FALLO (Binario existe pero no ejecuta){Colors.E}")
        
        
        terms = ["gnome-terminal", "mate-terminal", "tilix", "terminator", "konsole", "xfce4-terminal", "qterminal", "xterm", "x-terminal-emulator"]
        found_term = None
        for t in terms:
            if shutil.which(t):
                 found_term = t
                 break
        
        if found_term:
             report.append(f" - Terminal Detectada: {Colors.G}{found_term}{Colors.E}")
             
             try:
                 # TEST LIVE: Intentar abrir una ventana que sobreviva 3 segundos
                 cmd_test = []
                 sleep_cmd = "sleep 3" 
                 
                 # GNOME Fix: Use --wait to actually wait for the window
                 if found_term == "gnome-terminal":
                     cmd_test = [found_term, "--wait", "--", "sh", "-c", sleep_cmd]
                 elif found_term in ["mate-terminal", "xfce4-terminal"]:
                     cmd_test = [found_term, "--", "sh", "-c", sleep_cmd]
                 elif found_term == "konsole":
                      cmd_test = [found_term, "-e", "sh", "-c", sleep_cmd]
                 elif found_term == "terminator":
                      cmd_test = [found_term, "-x", "sh", "-c", sleep_cmd]
                 else: # xterm, etc
                      cmd_test = [found_term, "-e", f"sh -c '{sleep_cmd}'"]
                 
                 report.append(f"    Tecnolog铆a: {found_term}")
                 report.append(f"    Comando Test: {' '.join(cmd_test)}") 

                 # Ejecutar test
                 p = subprocess.Popen(cmd_test, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                 
                 # Dar tiempo visible (2s)
                 time.sleep(2.0) 
                 
                 ret = p.poll()
                 if ret is not None:
                     # Si termin贸 antes de 3s:
                     if ret != 0: st_spawn = f"{Colors.F}FALLO (Exit Code {ret}){Colors.E}"
                     else: st_spawn = f"{Colors.W}OK? (Cerr贸 antes de 3s - 驴Falta --wait o flag incompatible?){Colors.E}"
                 else:
                     # Sigue corriendo. Exitoso.
                     p.kill() # Limpiar
                     st_spawn = f"{Colors.G}EXITOSO (Ventana persistente detectada){Colors.E}"

             except Exception as e:
                 st_spawn = f"{Colors.F}ERROR ({e}){Colors.E}"

             report.append(f" - Test de Consola Hija: {st_spawn}")
             if "FALLO" in st_spawn or "ERROR" in st_spawn:
                 report.append(f"   {Colors.W} Sugerencia: Faltan librer铆as gr谩ficas o DISPLAY mal configurado.{Colors.E}")
             
        else:
             report.append(f" - Terminal: {Colors.F}NO DETECTADA{Colors.E}")
             report.append(f"   {Colors.W} Instala: sudo apt install gnome-terminal (o mate-terminal / xterm){Colors.E}")
        
        self.reply("\n".join(report), cid)
    
    def set_config(self, key, val):
        global VISIBLE_IN_SCAN, MY_STATUS, MY_NICK, LOG_ON, AUTO_DL, USER_OFF
        if key == 'visible': VISIBLE_IN_SCAN = val
        elif key == 'status': MY_STATUS = val
        elif key == 'nick': MY_NICK = val
        elif key == 'log_on': LOG_ON = val

        elif key == 'auto_dl': AUTO_DL = val
        save_config()
        refresh_ui()

    def broadcast_status(self, st=None): 
        # V2 STATUS_UPDATE: [CMD]STATUS_UPDATE|1|[MPP][CMD]
        # MPP already contains new Status/Nick
        gw_comm.send_cmd(None, "STATUS_UPDATE", get_my_mpp())

    def update_title(self): set_terminal_title(f"GWC Lobby - {MY_NICK}")
    def toggle_autostart(self, val, cid): toggle_autostart(val, cid)
    
    def clear_screen(self, cid):
        if gw_display.DISPLAY: gw_display.DISPLAY.history = []
        if cid: self.reply(f"{Colors.G}Pantalla limpiada.{Colors.E}", cid)
        else: refresh_ui()

    def suggest_command(self, invalid):
        if gw_complete.COMPLETER:
             sugs = gw_complete.COMPLETER.suggest_command(invalid)
             if sugs:
                 safe_print(f"{Colors.W}Comando no encontrado. Quiz谩s quisiste decir:{Colors.E}")
                 for s in sugs: safe_print(f"  - {s}")
             else:
                 safe_print(f"{Colors.W}Comando no encontrado. Prueba --help.{Colors.E}")
    
    def suggest_user(self, invalid):
        if gw_complete.COMPLETER:
             sugs = gw_complete.COMPLETER.suggest_user(invalid)
             if sugs:
                 safe_print(f"{Colors.W}Usuario no encontrado. Quiz谩s buscas a:{Colors.E}")
                 for s in sugs: safe_print(f"  - {s}")

    def invite_users(self, args_str, cid):
        # Logic V2: Parse args (Nick/IPs) -> Send INVITE
        targets = args_str.replace(",", " ").split()
        
        # UX Animation
        if not cid:
             # Only loader if inside Lobby (otherwise child does its own thing or stream interrupts)
             # But if User types help in child, here we are in LobbyAdapter?
             # invite_users from Child passes cid.
             # If cid is active, Loader inside Lobby text is weird for child user.
             # Child user expects reply "Invitando...".
             pass
        
        # Universal Loader if CID is None (Lobby Command)
        if not cid:
            loader = Loader(f"{Colors.C}[*] Enviando invitaciones{Colors.E}")
            loader.__enter__()
            time.sleep(1.5)
        
        for t in targets:
            # Check if IP or Nick
            target_ip = None
            if "." in t and len(t.split(".")) == 4: target_ip = t
            else:
                # Resolve Nick
                for ip, p in PEERS.items():
                    if p.get('nick') == t: target_ip = ip; break
            
            if target_ip:
                inv_type = "PRIV"
                extras = []
                if cid and cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'GROUP':
                     inv_type = "GROUP"
                     gid = ACTIVE_CHATS[cid]['remote_id']
                     gp = ACTIVE_CHATS[cid].get('pass', '')
                     extras = [gid, gp]
                     
                gw_comm.send_cmd(target_ip, "INVITE", get_my_mpp(), inv_type, *extras)
                self.reply(f"{Colors.G}[] Invitaci贸n enviada a {t} ({target_ip}){Colors.E}", cid)
            else:
                self.reply(f"{Colors.R}[X] No encontrado: {t}{Colors.E}", cid)
                self.suggest_user(t)
        
        if not cid:
            loader.__exit__(None, None, None)
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def send_file(self, args, cid): send_file(args, target_cid=cid)
    def leave_sess(self, cid): leave_sess(target_cid=cid)
    def shutdown_app(self): shutdown_lobby()
    
    def handle_accept(self, cid):
        global PENDING_INVITE
        if not PENDING_INVITE: return reply_print(f"{Colors.W}No tienes invitaciones pendientes.{Colors.E}", cid)
        
        restore_from_afk() # Restore status if we were AFK
        
        # UX Animation (Only if Lobby)
        if not cid:
            with Loader(f"{Colors.C}[*] Sincronizando sesi贸n{Colors.E}"):
                time.sleep(1.5)
        else:
             reply_print(f"{Colors.G}[*] Aceptando...{Colors.E}", cid)

        if PENDING_INVITE['type'] == 'GROUP':
             self.create_group(PENDING_INVITE['data'][0], PENDING_INVITE['data'][1])
             self.reply(f"{Colors.G}[*] Grupo creado/unido.{Colors.E}", cid)
        else:
             start_private_chat(PENDING_INVITE['ip'], PENDING_INVITE.get('nick','?'))
        PENDING_INVITE = None
        
        # Restore prompt if Lobby
        if not cid:
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def handle_deny(self, cid):
        global PENDING_INVITE
        if PENDING_INVITE:
             reply_print(f"{Colors.W}[*] Invitaci贸n rechazada.{Colors.E}", cid)
             send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Rechazado")
             PENDING_INVITE = None
        else:
             reply_print(f"{Colors.W}Nada que rechazar.{Colors.E}", cid)

    def get_var(self, name):
        if name == 'visible': return VISIBLE_IN_SCAN
        if name == 'auto_dl': return AUTO_DL

        if name == 'log_on': return LOG_ON
        return None

    def get_active_chats(self): return ACTIVE_CHATS
    def get_version_str(self): return APP_VERSION
    
    def show_contacts(self, cid):
        users = self.get_known_users()
        self.reply(f"{Colors.G}[*] Historial de Sesi贸n ({len(users)}):{Colors.E}", cid)
        for ip, d in users.items(): 
            msg = f"   - {d['nick']} ({ip}) [{d['status']}] (Visto: {time.strftime('%H:%M', time.localtime(d['t']))})"
            self.reply(msg, cid)

    def show_global_status(self, cid):
        import gw_cmd
        gw_cmd.show_global_status(self, cid)

    def toggle_debug(self):
        global DEBUG_MODE
        DEBUG_MODE = not DEBUG_MODE
        # Logic from command
        # dsk = get_desktop_path()... we assume caller handles logging the toggle status via reply
        return DEBUG_MODE

LOBBY_ADAPTER = LobbyAdapter()

# --- PROCESOS & LOBBY ---

def check_child_health():
    """Vigila si los procesos hijos siguen vivos. Si no, limpia la sesi贸n."""
    while True:
        time.sleep(2) # v37.26: Faster check (2s)
        to_kill = []
        for cid, data in list(ACTIVE_CHATS.items()):
            if 'pid' in data:
                pid = data['pid']
                try:
                    # Check if process exists (signal 0 does nothing but checks access)
                    os.kill(pid, 0)
                except OSError:
                    # Process died
                    to_kill.append(cid)
                    
        for cid in to_kill:
             if cid in ACTIVE_CHATS:
                 cdata = ACTIVE_CHATS[cid]
                 rem_nick = cdata.get('remote_nick', cdata.get('remote_id', '?'))
                 type_s = cdata.get('type', '?')
                 
                 safe_print(f"\n{Colors.W}[Info] Se detect贸 cierre de ventana ({type_s}: {rem_nick}). Limpiando sesi贸n...{Colors.E}")
                 
                 # v37.26: Use consistent disconnect logic
                 # Using leave_sess logic manually here to avoid modifying dict while iterating if leave_sess does strange things,
                 # but actually leave_sess removes from ACTIVE_CHATS.
                 # Let's replicate safe leave logic:
                 
                 # Avisar al remoto si es privado
                 if cdata['type'] == 'PRIV':
                     if 'remote_id' in cdata:
                         send_cmd(cdata['remote_id'], "DISCONNECT_NOW", MY_NICK)
                 elif cdata['type'] == 'GROUP':
                     if 'remote_id' in cdata:
                          send_cmd_all("LEAVE_GRP", cdata['remote_id'], MY_NICK)
                 
                 # Remove local
                 del ACTIVE_CHATS[cid]

def spawn_child_process(cid, cdata):
    # Asignar puerto 煤nico para este hijo (IPC)
    # Buscamos puerto libre o usamos hash/incremental
    child_port = IPC_PORT + 1
    # Optimization: Limited search range
    for i in range(100): 
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', child_port))
            break # Free
        except: child_port += 1
    
    cdata['port'] = child_port
    rnick = cdata.get('remote_nick', '?')

    script_path = os.path.abspath(sys.argv[0])
    
    # Create Child Environment with correct PYTHONPATH for source execution
    child_env = os.environ.copy()
    repo_lib = os.path.join(os.path.dirname(os.path.dirname(script_path)), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
         old_pp = child_env.get("PYTHONPATH", "")
         child_env["PYTHONPATH"] = f"{repo_lib}{os.pathsep}{old_pp}" if old_pp else repo_lib
    
    cmd_args = [
        sys.executable, script_path, 
        "--child", cid,
        "--type", cdata['type'],
        "--remote", cdata['remote_id'],
        "--pass", str(cdata['pass']),
        "--nick", MY_NICK,
        "--status", MY_STATUS,
        "--port", str(child_port),
        "--rnick", rnick
    ]
    
    # CRITICAL FIX for Parrot/MATE & Others: Wrap in shell to handle args correctly
    import shlex
    inner_cmd = " ".join([shlex.quote(str(x)) for x in cmd_args])
    shell_wrapper = ["sh", "-c", f"exec {inner_cmd}"] # exec to replace shell pid

    debug_log(f"Spawn start ({time.time()}) CMD: {inner_cmd}")
    
    # Detectar terminal
    try:
        terminal_cmd = None
        if shutil.which("gnome-terminal"):
            terminal_cmd = ["gnome-terminal", "--wait", "--"] + shell_wrapper
        elif shutil.which("mate-terminal"):
             # Parrot OS / MATE Desktop Support
             terminal_cmd = ["mate-terminal", "--disable-factory", "--"] + shell_wrapper
        elif shutil.which("tilix"):
             terminal_cmd = ["tilix", "-e"] + shell_wrapper
        elif shutil.which("terminator"):
             # Terminator -x expects string if simple, but list works often. Safe bet implies -x "cmd".
             # But here we use list structure compatibility.
             terminal_cmd = ["terminator", "-x", "sh", "-c", inner_cmd]
        elif shutil.which("konsole"):
            terminal_cmd = ["konsole", "--nofork", "-e"] + shell_wrapper
        elif shutil.which("xfce4-terminal"):
             terminal_cmd = ["xfce4-terminal", "--disable-server", "--"] + shell_wrapper
        elif shutil.which("qterminal"):
             terminal_cmd = ["qterminal", "-e"] + shell_wrapper
        elif shutil.which("xterm"):
             terminal_cmd = ["xterm", "-e"] + shell_wrapper
        elif shutil.which("x-terminal-emulator"):
             terminal_cmd = ["x-terminal-emulator", "-e"] + shell_wrapper
        
        if terminal_cmd:
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            try:
                 dlog = open(log_path, "a")
                 dlog.write(f"\n[{time.time()}] Launching Primary: {' '.join(terminal_cmd)}\n")
                 proc = subprocess.Popen(terminal_cmd, stdout=dlog, stderr=dlog, env=child_env)
            except:
                 proc = subprocess.Popen(terminal_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, env=child_env)
            
            time.sleep(0.5)
            poll_res = proc.poll()
            
            if poll_res is not None and poll_res != 0:
                print(f"{Colors.F}[!] Error: La terminal fall贸 (Code {proc.returncode}).{Colors.E}")
                # Fallback to background
                log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
                with open(log_path, "a") as err_log:
                    # Also pass env to fallback
                    proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid
        else:
            print(f"{Colors.F}[!] No se encontr贸 terminal compatible.{Colors.E}")
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            with open(log_path, "a") as err_log:
                proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid

        # Feedback
        if cdata['type'] == 'GROUP':
            gid = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir谩 una nueva consola para el chat grupal {gid}.{Colors.E}")
        else:
            target = cdata.get('remote_nick', '?')
            if target == '?': target = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir谩 una nueva consola para el chat privado con {target}.{Colors.E}") 

    except Exception as e:
        print(f"{Colors.F}[!] Error lanzando terminal: {e}{Colors.E}")

# --- CONFIG POP ---
# Limits from gw_shared are used: POP_RESET_TIME, MAX_POPS_BURST
CHAT_ACTIVITY = {} # cid -> {'last': t, 'pops': n}

def check_pop_allowance(cid):
    now = time.time()
    if cid not in CHAT_ACTIVITY:
         CHAT_ACTIVITY[cid] = {'last': now, 'pops': 0}
         return True # First ever
         
    dt = now - CHAT_ACTIVITY[cid]['last']
    CHAT_ACTIVITY[cid]['last'] = now # Update activity timestamp
    
    if dt > gw_shared.POP_RESET_TIME:
         # Reset counter
         CHAT_ACTIVITY[cid]['pops'] = 0
    
    if CHAT_ACTIVITY[cid]['pops'] < gw_shared.MAX_POPS_BURST:
         CHAT_ACTIVITY[cid]['pops'] += 1
         return True
    
    return False

def register_outgoing_activity(cid):
    # Called when Child sends a msg (via CMD_ACTIVITY)
    # Simply updates timestamp, keeping conversation "Active"
    # This suppression prevents pops if I am replying.
    now = time.time()
    if cid not in CHAT_ACTIVITY: CHAT_ACTIVITY[cid] = {'last': now, 'pops': gw_shared.MAX_POPS_BURST} # Assume active
    else: CHAT_ACTIVITY[cid]['last'] = now

def ipc_listen_parent():
    global ACTIVE_CHATS
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: u.bind(('127.0.0.1', IPC_PORT))
    except: return print(f"{Colors.F}[!] Error binding IPC {IPC_PORT}{Colors.E}")
    
    while True:
        try:
            d, _ = u.recvfrom(4096); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "CHILD_EXIT":
                cid = p[1]
                if cid in ACTIVE_CHATS:
                    # v37.26 Fix: Notify peers correctly before local deletion
                    # Using leave_sess ensures DISCONNECT_NOW/LEAVE_GRP is sent.
                    leave_sess(target_cid=cid, silent=False) 
                    refresh_ui()
            
            elif cmd == "CLI_CMD":
                # CLI_CMD | ReturnIP | ReturnPort | CommandStr
                if len(p) >= 4:
                    rip, rport, cstr = p[1], p[2], p[3]
                    # Create a virtual CID for CLI
                    cli_sig = f"CLI:{rip}:{rport}"
                    try:
                        # Ejecutar comando como si fuera el lobby, pero redirigiendo output
                        exec_lobby_cmd(cstr, origin_cid=cli_sig)
                        # Opcional: Enviar ACK de fin?
                    except Exception as e:
                        try:
                            s_err = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                            s_err.sendto(f"{Colors.F}Error procesando comando: {e}{Colors.E}".encode(), (rip, int(rport)))
                        except: pass

            elif cmd == "CMD_SYNC_PEERS":
                # Child requests sync. Send all known peers.
                if len(p) >= 2:
                    req_cid = p[1]
                    if req_cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[req_cid]:
                         cport = ACTIVE_CHATS[req_cid]['port']
                         # Send all known peers
                         for ip, pg in PEERS.items():
                              nick = pg.get('nick', '?')
                              payload = f"CMD_ADD_PEER{SEP}{ip}{SEP}{nick}"
                              send_ipc(payload, cport)

            elif cmd == "FWD_CMD":
                if len(p) >= 3:
                     cstr = p[2]
                     # print(f"\n{Colors.M}[IPC] Ejecutando comando remoto: {cstr}{Colors.E}")
                     exec_lobby_cmd(cstr, origin_cid=p[1])
            
            elif cmd == "CMD_ACTIVITY":
                # Child reporting activity (User Typed)
                if len(p) >= 2:
                    register_outgoing_activity(p[1])

        except Exception as e:
            debug_log(f"[IPC_ERROR] Error en listener IPC del Lobby: {e}")

def ipc_listen_child(my_port, lock_state):
    # lock_state es un dict compartido con el thread principal del hijo para leer/escribir estado de POPs
    global MY_CHILD_ID
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try: u.bind(('127.0.0.1', int(my_port)))
    except Exception as e: 
        print(f"Error bind child IPC: {e}")
        return
    
    while True:
        try:
            d, _ = u.recvfrom(8192); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "FWD_MSG":
                if len(p) >= 4:
                    cid, tag, text = p[1], p[2], p[3]
                    if cid == MY_CHILD_ID:
                        safe_print(f"{tag}: {text}") 
                        
                        # LOGICA SMART POPUP
                        now = time.time()
                        last_in = lock_state.get('last_input', 0)
                        last_rx = lock_state.get('last_rx', 0)
                        manual_off = lock_state.get('pop_off', False)
                        ctype = lock_state.get('type', 'PRIV')
                        
                        # Actualizamos last_rx AHORA (actividad reciente en el chat)
                        lock_state['last_rx'] = now
                        
                        should_pop = False

                        # 1. Chequeo Manual Override (Prioridad Alta)
                        if manual_off:
                            # Si activado 'mute', solo suena si pasaron 5 mins (300s) de TOTAL SILENCIO previo
                            # Ojo: last_rx se acaba de actualizar, asi que comparamos con el last_rx *antes* de este msg?
                            # El usuario dijo: "pasan 5 minutos sin actividad... se vuelven a activar".
                            # Significa que si entre el mensaje ANTERIOR y ESTE pasaron > 300s, reactivamos.
                            if (now - last_rx) > TIMERS['MANUAL']:
                                lock_state['pop_off'] = False # Reactivar
                                safe_print(f"{Colors.W}[i] Popups reactivados por inactividad prolongada.{Colors.E}")
                                should_pop = True
                        else:
                            # 2. Chequeo Smart (Solo si no escrib铆 yo recientemente)
                            limit = TIMERS['PRIV'] if ctype == 'PRIV' else TIMERS['GROUP']
                            if (now - last_in) > limit:
                                should_pop = True
                        
                        if should_pop:
                             # Limpiar colores (ANSI escape codes) PRIMERO
                             # Si quitamos corchetes antes, rompemos la secuencia \033[...m
                             ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                             
                             tag_clean = ansi_escape.sub('', tag)
                             text_clean = ansi_escape.sub('', text)
                             
                             # Ahora sacar los corchetes decorativos del tag
                             sender_clean = tag_clean.replace('[','').replace(']','')
                             
                             title = ""
                             if ctype == 'GROUP':
                                 # Necesitamos el ID del grupo
                                 rid = lock_state.get('remote_id', '?')
                                 title = f"Mensaje grupal ({rid}) de {sender_clean}"
                             else:
                                 title = f"Mensaje privado de {sender_clean}"

                             popup(title, text_clean)

            elif cmd == "FWD_FILE":
                if len(p) >= 4 and p[1] == MY_CHILD_ID:
                    safe_print(f"{Colors.W}[] Archivo '{p[3]}' de {p[2]} recibido en Lobby.{Colors.E}")
            
            elif cmd == "FWD_PEER":
                if len(p) >= 4:
                    rmt_ip, rmt_nick, rmt_stat = p[1], p[2], p[3]
                    if rmt_ip not in PEERS: PEERS[rmt_ip] = {'nick': rmt_nick, 'chats': {MY_CHILD_ID}}
                    else: 
                         if isinstance(PEERS[rmt_ip], dict):
                             PEERS[rmt_ip]['nick'] = rmt_nick
                             PEERS[rmt_ip]['chats'].add(MY_CHILD_ID)
                    safe_print(f"{Colors.G}[+] Detectado: {rmt_nick}{Colors.E}")
            
            elif cmd == "CMD_CLOSE_NOW":
                # Fuerza cierre (ej: peer desconectado en privado)
                # Usamos global REMOTE_NICK seteada en run_child
                safe_print(f"\n{Colors.F}[] {REMOTE_NICK} ha abandonado el chat.{Colors.E}")
                # print(f"\n{Colors.F}[!] Cierre remoto: {p[1] if len(p)>1 else ''}{Colors.E}")
                time.sleep(3)
                # No mandamos exit signal propia para evitar bucle, solo salimos
                os._exit(0)

        except: pass

def shutdown_lobby():
    # Animated Exit
    with Loader(f"{Colors.W}[*] Cerrando todas las sesiones y saliendo{Colors.E}"):
        
        # 1. Notificar a peers remotos (Global Disconnect)
        active_targets = []
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and pdata.get('chats'):
                 active_targets.append(ip)

        for ip in active_targets:
            # send_cmd legacy compatible or V2?
            # V2 DISCONNECT_ALL: [CMD]DISCONNECT_ALL|1|[MPP][CMD]
            # send_cmd wrapper handles MPP?
            # send_cmd(ip, cmd, *args) -> build_cmd
            # If we reuse old DISCONNECT_NOW for compatibility
            send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
            
        # 2. Cerrar hijos locales
        for cid, cdata in list(ACTIVE_CHATS.items()):
            if 'port' in cdata:
                # Mandar se帽al de cierre suicida al hijo
                send_ipc("CMD_CLOSE_NOW", cdata['port'])
        
        time.sleep(1.0) # Dar tiempo a que salgan los mensajes

    restore_terminal()
    print(f"\n{Colors.G}[] Todo cerrado. Hasta luego.{Colors.E}")
    sys.exit(0)

def restore_terminal():
    """Restaura el eco de la terminal en Linux si se perdi贸"""
    if platform.system() != "Windows":
        os.system("stty echo")

# Asegurar restauraci贸n al salir brusco
atexit.register(restore_terminal)


def liberate_ports():
    """Detecta y elimina procesos zombies ocupando nuestros puertos"""
    ports = [TCP_PORT, UDP_PORT]
    try:
        if platform.system() == "Linux":
            for p in ports:
                subprocess.run(f"fuser -k {p}/tcp", shell=True, stderr=subprocess.DEVNULL)
                subprocess.run(f"fuser -k {p}/udp", shell=True, stderr=subprocess.DEVNULL)
        elif platform.system() == "Windows":
             for p in ports:
                 try:
                     r = subprocess.check_output(f"netstat -ano | findstr :{p}", shell=True, stderr=subprocess.DEVNULL).decode(errors='ignore')
                     lines = r.strip().split('\n')
                     for line in lines:
                         parts = line.split()
                         if len(parts) > 4:
                             pid = parts[-1]
                             if pid != "0": # No matar System
                                 subprocess.run(f"taskkill /F /PID {pid}", shell=True, stderr=subprocess.DEVNULL)
                 except: pass
    except: pass

def enable_win_visuals():
    """Fuerza UTF-8 y ANSI Colors en consola de Windows"""
    if platform.system() == "Windows":
        try:
            # 1. UTF-8
            os.system("chcp 65001 > nul") 
            # 2. ANSI VT100
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except: pass

# --- CONFIGURACIN & MAIN ---

def get_complete_ctx():
    """Context provider for Autocomplete"""
    return {
        'known_users': KNOWN_USERS,
        'peers': PEERS,
        'scan_buffer': SCAN_BUFFER # v41.0 Buffer de escaneo
    }

def init_completer():
    """Inicializa autocompletado inteligente v2 (gw_complete)"""
    if platform.system() != "Windows":
        if gw_complete.setup(get_complete_ctx):
             safe_print(f"{Colors.G}[] Autocompletado Inteligente activado (TAB).{Colors.E}")
        else:
             safe_print(f"{Colors.W}[!] Autocompletado no disponible.{Colors.E}")

def get_my_mpp():
    """Genera mi [MPP] actualizado"""
    # IP, Nick, Status, Version
    return gw_comm.build_mpp(MY_IP, MY_NICK, MY_STATUS, APP_VERSION)


def handle_afk_timeout():
    """Called by Zenity when timeout expires"""
    global MY_STATUS, PENDING_INVITE
    safe_print(f"{Colors.W}[AFK] Invitaci贸n expirada. Pasando a modo Ausente.{Colors.E}")
    
    # 1. Update Status
    if "-AFK" not in MY_STATUS:
        reason = "Ausente"
        # Avoid circular import or global mess, use adapter if possible or direct
        LOBBY_ADAPTER.set_config('status', f"{reason}-AFK")
        LOBBY_ADAPTER.broadcast_status(f"{reason}-AFK")
        safe_print(f"{Colors.F}[AFK] Estado cambiado a 'Ausente-AFK'.{Colors.E}")
    
    # 2. Reject and Clean Invite
    if PENDING_INVITE:
         # Inform Sender
         gw_comm.send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Ausente (AFK)")
         PENDING_INVITE = None


def restore_from_afk():
    """Checks if we are AFK and restores original status on activity"""
    global MY_STATUS
    if "-AFK" in MY_STATUS:
        original = MY_STATUS.replace("-AFK", "").replace("Ausente", "En l铆nea") 
        # Si era "Ausente-AFK", restauramos a "En l铆nea" por defecto, o limpiamos el suffix
        
        LOBBY_ADAPTER.set_config('status', original)
        LOBBY_ADAPTER.broadcast_status(original)
        safe_print(f"{Colors.G}[AFK] Actividad detectada. Estado restaurado a '{original}'.{Colors.E}")


def handle_v2_logic(pkt_type, cmd_name, args, source_ip):
    """Central V2 Logic: Process Parsed Packet"""
    import gw_pop
    if source_ip == MY_IP: return # Prevent Self-Loop
    
    try:
        # Extract MPP if present (Most commands have it as Arg 0)
        sender_mpp = None
        if len(args) > 0:
            sender_mpp = gw_comm.extract_mpp(args[0])
            
        # Update Knowledge Base (Auto-Discovery)
        if sender_mpp:
            # MPP always contains Nick/Status. Update Knowledge.
            if source_ip not in PEERS: PEERS[source_ip] = {'chats': set()}
            PEERS[source_ip]['nick'] = sender_mpp['nick']
            PEERS[source_ip]['ver']  = sender_mpp['ver']
            PEERS[source_ip]['status'] = sender_mpp['status'] # Fix [?] in scan
            PEER_STATUSES[source_ip] = sender_mpp['status']
            
            # Persistencia Autom谩tica + Refresh solo si es nuevo (evitar parpadeo)
            is_new = source_ip not in KNOWN_USERS
            update_memory(source_ip, sender_mpp['nick'], sender_mpp['status'])
            if is_new: refresh_ui()
            
        if pkt_type == 'CMD':
            debug_log(f"[V2] CMD: {cmd_name} Args: {len(args)}")
            
            if cmd_name == "SEARCH_GROUP":
                # Args: [MPP], GID, PASS
                if len(args) < 3: return
                gid, gpass = args[1], args[2]
                
                # Check if I have this group
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid and cdata['pass'] == gpass:
                        # Found! Send I_EXIST
                        # For now, Simple Response (No I_ANSWER delay)
                        # Build Local LS
                        # TODO: LS Builder from Peer list
                         
                        local_ls = [] # Placeholder
                        ls_pkt = gw_comm.build_ls(local_ls) # Placeholder
                        
                        gw_comm.send_cmd(source_ip, "I_EXIST", get_my_mpp(), gid, gpass, ls_pkt)
                        debug_log(f"[V2] Respondido I_EXIST a {source_ip} por grupo {gid}")
                        break

            elif cmd_name == "INVITE":
                # Args: [MPP], TYPE (PRIV/GROUP), [GID, PASS]
                if len(args) < 2: return
                itype = args[1]
                
                global PENDING_INVITE
                PENDING_INVITE = {
                    'ip': source_ip, 'nick': sender_mpp['nick'], 
                    'type': 'GROUP' if itype == 'GROUP' else 'PRIV',
                    'data': args[2:] if len(args)>2 else None,
                    'ts': time.time()
                }
                
                if itype == "PRIV":
                    msg_text = f" 隆Hey! {sender_mpp['nick']} ({source_ip}) quiere iniciar una conversaci贸n contigo.\n\n驴Te gustar铆a aceptar la conexi贸n?"
                    log_text = f"{sender_mpp['nick']} te invita a un Chat Privado"
                else:
                    gid = args[2] if len(args)>2 else '?'
                    msg_text = f" {sender_mpp['nick']} quiere que formes parte del grupo \"{gid}\".\n\n驴Te unes a la conversaci贸n?"
                    log_text = f"{sender_mpp['nick']} te invita a un Chat Grupal '{gid}'"

                safe_print(f"{Colors.G}[!] {log_text}. Responde en el popup o usa --aceptar.{Colors.E}")
                
                # Interactive Popup via gw_pop
                gw_pop.POP.show_question("Invitaci贸n Entrante", msg_text,
                                       lambda: LOBBY_ADAPTER.handle_accept(None) if LOBBY_ADAPTER else None,
                                       lambda: LOBBY_ADAPTER.handle_deny(None) if LOBBY_ADAPTER else None,
                                       on_timeout=handle_afk_timeout,
                                       timeout=gw_shared.AFK_TIMEOUT)
                
                sys.stdout.write('\a') # Beep

            elif cmd_name == "SEARCH_GROUP":
                # Args: [MPP], GID, PASS
                if len(args) < 2: return
                gid = args[1]; gp = args[2] if len(args)>2 else ""
                
                # Check for match in active groups
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid and cdata.get('pass','') == gp:
                        # Found match!
                        
                        # 1. Reply I_EXIST (Discovery)
                        gw_comm.send_cmd(source_ip, "I_EXIST", gid, gp, "LS_DATA?")
                        
                        # 2. Add Peer Logic (Mesh)
                        if 'port' in cdata:
                             payload = f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}"
                             send_ipc(payload, cdata['port'])
                             
                             # 3. Notify User Joined (Chat Event)
                             msg = f"[+] {sender_mpp['nick']} ({source_ip}) se uni贸 al grupo."
                             send_ipc(f"MSG_IN{gw_comm.SEP}Sistema{gw_comm.SEP}{msg}{gw_comm.SEP}{Colors.G}", cdata['port'])

                        # Only reply for one matching chat
                        break

            elif cmd_name == "INVITE_REJ":
                 # Args: [MPP], Reason
                 reason = args[1] if len(args) > 1 else "Rechazado"
                 safe_print(f"{Colors.R}[X] Invitaci贸n rechazada por {sender_mpp['nick']}: {reason}{Colors.E}")
                 # Notificar visualmente
                 gw_pop.POP.show(f"Invitaci贸n Rechazada", f"{sender_mpp['nick']} rechaz贸:\n{reason}", 5)
            
            elif cmd_name == "GRP_MSG":
                # Args: [MPP], GID, TEXT
                if len(args) < 3: return
                gid, text = args[1], args[2]
                
                # Route to compatible chats
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                         # 1. Auto-Add Sender to Peers (Mesh Fix)
                         if 'port' in cdata:
                             payload = f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}"
                             send_ipc(payload, cdata['port'])

                         # 2. Forward Message
                         tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                         ipc_payload = f"MSG_IN{gw_comm.SEP}{cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{text}"
                         if 'port' in cdata:
                             send_ipc(ipc_payload, cdata['port'])
                         
            elif cmd_name == "INVITE_ACC":
                # Args: [MPP]
                # Invitee accepted. Start chat without sending ACK back.
                safe_print(f"{Colors.G}[!] {sender_mpp['nick']} acept贸 tu invitaci贸n.{Colors.E}")
                start_private_chat(source_ip, sender_mpp['nick'], sender_mpp['status'], send_ack=False)

            elif cmd_name == "WHOIS":
                 # V2 Scan Request
                 if VISIBLE_IN_SCAN:
                     gw_comm.send_cmd(source_ip, "IAM_HERE", get_my_mpp())

            elif cmd_name == "IAM_HERE":
                 # Forward discovery result to all active children (for --quienes)
                 for cid, cdata in ACTIVE_CHATS.items():
                     if 'port' in cdata:
                          p = f"FWD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}{gw_comm.SEP}{sender_mpp['status']}"
                          send_ipc(p, cdata['port'])

            elif cmd_name == "LEAVE_GROUP":
                 # Args: [MPP], GID, PASS
                 if len(args) < 2: return
                 gid = args[1]
                 # Safe Nick
                 snick = sender_mpp['nick'] if sender_mpp else f"? ({source_ip})"
                 # Notify relevant group chats
                 for cid, cdata in ACTIVE_CHATS.items():
                     if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                          if 'port' in cdata:
                               # Logic Removal (Printing delegated to Child to avoid duplicates)
                               send_ipc(f"CMD_DEL_PEER{gw_comm.SEP}{source_ip}", cdata['port'])

            elif cmd_name == "CLOSE_PRIV" or cmd_name == "DISCONNECT_NOW":
                # Args: [MPP], NICK, [TIMESTAMP]
                snick = sender_mpp['nick'] if sender_mpp else f"? ({source_ip})"
                
                # Check Timestamp to avoid killing new sessions with old packets
                pkt_ts = float(args[1]) if len(args) > 1 and args[1].replace('.','',1).isdigit() else time.time()
                
                # Find Priv chat
                to_remove = []
                for cid, cdata in ACTIVE_CHATS.items():
                     if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                         # Validating Timing
                         created_at = cdata.get('created_at', 0)
                         if pkt_ts < created_at:
                             debug_log(f"[RACE FIX] Ignorando {cmd_name} viejo de {snick}. PktTs: {pkt_ts} < Created: {created_at}")
                             continue
                             
                         safe_print(f"{Colors.F}[!] {snick} cerr贸 el chat privado.{Colors.E}")
                         if 'port' in cdata:
                              send_ipc("CMD_CLOSE_NOW", cdata['port'])
                         to_remove.append(cid)
                
                for cid in to_remove:
                    del ACTIVE_CHATS[cid]
                if to_remove: refresh_ui()

            elif cmd_name == "IAM_HERE":
                 # Scan Response. MPP Parser already updated PEERS.
                 # Just notify User.
                 msg = f"{Colors.G}[+] Detectado: {sender_mpp['nick']} ({source_ip}){Colors.E}"
                 
                 # Broadcast to all children
                 for c_id, c_data in ACTIVE_CHATS.items():
                     if 'port' in c_data:
                          send_ipc(f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}", c_data['port'])

                 if SCANNING_NOW:
                      SCAN_BUFFER.append(msg)
                 else:
                      safe_print(msg)


        elif pkt_type == 'MSJ':
            # Args: MPP, TYPE, [PKG_ID, GID/DEST...], LEN, BODY
            # Last arg is BODY.
            msg_body = args[-1]
            msg_type = cmd_name # parse_packet returns Subtype as name for MSJ
            
            debug_log(f"[V2] MSJ {msg_type} de {sender_mpp['nick']}: {msg_body}")
            
            # Routing Logic
            target_cid = None
            
            if msg_type == 'PRIV':
                # Route by IP map
                # Find chat with remote_id == source_ip
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                         target_cid = cid; break
                         
            elif msg_type == 'GRUP':
                # Route by GID (Arg 3 usually: MPP|GRUP|PKID|GID)
                if len(args) >= 4:
                    gid = args[3]
                    for cid, cdata in ACTIVE_CHATS.items():
                         if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                              target_cid = cid; break
            
            if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                # Forward to Child
                # Format: FWD_MSG<SEP>CID<SEP>TAG<SEP>BODY
                tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                
                # V2 IPC uses same FWD_MSG or new?
                # Let's reuse FWD_MSG for compatibility with gw_child v39
                full_ipc = f"FWD_MSG{gw_comm.SEP}{target_cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{msg_body}"
                send_ipc(full_ipc, ACTIVE_CHATS[target_cid]['port'])
                
                # SMART POP LOGIC (User Request: Anti-Spam)
                if check_pop_allowance(target_cid):
                     try:
                         # Show Pop-up
                         import gw_pop
                         # Determine context for title
                         ctx = "Grupo" if msg_type == 'GRUP' else "Privado"
                         title = f"{ctx}: {sender_mpp['nick']}"
                         gw_pop.show(title, msg_body, duration=4)
                     except: pass
            else:
                 debug_log(f"[V2] Drop MSJ: No Chat Found for {source_ip}")

    except Exception as e:
        safe_print(f"Err V2 Logic: {e}")


def get_rx_folder():
    base = os.path.join(os.path.expanduser("~"), "Desktop")
    if not os.path.exists(base): base = os.path.join(os.path.expanduser("~"), "Escritorio")
    if not os.path.exists(base): base = os.path.expanduser("~") 
    
    rx = os.path.join(base, "GhostWhisper_Recibidos")
    if not os.path.exists(rx): os.makedirs(rx, exist_ok=True)
    return rx

def handle_incoming_file(conn, args, source_ip):
    # Args: Filename, Size, Hash, Type, ...
    if len(args) < 2: return
    fname, fsize = args[0], int(args[1])
    ftype = args[3] if len(args)>3 else 'FILE'
    
    # Notify Start logic?
    safe_print(f"{Colors.C}[猬] Recibiendo archivo '{fname}' ({fsize} bytes) de {source_ip}...{Colors.E}")
    
    dest_path = os.path.join(get_rx_folder(), fname)
    
    # Receive Loop
    recvd = 0
    try:
        with open(dest_path, "wb") as f:
            while recvd < fsize:
                chunk_size = min(4096, fsize - recvd)
                data = conn.recv(chunk_size)
                if not data: break
                f.write(data)
                recvd += len(data)
                
        safe_print(f"{Colors.G}[] Archivo guardado en: {dest_path}{Colors.E}")
        
        # Notify Children (via broadcast FWD_FILE?)
        # Search relevant child to notify?
        # File transfer is TCP P2P (Priv usually).
        # We can notify all or search for private chat with source_ip.
        
        notify_cid = None
        sender_nick = "?"
        # Try to resolve nick
        if source_ip in PEERS: sender_nick = PEERS[source_ip].get('nick','?')

        # send IPC to all children or specific? 
        # FWD_FILE format: FWD_FILE | CID(Target) | SenderNick | Filename
        # Child IPC expects: cmd == "FWD_FILE": if len(p) >= 4 and p[1] == MY_CHILD_ID: ...
        
        for cid, cdata in ACTIVE_CHATS.items():
            if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                 if 'port' in cdata:
                     # Correct CID found
                     send_ipc(f"FWD_FILE{gw_comm.SEP}{cid}{gw_comm.SEP}{sender_nick}{gw_comm.SEP}{fname}", cdata['port'])
                 break
        
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error recibiendo archivo: {e}{Colors.E}")

def handle_v2_priv(conn, ip, raw):
    """TCP 44494: Privado, Control y Archivos"""
    if LOG_ON: debug_log(f"[RX TCP PRIV] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    
    if parsed[0] == 'CMD' and parsed[1] == 'FILE_TRANSFER':
        # Handover to File Handler
        # Takes ownership of Stream
        handle_incoming_file(conn, parsed[2], ip)
        return False # Listener closes socket after we return?
        # Our handler consumed the stream. Listener can close safely.
        
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

def handle_v2_disc(data, ip):
    """UDP 44495: Discovery"""
    if LOG_ON:
         try: dstr = data.decode('utf-8', errors='ignore').strip()
         except: dstr = f"<Bytes {len(data)}>"
         debug_log(f"[RX UDP DISC] {ip}: {dstr}")

    parsed = gw_comm.parse_packet(data)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)

def handle_v2_grp(conn, ip, raw):
    """TCP 44496: Group Mesh"""
    if LOG_ON: debug_log(f"[RX TCP GRP] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

# --- GLOBALS ---
LOBBY_ADAPTER = None



def run_lobby():
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE, LOBBY_ADAPTER
    # atexit.register(lambda: print(f"{Colors.W}Lobby cerrado.{Colors.E}")) # Reemplazado por shutdown manual
    
    # Self-Healing Checks
    enable_win_visuals()
    liberate_ports()
    
    # Capturar Ctrl+C en Lobby para shutdown limpio
    import signal
    signal.signal(signal.SIGINT, lambda s, f: shutdown_lobby())
    
    lazy_import() # Load heavy libraries only when needed (Lobby or Child)
    global hashlib
    import hashlib # v36.0 Integrity check
    
    # Init Display Manager
    gw_display.DISPLAY = gw_display.DisplayManager(get_lobby_status)

    adapter = LobbyAdapter()
    LOBBY_ADAPTER = adapter # Expose globally for callbacks
    os.system('cls' if os.name == 'nt' else 'clear'); fw_cfg(); MY_IP = get_ip()
    set_terminal_title(f"GWC Lobby - {MY_NICK}")
    
    # Kali/Network Check
    if MY_IP.startswith("127.") and platform.system() == "Linux":
         print(f"{Colors.W}[!] ADVERTENCIA: IP local ({MY_IP}) detectada.{Colors.E}")
         print(f"{Colors.W}[!] Si usas Kali Linux, verifica que no est茅s en 'Modo Monitor' (airmon-ng stop wlan0).{Colors.E}")
         print(f"{Colors.W}[!] La visibilidad en red estar谩 limitada.{Colors.E}")
         time.sleep(3)
    
    global PROMPT
    PROMPT = f"{Colors.B}Lobby > {Colors.E}"
    
    val_nick = MY_NICK if MY_NICK.strip() else socket.gethostname()
    
    if not load_config():
        while True:
            try: 
                if n := input("Tu Nickname: ").strip(): MY_NICK = n; break
            except: sys.exit()
        save_config()
    else:
        # Fallback if config loaded empty nick
        if not MY_NICK.strip(): MY_NICK = socket.gethostname()
    
    # SILENT_UPDATES_ALLOWED logic removed
    pass

    refresh_ui() # Clean start with Dashboard
    
    # Aseguramos limpieza al inicio tambi茅n por si acaso
    # Aseguramos limpieza al inicio tambi茅n por si acaso
    restore_terminal()
    
    # Setup Autocomplete (v41.0)
    init_completer()

    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    # v37.23 Modular Logic - Start Listeners via gw_comm
    # v40.0 Protocol V2 Listeners
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_PRIV, handle_v2_priv)
    gw_comm.start_udp_listener(gw_comm.UDP_PORT_DISC, handle_v2_disc)
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_GRP,  handle_v2_grp)
    
    threading.Thread(target=check_child_health, daemon=True).start() # Health check
    
    check_repo_update()

    while True:
        try:
            inp = input(f"{Colors.B}Lobby > {Colors.E}").strip()
            if inp and gw_display.DISPLAY:
                 gw_display.DISPLAY.add(f"{Colors.B}Lobby > {Colors.E}{inp}")
            
            restore_from_afk()
            exec_lobby_cmd(inp)
        except KeyboardInterrupt: sys.exit()
        except Exception as e: safe_print(f"Err Lobby: {e}")




def is_daemon_alive():
    """Returns True if Daemon is running (Bind fails), False if not (Bind success)"""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.bind(('127.0.0.1', IPC_PORT))
        return False # We could bind, so port was free -> Not running
    except: return True # Port busy -> Running

def launch_daemon_background():
    # Launch self with --daemon
    # Detach process
    # Use setsid to ensure it doesn't get killed when parent exits
    # We pass 'python3' explicitly or sys.executable
    script_abs = os.path.abspath(sys.argv[0])
    cwd_dir = os.path.dirname(script_abs)
    
    # Ensure log dir exists for launch errors
    log_path = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
    if not os.path.exists(log_path): os.makedirs(log_path)
    
    # Redirect stderr to launch_log to catch startup errors (e.g. imports)
    with open(os.path.join(log_path, "launch.err"), "a") as ferr:
        subprocess.Popen([sys.executable, script_abs, "--daemon"], 
                         stdout=subprocess.DEVNULL, stderr=ferr,
                         cwd=cwd_dir,
                         start_new_session=True)

def run_client(cmd_str):
    restore_from_afk() # Any CLI interaction implies activity
    if not cmd_str: cmd_str = "--estados-globales"
    
    # 1. Bind Reply Socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(5.0) # 5s timeout default
    
    # Find free port
    my_port = 0
    try:
        s.bind(('127.0.0.1', 0)) # Ephemeral
        my_port = s.getsockname()[1]
    except:
        print("Error sockets cliente"); return

    # 2. Send Command
    # CLI_CMD | ReturnIP | ReturnPort | CommandStr
    payload = f"CLI_CMD{SEP}127.0.0.1{SEP}{my_port}{SEP}{cmd_str}"
    send_ipc(payload, IPC_PORT)
    
    # 3. Listen for replies

    try:
        while True:
            d, _ = s.recvfrom(65535)
            print(d.decode())
            # For specific commands like --quienes that might have multiple lines, we wait.
            # But normally we just print one reply.
            pass
            
    except socket.timeout:
        pass # End of stream implicit
    except KeyboardInterrupt:
        pass
    finally:
        s.close()

def run_daemon():
    global MY_NICK, MY_STATUS, MY_IP, LOBBY_ADAPTER, PROMPT
    
    # Daemon Hygiene
    liberate_ports()
    
    # Logging
    log_path = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
    if not os.path.exists(log_path): os.makedirs(log_path)
    
    # Redirect Stdout/Stderr to log
    sys.stdout = open(os.path.join(log_path, "daemon.log"), "a", buffering=1)
    sys.stderr = open(os.path.join(log_path, "daemon.err"), "a", buffering=1)
    
    print(f"[{time.time()}] Daemon Started (PID: {os.getpid()})")
    
    # Basic Init (No Display)
    lazy_import() 
    global hashlib; import hashlib
    
    gw_display.DISPLAY = None # NO TUI
    
    adapter = LobbyAdapter()
    LOBBY_ADAPTER = adapter
    
    fw_cfg()
    MY_IP = get_ip()
    
    if not load_config():
        MY_NICK = socket.gethostname()
        save_config()
        
    init_completer() # Maybe not needed in daemon, but harmless
    
    # Listeners
    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_PRIV, handle_v2_priv)
    gw_comm.start_udp_listener(gw_comm.UDP_PORT_DISC, handle_v2_disc)
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_GRP,  handle_v2_grp)
    
    threading.Thread(target=check_child_health, daemon=True).start()
    
    # Ensure DISPLAY for Zenity (if available in env)
    if "DISPLAY" not in os.environ:
        os.environ["DISPLAY"] = ":0"

    # Infinite Loop
    while True:
        # Check Pending Invite Timeout
        # (OBSOLETE: Now handled by gw_pop callback 'on_timeout' -> handle_afk_timeout)
        # We removed the loop to avoid Race Conditions.
        
        time.sleep(1)

def main():
    # v37.18: Clear debug log on startup (only if Lobby/Daemon)
    try:
        if "--child" not in sys.argv and "--daemon" not in sys.argv:
             # CLI triggers debug clear? No, maybe only Daemon should clear it or Lobby.
             # Legacy behavior: Lobby cleared it.
             # Now Daemon clears it.
             pass
    except: pass

    # Parsing
    if "--daemon" in sys.argv:
        try:
            dsk = get_desktop_path()
            path = os.path.join(dsk, "gwc_lobby_debug.log")
            if os.path.exists(path):
                 with open(path, "w") as f: f.write(f"--- DAEMON START {time.ctime()} ---\n")
        except: pass
        run_daemon()

    elif "--child" in sys.argv:
        try:
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            
            port = sys.argv[sys.argv.index("--port")+1]
            
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            global SILENT_UPDATES_ALLOWED

            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        # CLI / AUTO-DAEMON MODE
        # Check Daemon Status
        is_running = is_daemon_alive()
        
        args = sys.argv[1:]
        
        if not args:
             # DAEMON NO CORRE: INICIARLO
             if not is_running:
                 print(f"{Colors.C}[*] Iniciando GhostWhisperChat Daemon...{Colors.E}")
                 launch_daemon_background()
                 # Esperar a que arranque
                 up = False
                 for _ in range(10):
                     time.sleep(0.5)
                     if is_daemon_alive():
                         up=True; break
                 
                 if up:
                     print(f"{Colors.G}[] Daemon iniciado en segundo plano.{Colors.E}")
                     # Start default interactive client or just show status
                     args = ["--estados-globales"] 
                 else:
                     print(f"{Colors.F}[X] Fallo al iniciar el Daemon.{Colors.E}")
                     sys.exit(1)
             else:
                 # Default command if running
                 print(f"{Colors.G}[*] Daemon activo. Cliente conectado.{Colors.E}")
                 args = ["--estados-globales"]

        elif not is_running:
             # Args provided but Daemon dead?
             print(f"{Colors.W}[!] Daemon no activo. Iniciando...{Colors.E}")
             launch_daemon_background()
             time.sleep(2)
        
        if "--update" in args or "--actualizar" in args or "update" in args or "actualizar" in args:
             # run update locally
             trigger_manual_update()
        else:
             # Run Client for other commands
             # Pre-process args to support dashless commands (Sugar)
             # E.g. gwc scan -> gwc --scan
             # Only applied in CLI mode, safe for Chat logic.
             new_args = []
             import gw_shared
             for a in args:
                 if not a.startswith("-"):
                     # Try finding canonical command
                     if f"--{a}" in gw_shared.CMD_MAP:
                         new_args.append(f"--{a}")
                     elif f"-{a}" in gw_shared.CMD_MAP:
                         new_args.append(f"-{a}")
                     else:
                         new_args.append(a) # Pass through (e.g. arguments like IP or Nick)
                 else:
                     new_args.append(a)
                     
             run_client(" ".join(new_args))

if __name__ == "__main__": main()
