#!/usr/bin/env python3
import os
import sys
import platform
import subprocess
import threading
import time
import socket
import json
import uuid
import re
import signal
import shutil
import unicodedata
import atexit
import ctypes
import urllib.request as request

# ... Imports ...
try:
    import gw_comm
    import gw_shared
    import gw_child
    import gw_pop
except ImportError:
    # Logic for manual path resolution
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. Check system install
    if os.path.exists("/usr/lib/ghostwhisperchat"):
        sys.path.append("/usr/lib/ghostwhisperchat")
    
    # 2. Check repo structure (../lib/ghostwhisperchat relative to bin)
    # script_dir is ".../usr/bin"
    # we want ".../usr/lib/ghostwhisperchat"
    repo_lib = os.path.join(os.path.dirname(script_dir), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
        sys.path.insert(0, repo_lib)

    # 3. Check CWD fallback (Dev root)
    if os.path.exists("ghostwhisperchat_pkg/usr/lib/ghostwhisperchat"):
        sys.path.insert(0, "ghostwhisperchat_pkg/usr/lib/ghostwhisperchat")
        
    try:
        import gw_comm
        import gw_shared
        import gw_child
        import gw_pop
    except ImportError as e:
        print(f"CRITICAL ERROR: Could not import gw_comm/gw_shared module. Paths tried: {sys.path}")
        print(f"Error detail: {e}")
        # Log to file for child process visibility (Desktop)
        dsk = os.path.join(os.path.expanduser("~"), "Desktop")
        if not os.path.exists(dsk): dsk = os.path.join(os.path.expanduser("~"), "Escritorio")
        
        try:
            with open(os.path.join(dsk, "gwc_import_crash.log"), "a") as f:
                f.write(f"[{time.time()}] CRITICAL: Modules import failed. Env: {os.environ.get('PATH')}\n")
                f.write(f"Error: {e}\n")
        except: pass
        sys.exit(1)

# Aliases for compatibility
from gw_shared import Colors, COMMAND_DEFS, resolve_cmd, IPC_PORT, get_ip, calculate_file_hash, APP_VERSION, APP_VER_NUM, APP_VER_TAG, Loader, get_desktop_path, CMD_MAP
SEP = gw_comm.SEP
UDP_PORT = gw_comm.UDP_PORT
TCP_PORT = gw_comm.TCP_PORT
build_packet = gw_comm.build_packet
parse_packet = gw_comm.parse_packet

# ... (Rest of globals) ...

# ... (Functions like spawn_child_process need to use gw_shared vars) ...

def main():
    # ...
    if "--child" in sys.argv:
        try:
            # ... Parse args ...
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            port = sys.argv[sys.argv.index("--port")+1]
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Delegate to Module
            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

# --- CONFIGURACIN ---


multicast_group = ('224.0.0.1', 44496) # Multicast opcional (futuro)
BUFFER, LOG_FILE, CONFIG_FILE = 4096, "cyberdei_history.log", "cyberdei_config.json"



def find_free_port(start_port=5001, max_tries=50):
    for p in range(start_port, start_port + max_tries):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', p))
                return p
        except: continue
    return start_port # Fallback

DL_ROOT = get_desktop_path()
DL_DIR = os.path.join(DL_ROOT, "GhostWhisper_Recibidos")
if not os.path.exists(DL_DIR):
    try: os.makedirs(DL_DIR)
    except: pass
TIMERS = {'PRIV': 60, 'GROUP': 120, 'MANUAL': 300, 'INVITE': 15, 'BAN': 60}

# --- ESTADO PROCESOS ---
IS_CHILD = False
MY_CHILD_ID = None
PARENT_PID = None
CHILD_PROCESSES = {} # {ChatID: {'pid': PID, 'port': Port}} for Parent logic

# --- PILAS DE DATOS ---
PEERS = {}              # CONECTADOS: {IP: {'nick': Nick, 'chats': [ChatID1, ...]}}
PEER_STATUSES = {}      # ESTADOS CONECTADOS: {IP: Status}
KNOWN_USERS = {}        # HISTORIAL: {IP: {'nick': Nick, 'status': Status, 't': time}}
ACTIVE_CHATS = {}       # {ChatID: {'type': 'PRIV'/'GROUP', 'remote_id': ..., 'pass': ..., 'created_at': time}}
CURRENT_CHAT_ID = None

# GROUP_ID, GROUP_PASS = None, None # MOVIDO A ACTIVE_CHATS
MY_IP, MY_NICK, MY_STATUS = "", "An贸nimo", "En l铆nea"
DISC_TEMP, SCAN_RESULTS, PENDING_INVITE = [], [], None
POPUP_ON, USER_OFF, LAST_ACT = True, False, 0
HAS_ZENITY = False

def ensure_dependencies():
    """Instala zenity si falta en Linux (Debian/Kali/Ubuntu)"""
    if platform.system() == "Linux" and shutil.which("zenity") is None:
        try:
            print("\033[93m[!] Zenity no detectado. Instalando dependencias visuales...\033[0m")
            # Intentar apt-get silencioso
            subprocess.run(["sudo", "apt-get", "update", "-qq"], check=False)
            subprocess.run(["sudo", "apt-get", "install", "zenity", "-y", "-qq"], check=False)
        except: pass

ensure_dependencies()
HAS_ZENITY = shutil.which("zenity") is not None
AUTO_DL, LOG_ON, PENDING_FILES = True, False, []
VISIBLE_IN_SCAN = True 
SCANNING_NOW = False
SCAN_BUFFER = []
IS_AFK = False 


PROMPT = f"\001{Colors.B}\002Lobby > \001{Colors.E}\002"
print_lock = threading.Lock()

# --- UTILS ---
def set_terminal_title(title):
    """Establece el t铆tulo de la ventana de la terminal usando secuencias ANSI."""
    if platform.system() == "Windows":
        os.system(f"title {title}")
    else:
        # Secuencia est谩ndar XTerm (funciona en gnome, konsole, xfce, etc)
        sys.stdout.write(f"\x1b]2;{title}\x07")
        sys.stdout.flush()

def normalize_str(s):
    # Quita acentos y pasa a minusculas (ej: S谩ez -> saez)
    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn').lower()

def raw_print(s):
    # Imprime SIN guardar en historial
    # Si es hilo secundario (Async), restauramos el prompt visualmente.
    # Si es Main Thread (Sync), solo imprimimos (el input loop pondr谩 el prompt).
    with print_lock:
        if threading.current_thread() is threading.main_thread():
             print(s)
        else:
             try:
                 sys.stdout.write(f'\r\033[K{s}\n' + PROMPT + (readline.get_line_buffer() if 'readline' in sys.modules else ""))
                 sys.stdout.flush()
             except:
                 print(s)

def safe_print(s):
    # Imprime Y guarda en historial (Eventos publicos)
    LOBBY_HISTORY.append(s)
    raw_print(s)

def reply_print(msg, target_cid=None):
    """
    Imprime en el destino correcto:
    - Si target_cid es None -> Imprime en Lobby (safe_print).
    - Si target_cid existe -> Env铆a IPC al hijo para que lo muestre.
    """
    if target_cid and target_cid in ACTIVE_CHATS:
        # Enviar al hijo
        cdata = ACTIVE_CHATS[target_cid]
        port = cdata.get('port')
        if port:
            # Usamos MSG_IN con 'Sistema' como remitente
            # Limpiamos colores para IPC? No, el hijo soporta colores.
            send_ipc(f"MSG_IN{SEP}Sistema{SEP}{msg}{SEP}{Colors.C}", port)
        else:
            safe_print(msg) # Fallback
    else:
        safe_print(msg)

def send_ipc(msg, port=IPC_PORT):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(msg.encode(), ('127.0.0.1', int(port)))
    except: pass





def write_log(txt, type="MSG"):
    if LOG_ON:
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                f.write(f"[{datetime.datetime.now().strftime('%F %T')}] [{type}] {txt}\n")
        except: pass

KNOWN_USERS = {} # {ip: {nick, status, t}}
LOBBY_HISTORY = [] # Buffer para repintar la UI
DISC_TEMP = [] # Buffer para descubrimiento (Scan)
DEBUG_MODE = False # v36.8

# --- UTILS VISUALES ---
def safe_print(msg):
    """Thread-safe print"""
    try:
        sys.stdout.write(msg + '\n')
    except: pass

def debug_log(msg):
    if DEBUG_MODE:
        s = f"{Colors.M}[DEBUG] {msg}{Colors.E}"
        safe_print(s)
        # v37.13: Persist debug to file
        try:
             dsk = get_desktop_path()
             path = os.path.join(dsk, "gwc_lobby_debug.log")
             with open(path, "a", encoding="utf-8") as f:
                 f.write(f"[{time.time()}] {msg}\n")
        except Exception as e:
             safe_print(f"{Colors.F}[!] Error escribiendo log en disco: {e}{Colors.E}")

# --- PROTOCOLO (Delegado a gw_comm) ---
# --- PROTOCOLO (Delegado a gw_comm) ---
# Funciones redirigidas totalmente al m贸dulo
def send_cmd(ip, cmd, *args):
    if LOG_ON:
         debug_log(f"[TX] CMD={cmd} DST={ip if ip else 'BCAST'} ARGS={args}")
    gw_comm.send_cmd(ip, cmd, *args)

def send_cmd_all(cmd, *args):
    gw_comm.send_cmd_all(cmd, *args)

def send_raw(ip, d):
    gw_comm.send_tcp_packet(ip, d)

# Popup Logic Delegated to gw_pop
def get_col(n): return Colors.PALETTE[sum(ord(c) for c in n) % len(Colors.PALETTE)] if n else Colors.WH

# --- CONFIG & STATE ---
    


# --- CONFIG & STATE ---
CONFIG_FILE = "inter_chat.json"
KNOWN_USERS = {} # {ip: {nick, status, t}}
TRUSTED_PEERS = set() # IPs de gente con chat privado exitoso {ip}
TRUSTED_NETS = {} # {network_id: {'trusted': bool, 'last_seen': ts, 'name': str}}
MY_NICK = socket.gethostname()
# ... rest of vars ...
ACTIVE_CHATS = {} # cid -> {type, remote_id, pass, process_handle, port}
PEERS = {} # ip -> {nick, chats: {cid1, cid2}}
PEER_STATUSES = {} # ip -> status_str
SILENT_UPDATES_ALLOWED = False # Global state



def load_config():
    global KNOWN_USERS, MY_NICK, MY_STATUS, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, TRUSTED_NETS, TRUSTED_PEERS
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                d = json.load(f)
                KNOWN_USERS = d.get('known_users', {})
                MY_NICK = d.get('nick', MY_NICK)
                MY_STATUS = d.get('status', "En l铆nea")
                VISIBLE_IN_SCAN = d.get('visible', True)
                LOG_ON = d.get('log_on', True)
                gw_pop.POP.set_active(d.get('pop_on', True))
                AUTO_DL = d.get('auto_dl', True)
                TRUSTED_NETS = d.get('trusted_nets', {})
                TRUSTED_PEERS = set(d.get('trusted_peers', []))
                return True
        except: pass
    return False

def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump({
                'known_users': KNOWN_USERS,
                'nick': MY_NICK,
                'status': MY_STATUS,
                'visible': VISIBLE_IN_SCAN,
                'log_on': LOG_ON,
                'pop_on': gw_pop.POP.pop_on,
                'auto_dl': AUTO_DL,
                'trusted_nets': TRUSTED_NETS,
                'trusted_peers': list(TRUSTED_PEERS)
            }, f, indent=4)
    except: pass

# --- NETWORK IDENTIFICATION ---
def get_network_id():
    """Identifica la red actual (Gateway + SSID/Name)"""
    gw = "UNK_GW"
    ssid = "LAN"
    
    try:
        if platform.system() == "Linux":
            # Gateway
            r = subprocess.check_output("ip route | grep default", shell=True).decode()
            gw = r.split()[2] if len(r.split()) > 2 else "UNK"
            # SSID/Interface
            try:
                w = subprocess.check_output("iwgetid -r", shell=True).decode().strip()
                if w: ssid = w
            except: pass
            
        elif platform.system() == "Windows":
             # 1. Gateway via Powershell (NextHop)
             try:
                 cmd_gw = "Get-NetRoute -DestinationPrefix 0.0.0.0/0 | Select-Object -ExpandProperty NextHop"
                 r = subprocess.check_output(["powershell", "-Command", cmd_gw], creationflags=0x08000000).decode().strip()
                 if r: gw = r
             except: 
                 # Fallback ipconfig parse
                 try:
                     r = subprocess.check_output("ipconfig", creationflags=0x08000000).decode()
                     # Buscar "Default Gateway . . . : 192..."
                     m = re.search(r"Default Gateway.*: ([\d\.]+)", r)
                     if m: gw = m.group(1)
                 except: pass

             # 2. SSID via netsh
             try:
                 r = subprocess.check_output("netsh wlan show interfaces", creationflags=0x08000000).decode()
                 m = re.search(r"^\s+SSID\s+:\s+(.+)$", r, re.MULTILINE)
                 if m: ssid = m.group(1).strip()
             except: pass
    except: pass
    
    return f"{gw}_{ssid}"

def check_network_trust():
    """Verifica si la red actual es confiable para updates"""
    net_id = get_network_id()
    now = time.time()
    
    data = TRUSTED_NETS.get(net_id)
    ask = False
    
    if not data:
        # Nueva red
        ask = True
        msg = f"Se ha detectado una nueva red:\n{net_id}\n\n驴Desea activar actualizaciones silenciosas en esta red?"
    else:
        # Red conocida, verificar timestamp (3 weeks = 1814400s)
        if (now - data['last_seen']) > 1814400:
            ask = True
            msg = f"No te conectas a esta red ({net_id}) en m谩s de 3 semanas.\n\n驴Mantener actualizaciones silenciosas?"
        else:
            # Update timestamp and proceed
            TRUSTED_NETS[net_id]['last_seen'] = now
            save_config()
            return data['trusted']

    if ask:
        # Popup de pregunta IMPORTANTE
        is_windows = platform.system() == "Windows"
        res = False
        
        # Reutilizamos logica de popup pero bloqueante y con Yes/No pregunta
        # Hack simple usando zenity/powershell directo aqui para bloquear
        try:
            if platform.system() == "Linux" and shutil.which("zenity"):
                ret = os.system(f"zenity --question --title='IMPORTANTE: Seguridad' --text='{msg}'")
                res = (ret == 0)
            elif is_windows:
               # Powershell simple
               script = f"$r=[System.Windows.Forms.MessageBox]::Show('{msg}','Seguridad','YesNo','Question');if($r-eq'Yes'){{exit 0}}else{{exit 1}}"
               ret = subprocess.call(["powershell", "-Command", f"Add-Type -A System.Windows.Forms; {script}"])
               res = (ret == 0)
        except: pass
        
        TRUSTED_NETS[net_id] = {'trusted': res, 'last_seen': now, 'name': net_id}
        save_config()
        return res
    
    return False # Should not reach

def show_help(target_cid=None):
    lines = []
    lines.append(f" {Colors.BO}--- AYUDA Y COMANDOS ---{Colors.E}")
    
    cats = {
        "GESTIN DE CHATS": [
            ("--chatpersonal (Nick y/o IP)", "Crear un chat privado con un usuario."),
            ("--chatgrupal ID CLAVE", "Unirse/Crear sala."), 
            ("--invite (Nick1, Nick2...) y/o IPs", "Invitar gente al grupo actual."),
            ("--aceptar / --rechazar", "Responder a invitaciones pendientes."),
            ("--ls", "Listar usuarios CONECTADOS en el chat."), 
            ("--salir", "Desconectar de la sesi贸n.")
        ],
        "RED Y CONTACTOS": [
            ("--quienes", "Escanear red (驴Qui茅n est谩 online?)."),
            ("--contactos", "Ver historial de gente vista."),
            ("--quienes-si / --quienes-no", "Visibilidad en esc谩ner.")
        ],
        "UTILIDADES Y ARCHIVOS": [
            ("--archivo (Archivo.ext y/o Ruta)", "Enviar archivo."),
            ("--nombre (NuevoNick)", "Cambiar tu nombre visible."),
            ("--estado (Texto)", "Cambiar estado."),
            ("--descarga-si / --descarga-no", "Control descarga autom谩tica."),
            ("--estados-globales", "Ver resumen de configuraci贸n."),
            ("--abreviaciones", "Ver todos los formatos aceptados por cada comando."),
            ("--limpiar", "Limpiar pantalla.")
        ],
        "SISTEMA Y CONFIGURACIN": [
             ("--log on / off", "Guardar historial."), 
             ("--popno / --popsi", "Control Notificaciones."), 
             ("--autolevantado-si/no", "Iniciar app al encender PC (Linux).")
        ]
    }

    for cat_name, cmds in cats.items():
        lines.append(f"\n {Colors.C}:: {cat_name} ::{Colors.E}")
        for c, d in cmds: 
            lines.append(f"   {Colors.BO}{c:<35}{Colors.E} : {d}")

    lines.append("-" * 60)
    
    full_msg = "\n".join(lines)
    if target_cid: reply_print(full_msg, target_cid)
    else: safe_print(full_msg)

def get_peer_name(ip):
    p = PEERS.get(ip)
    if p and isinstance(p, dict):
        return p.get('nick', ip)
    return ip

    """Imprime y guarda en historial para repintado"""
    safe_print(txt)
    # LOBBY_HISTORY append is handled by safe_print now
    if len(LOBBY_HISTORY) > 200: LOBBY_HISTORY.pop(0) # v37.13 Increased limit

def refresh_ui(msg=None):
    os.system('cls' if os.name == 'nt' else 'clear')

    # Dashboard Format
    vis_txt = f"{Colors.G}SI{Colors.E}" if VISIBLE_IN_SCAN else f"{Colors.F}NO{Colors.E}"

    raw_print(f"{Colors.H}Version: {APP_VERSION}{Colors.E}")
    raw_print(f"Mi IP: {Colors.BO}{MY_IP}{Colors.E} | Nick: {Colors.BO}{MY_NICK}{Colors.E} | Visible en red: {vis_txt} | Estado: {Colors.C}{MY_STATUS}{Colors.E}")
    raw_print(f"Total de chats: {Colors.M}{len(ACTIVE_CHATS)}{Colors.E}")
    raw_print(f"Total de contactos: {Colors.M}{len(KNOWN_USERS)}{Colors.E}")
    raw_print(f"Puedes poner --help para ver los comandos")
    raw_print(f"{Colors.G}Bienvenido al lobby{Colors.E}")
    raw_print("-" * 60)

    # Repintar Historial sin duplicarlo
    for line in LOBBY_HISTORY:
        raw_print(line)

    if msg: 
        safe_print(msg) # Este es nuevo, s铆 guardar
    
    # Force Prompt restore only if Async (refresh inside refresh?)
    # Actually raw_print handles the logic per line, but for refresh we want clean output.
    # But for now let's trust it.
    
    # If we are async, raw_print appended prompt on the last line.
    # If we are sync, nobody printed prompt. Correct.

# --- RED ---
def lazy_import():
    global json, difflib, urllib, unicodedata, request, datetime, uuid
    import json, difflib, datetime, uuid, unicodedata
    import urllib.request as request
    
def get_ip():
    # Optimization: Use a dummy socket to get preferred outgoing IP without actual connection
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            # Google DNS IP (doesn't need to be reachable)
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except:
        return "127.0.0.1"

def fw_cfg():
    if platform.system() == "Linux":
        # 1. Intentar UFW (Ubuntu/Debian standard)
        try:
            for c in [[f"{p}/tcp", f"{p}/udp"] for p in [TCP_PORT, UDP_PORT]]:
                subprocess.run(["sudo", "ufw", "allow"] + c, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
        # 2. Intentar IPTABLES (Kali/RedHat/Arch fallback)
        # sudo iptables -C INPUT -p tcp --dport 44494 -j ACCEPT 2> /dev/null || sudo iptables -A INPUT -p tcp --dport 44494 -j ACCEPT
        try:
            for p, proto in [(TCP_PORT, 'tcp'), (UDP_PORT, 'udp')]:
                rule = ["sudo", "iptables", "-A", "INPUT", "-p", proto, "--dport", str(p), "-j", "ACCEPT"]
                # Check simple para no duplicar (es complejo en python puro, lanzamos el add y que iptables decida si duplica o no)
                # Mejor intentar solo si no existe, pero para simplificar lanzamos append.
                # Si el user no tiene sudo sin pass, fallara silencioso.
                subprocess.run(rule, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
    elif platform.system() == "Windows":
        subprocess.run(["powershell", f"Start-Process cmd -Verb RunAs -ArgumentList '/c netsh advfirewall firewall add rule name=\"CyberDEI\" dir=in action=allow protocol=ANY localport=\"{TCP_PORT},{UDP_PORT}\"'"], shell=True)

# send_raw eliminado (Replaced by alias above)
def send_all(d, targets=None):
    if targets is None:
        # Enviar solo a usuarios del chat actual
        targets = []
        if CURRENT_CHAT_ID:
            for ip, pdata in PEERS.items():
                if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                    targets.append(ip)

    for ip in [i for i in targets if i != MY_IP]: send_raw(ip, d)

# --- DISCOVERY & MEMORY ---
def update_memory(ip, nick, status):
    """Actualiza memoria y guarda en config"""
    global KNOWN_USERS
    now = time.time()
    
    # Detectar cambio de nombre
    old_nick = None
    if ip in KNOWN_USERS:
        old_nick = KNOWN_USERS[ip].get('nick', nick)
    
    KNOWN_USERS[ip] = {'nick': nick, 'status': status, 't': now}
    
    if old_nick and old_nick != nick:
        safe_print(f"{Colors.C}[Info] '{old_nick}' ahora se llama '{nick}'{Colors.E}")
        # Notificar a los hijos (para que en el chat se vea el cambio)
        # Iterar chats activos y enviar mensaje de sistema
        for cid, cdata in ACTIVE_CHATS.items():
            # Si es privado y es con esa IP:
            if cdata['type'] == 'PRIV' and cdata.get('remote_id') == ip:
                 cdata['remote_nick'] = nick # Actualizar metadata interna
                 # Send alert to child
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}El usuario cambio su nombre a {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))
            
            # Si es grupo, avisar tambien (mas complejo filtrar si esta en el grupo, pero avisamos igual si es relevante)
            if cdata['type'] == 'GROUP':
                 # Verificar si IP esta en grupo? Simplificamos: enviamos a todos los grupos activos
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}{old_nick} ahora es {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))

    if ip in PEERS:
        if isinstance(PEERS[ip], dict):
             PEERS[ip]['nick'] = nick
    save_config()

def handle_incoming_udp(d, ip):
    global PEERS, DISC_TEMP, PEER_STATUSES, SCAN_RESULTS
    
    msg = d.decode('utf-8', errors='ignore')
    debug_log(f"[UDP] Recibido de {ip}: {msg[:100]}") # Show first 100 chars
    
    if ip == MY_IP: return

    is_cmd, cmd, args = parse_packet(msg)

    if not is_cmd: return # Ignorar mensajes no estructurados en UDP

    if cmd == "SEARCH_GROUP":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                    send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

                gw_comm.send_udp_cmd(ip, "I_EXIST", gid, gpass, MY_NICK, MY_STATUS)

    elif cmd == "I_EXIST":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                        send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

    elif cmd == "WHOIS":
        # args[0] = target_nick (puede ser vac铆o)
        target = args[0].strip().lower() if args else ""

        # Soy yo?
        if not target or target == MY_NICK.lower():
            gw_comm.send_udp_cmd(ip, "USER_HERE", MY_NICK, MY_STATUS)

    elif cmd == "USER_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            # Check duplicate in DISC_TEMP
            if not any(x[0] == ip for x in DISC_TEMP):
                DISC_TEMP.append((ip, nick, st))
            update_memory(ip, nick, st)

    elif cmd == "WHO_ALL" and VISIBLE_IN_SCAN:
        gw_comm.send_udp_cmd(ip, "IAM_HERE", MY_NICK, MY_STATUS)

    elif cmd == "IAM_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            SCAN_RESULTS.append({'ip': ip, 'nick': nick, 'status': st})
            update_memory(ip, nick, st)

def find_global(t):
    target_clean = normalize_str(t)
    
    # 1. Check known
    for ip, d in KNOWN_USERS.items():
        if normalize_str(d['nick']) == target_clean or ip == t: return ip
        
    for ip, p in PEERS.items():
         if isinstance(p, dict) and normalize_str(p.get('nick', '')) == target_clean: return ip
         
    # 2. Discovery UDP
    safe_print(f"{Colors.W}[*] Buscando '{t}'...{Colors.E}")
    global DISC_TEMP
    DISC_TEMP = [] 
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHOIS", t), ('255.255.255.255', UDP_PORT)); u.close()
    
    time.sleep(2)
    
    for res in DISC_TEMP:
        # res = (ip, nick, status)
        # Check MATCH EXACTO (Insensitive)
        if normalize_str(res[1]) == target_clean:
            safe_print(f"{Colors.G}[+] Encontrado: {res[1]} en {res[0]}{Colors.E}")
            return res[0]
            
    safe_print(f"{Colors.F}[X] Usuario '{t}' no encontrado.{Colors.E}")
    
    # --- FUZZY SEARCH / SUGERENCIAS ---
    suggs = set() # (nick, ip)

    # Helper local
    def check_sim(n, ip):
        n_clean = normalize_str(n)
        if target_clean in n_clean: return True # Contenido exacto
        # Similitud > 55%
        if difflib.SequenceMatcher(None, target_clean, n_clean).ratio() > 0.55: return True
        return False

    # 1. Buscar en Resultados UDP
    for res in DISC_TEMP:
        if check_sim(res[1], res[0]): suggs.add((res[1], res[0]))

    # 2. Buscar en Historial Conocidos
    for ip, data in KNOWN_USERS.items():
        if check_sim(data['nick'], ip): suggs.add((data['nick'], ip))

    if suggs:
        safe_print(f"{Colors.W}驴Quiz谩s quisiste decir?:{Colors.E}")
        for snick, sip in suggs:
            safe_print(f"   > {Colors.BO}{snick}{Colors.E} ({sip})")

    return None

def scan_network(target_cid=None):
    global SCAN_RESULTS
    reply_print(f"{Colors.W}[*] Escaneando red local (1s)...{Colors.E}", target_cid)
    SCAN_RESULTS = []; u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHO_ALL"), ('255.255.255.255', UDP_PORT)); u.close(); time.sleep(1) # Optimizacion 2s -> 1s

    reply_print(f"{Colors.G}[*] Equipos Encontrados ({len(SCAN_RESULTS)}):{Colors.E}", target_cid)
    for res in SCAN_RESULTS:
        reply_print(f"   > {Colors.BO}{res['nick']}{Colors.E} ({res['ip']}) [{res['status']}]", target_cid)
    if not SCAN_RESULTS: reply_print("   (Ninguno visible)", target_cid)

def leave_sess(silent=False, exclude_ip=None, target_cid=None):
    global PEERS, PEER_STATUSES, CURRENT_CHAT_ID
    
    # Si no se especifica CID, usar el global (contexto Lobby)
    cid_to_close = target_cid if target_cid else CURRENT_CHAT_ID
    
    if not cid_to_close or cid_to_close not in ACTIVE_CHATS:
        if not silent: safe_print(f"{Colors.W}[!] Sesi贸n no v谩lida.{Colors.E}")
        return

    if not silent: safe_print(f"{Colors.W}[*] Cerrando sesi贸n {cid_to_close}...{Colors.E}")

    # Send disconnect to peers in THIS chat
    c = ACTIVE_CHATS[cid_to_close]
    to_remove = []

    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and cid_to_close in pdata.get('chats', []):
            if ip != exclude_ip:
                if c['type'] == 'GROUP':
                    send_cmd(ip, "LEAVE_GRP", c['remote_id'], MY_NICK)
                else: # PRIV
                    send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
            # Remove chat_id linkage
            pdata['chats'].discard(cid_to_close) # Use discard to be safe
            if not pdata['chats']: # Empty, user gone
                to_remove.append(ip)

    for ip in to_remove:
        if ip in PEERS: del PEERS[ip]
        if ip in PEER_STATUSES: del PEER_STATUSES[ip]

    # Matar proceso hijo si existe y no soy yo mismo el hijo suicid谩ndose
    if 'port' in ACTIVE_CHATS[cid_to_close]:
         # Enviamos kill por si acaso, aunque el hijo ya se haya ido
         send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid_to_close]['port'])

    del ACTIVE_CHATS[cid_to_close]
    
    # Si cerr茅 la sesi贸n activa del Lobby, limpiar variable
    if CURRENT_CHAT_ID == cid_to_close:
        CURRENT_CHAT_ID = None
        
    if not silent: safe_print(f"{Colors.G}[] Sesi贸n {cid_to_close} cerrada.{Colors.E}")

def start_private_chat(ip, nick, status="En l铆nea", send_ack=True):
    global CURRENT_CHAT_ID
    cid = str(uuid.uuid4())[:8]
    ACTIVE_CHATS[cid] = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': nick}
    CURRENT_CHAT_ID = cid

    if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
    if isinstance(PEERS[ip], dict):
        PEERS[ip]['nick'] = nick
        PEERS[ip]['chats'].add(cid)

    PEER_STATUSES[ip] = status
    update_memory(ip, nick, status)
    
    if send_ack:
        # v36.12 CRITICAL FIX: Send acceptance to inviter so they open their window!
        debug_log(f"[PROTOCOLO] Enviando INVITE_ACC (Confirmaci贸n) a {ip}...")
        # V2: INVITE_ACC uses [MPP]
        send_cmd(ip, "INVITE_ACC", get_my_mpp())
    debug_log(f"[PROTOCOLO] INVITE_ACC enviado. Ahora abriendo mi consola...")
    
    spawn_child_process(cid, ACTIVE_CHATS[cid]) # Spawn child immediately
    refresh_ui(f"{Colors.G}[*] Chat privado con {nick} iniciado.{Colors.E}")
    return cid

def join_grp(gid, gp, exclude_ip=None):
    # Ya no salimos de la sesi贸n anterior forzosamente
    # if PEERS: leave_sess(...) <--- REMOVED

    global CURRENT_CHAT_ID
    global PEERS, PEER_STATUSES

    if not CURRENT_CHAT_ID: return # Should not happen in child context

    safe_print(f"{Colors.G}[*] Conectando a '{gid}'...{Colors.E}")

    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("SEARCH_GROUP", gid, gp, MY_NICK, MY_STATUS), ('255.255.255.255', UDP_PORT)); u.close()

    time.sleep(2)
    # Check if peers found in this chat
    found_any = False
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
            found_any = True
            break

    if found_any:
        safe_print(f"{Colors.G}[] Unido.{Colors.E}")
        send_cmd_all("JOINED", MY_NICK, MY_STATUS); write_log(f"Grupo {gid}", "SYS")
    else:
        safe_print(f"{Colors.G}[] Sala creada (esperando peers).{Colors.E}"); write_log(f"Sala {gid}", "SYS")

    # Trigger Update Check on trusted peers in this group
    # Necesitamos la lista de IPs. Si es un join reciente, PEERS se va poblando.
    # Mejor hacerlo tras unos segundos o usar los que ya conocemos que est谩n ah铆.
    # Disparamos un hilo retardado
    # threading.Thread(target=lambda: (time.sleep(5), try_trigger_updates(list(PEERS.keys())))).start()
    pass

def invite_users(targets_str, target_cid=None):
    cid = target_cid if target_cid else CURRENT_CHAT_ID
    if not cid or cid not in ACTIVE_CHATS:
        return safe_print(f"{Colors.F}[!] Debes estar en un chat activo.{Colors.E}")

    chat = ACTIVE_CHATS[cid]
    if chat['type'] != 'GROUP':
        return safe_print(f"{Colors.F}[!] Solo puedes invitar en grupos.{Colors.E}")

    gid = chat['remote_id']
    gpass = chat['pass']

    targets = [t.strip() for t in targets_str.split(',')]

    members_list = ", ".join([d['nick'] for d in PEERS.values() if isinstance(d, dict) and cid in d.get('chats', [])])
    # payload = f"GRP_INVITE_REQ{SEP}{MY_NICK}{SEP}{gid}{SEP}{gpass}{SEP}{members_list}".encode() # Old

    safe_print(f"{Colors.W}[*] Enviando invitaciones...{Colors.E}")
    count = 0
    for t in targets:
        ip = find_global(t)
        if ip:
            pdata = PEERS.get(ip)
            if pdata and isinstance(pdata, dict) and cid in pdata.get('chats', []):
                 safe_print(f"   > {t}: Ya est谩 en el grupo.")
            else:
                send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, members_list)
                safe_print(f"   > {t}: Invitaci贸n enviada.")
                count += 1

    if count > 0:
        send_cmd_all("GRP_MSG", gid, f"[Grupo] {MY_NICK} ha invitado a {count} usuarios.")

# --- CORE ---
def set_afk_mode(cause_ip=None, cause_nick=None):
    global MY_STATUS, IS_AFK
    IS_AFK = True
    if not MY_STATUS.endswith("-AFK"): MY_STATUS += "-AFK"
    msg = f"{Colors.W}[!] Solicitud de {Colors.BO}{cause_nick}{Colors.E} {Colors.W}({cause_ip}) auto-rechazada. Entrando en AFK.{Colors.E}" if cause_nick else f"{Colors.W}[!] Timeout. Entrando en AFK.{Colors.E}"
    safe_print(msg); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def restore_from_afk():
    global MY_STATUS, IS_AFK
    if not IS_AFK: return
    IS_AFK = False
    if MY_STATUS == "Ausente (AFK)": MY_STATUS = "En l铆nea"
    elif MY_STATUS.endswith("-AFK"): MY_STATUS = MY_STATUS[:-4]
    safe_print(f"{Colors.G}[i] Bienvenido de vuelta. Estado: {MY_STATUS}{Colors.E}"); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def handle_invite_logic(ip, nick, type, extra_data=None):
    global PENDING_INVITE, PEER_STATUSES
    inviter_status = PEER_STATUSES.get(ip, "")

    req_text = ""
    if type == "PRIV": 
        req_text = f" 隆Hey! {nick} ({ip}) quiere iniciar una conversaci贸n contigo.\n\n驴Te gustar铆a aceptar la conexi贸n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat PRIV de {nick} ({ip})")
    else: 
        gid, gpass, members = extra_data
        req_text = f" {nick} quiere que formes parte del grupo \"{gid}\".\n\n驴Te unes a la conversaci贸n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat GROUP {gid} de {nick}")

    # --- GUI HANDLING (v26.1 Style: Popen + Polling) ---
    proc = None
    if platform.system() == "Linux" and HAS_ZENITY:
        try:
            proc = subprocess.Popen(["zenity", "--question", "--title=Invitaci贸n CyberDEI", f"--text={req_text}", "--timeout=30"], stderr=subprocess.DEVNULL)
        except: pass

    elif platform.system() == "Windows":
        # Windows Popen non-blocking
        # Strip emojis for Windows compatibility (PowerShell encoding issues)
        txt_win = req_text.encode('ascii', 'ignore').decode() 
        t_safe = txt_win.replace("\n", "`n").replace("'", "''")
        
        script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        $res = [System.Windows.Forms.MessageBox]::Show('{t_safe}', 'Invitaci贸n', 'YesNo', 'Question')
        if ($res -eq 'Yes') {{ exit 0 }} else {{ exit 1 }}
        """
        try:
             proc = subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", script], stderr=subprocess.DEVNULL)
        except: pass

    # Wait for GUI response if launched
    if proc:
        start_t = time.time()
        answered = False
        while time.time() - start_t < 30: # 30s timeout
            if proc.poll() is not None:
                answered = True
                debug_log(f"[INVITE_LOGIC] GUI process finished (Return Code: {proc.returncode})")
                break
            time.sleep(0.5) # Evitar consumo CPU 100%

        if answered:
            if proc.returncode == 0: # YES
                # Construir dict temporal y llamar yes
                safe_print(f"{Colors.M}[GUI] Aceptando invitaci贸n...{Colors.E}")
                debug_log(f"[INVITE_LOGIC] Usuario acept贸 en GUI. Ejecutando --y")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--y")
            else:
                debug_log(f"[INVITE_LOGIC] Usuario rechaz贸 en GUI. Ejecutando --n")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--n") # NO
            return
        else:
            # Timeout GUI -> AFK PROTOCOL
            try: proc.terminate()
            except: pass
            
            safe_print(f"{Colors.W}[!] Sin respuesta. Entrando en modo AFK.{Colors.E}")
            set_afk_mode(cause_ip=ip, cause_nick=nick)
            send_cmd(ip, "INVITE_REJ", MY_NICK, "Auto-AFK")
            return # Evitar fallback a CLI si ya fall贸 GUI

    # --- CLI FALLBACK (Solo si no hay GUI) ---
    # Set global pending invite DICTIONARY so --y/--n works in Lobby
    PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}

    msg_print(f"\n{Colors.M}**********************************{Colors.E}")
    msg_print(f"{Colors.M}* {req_text.upper()}{Colors.E}")
    msg_print(f"{Colors.M}* Escribe --y para Aceptar o --n para Rechazar{Colors.E}")
    msg_print(f"{Colors.M}**********************************{Colors.E}")
    safe_print("\a") # Beep

    # Loop de espera pasiva para CLI
    start_wait = time.time()
    while time.time() - start_wait < 30:
        if PENDING_INVITE is None: return # Respondido
        time.sleep(1)

    # Timeout CLI
    if PENDING_INVITE and PENDING_INVITE['ip'] == ip:
        msg_print(f"{Colors.F}[!] Invitaci贸n de {nick} expirada.{Colors.E}")
        send_cmd(ip, "INVITE_REJ", MY_NICK, "Timeout")
        PENDING_INVITE = None




# --- UTILS v36.0 ---
def calculate_file_hash(path):
    sha256_hash = hashlib.sha256()
    with open(path, "rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def dl_file(name, size, sock, sender, sender_ip=None, expected_hash=None, file_type='FILE'):
    if not os.path.exists(DL_DIR): os.makedirs(DL_DIR)
    tmp = os.path.join(DL_DIR, f".tmp_{int(time.time())}_{name}")
    try:
        with open(tmp, "wb") as f:
            r = 0
            while r < size:
                ch = sock.recv(min(BUFFER, size-r)); 
                if not ch: break
                f.write(ch); r += len(ch)
    except Exception as e: return safe_print(f"{Colors.F}Error DL: {e}{Colors.E}")

    # v36.0: Integrity Check
    if expected_hash:
        safe_print(f"{Colors.W}[*] Verificando integridad...{Colors.E}")
        cal_hash = calculate_file_hash(tmp)
        if cal_hash != expected_hash:
             safe_print(f"{Colors.F}[X] ERRO INTEGRIDAD: Hash mismatch.{Colors.E}")
             safe_print(f"    Esperado: {expected_hash[:8]}...")
             safe_print(f"    Recibido: {cal_hash[:8]}...")
             os.remove(tmp)
             return
        else:
             safe_print(f"{Colors.G}[] Integridad verificada.{Colors.E}")

    final_path = os.path.join(DL_DIR, name)
    
    # v36.0: Folder Logic (Si es DIR, es un zip que debemos descomprimir)
    is_zip_archive = (file_type == 'DIR')
    
    if AUTO_DL:
        if os.path.exists(final_path): 
            base, ext = os.path.splitext(name)
            final_path = os.path.join(DL_DIR, f"{base}_copy_{int(time.time())}{ext}")
        
        # Rename or Unzip
        if is_zip_archive:
             # Es un directorio comprimido. Le quitamos la extension .zip al nombre final si la tiene
             folder_final_path = final_path.replace('.zip', '')
             shutil.unpack_archive(tmp, folder_final_path)
             os.remove(tmp) # Borrar zip temporal
             final_path = folder_final_path + " (Carpeta)"
        else:
             os.rename(tmp, final_path)

        safe_print(f"{Colors.G}[] Archivo guardado: {final_path}{Colors.E}")
        popup(f"De: {sender}", f"Guardado: {name}", source_ip=sender_ip); write_log(f"Recibido {name}", "FILE")
        
        # Notify Local Chat Windows (Feature Request)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         # Send System Notification to Child
                         tag = f"[{Colors.C}{Colors.E}]"
                         msg = f"{Colors.C}{sender} ha enviado {'una carpeta' if is_zip_archive else 'un archivo'}: {name}{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

    else:
        # pending files logic, store hash/type for later accept? 
        # For simplicity, we assume if we are here we already accepted stream or stream happens anyway.
        # But wait, logic says "Wait for accept" BUT tcp stream ALREADY downloaded to tmp.
        # So we just keep tmp stored in PENDING_FILES with the metadata.
        PENDING_FILES.append({'t': tmp, 'r': final_path, 's': sender, 'hash': expected_hash, 'type': file_type})
        safe_print(f"{Colors.W}[?] '{name}' de {sender} espera (--aceptar/--rechazar).{Colors.E}"); popup("Archivo", f"{sender}: {name}", source_ip=sender_ip)
        
        # Notify Local Chat Windows (Manual Wait)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         tag = f"[{Colors.C}{Colors.E}]"
                         msg = f"{Colors.C}{sender} env铆a archivo: {name}. Escribe --aceptar.{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

def handle_incoming_tcp(c, ip, raw):
    global POPUP_ON, LAST_ACT, USER_OFF, PENDING_INVITE

    try:
        if raw:
            # 1. Intentar parsear como Paquete Estructurado v27
            is_cmd, cmd, args = parse_packet(raw)

            if is_cmd:
                # Auto-add to known if interaction happens
                if ip not in PEERS:
                    if ip in KNOWN_USERS:
                        PEERS[ip] = {'nick': KNOWN_USERS[ip]['nick'], 'chats': set()}
                    else:
                        PEERS[ip] = {'nick': "...", 'chats': set()}

                curr_nick = PEERS[ip]['nick']

                if not USER_OFF:
                    # Simple logic for popup, ignoring PRIVATE_PEER timeout logic for now
                    if not POPUP_ON and (time.time()-LAST_ACT > 30): POPUP_ON = True

                # BLOCK MODULAR DE COMANDOS
                if cmd == "INVITE":
                    # args: NICK, TYPE, (GID, GPASS, MEMBERS if group)
                    debug_log(f"[RED] Recibido INVITE de {ip}")
                    if len(args) >= 2:
                        nick, type = args[0], args[1]
                        extra = None
                        if type == "GROUP" and len(args) >= 5:
                            extra = (args[2], args[3], args[4]) # gid, pass, members

                        PEERS[ip]['nick'] = nick
                        st = args[len(args)-1] if type == "PRIV" and len(args) >= 3 else "?" # Status is last arg for PRIV
                        PEER_STATUSES[ip] = st
                        update_memory(ip, PEERS[ip]['nick'], st) # Sync al recibir
                        
                        debug_log(f"[INVITE_LOGIC] Iniciando logica de invitacion para {nick} (Tipo: {type})")
                        threading.Thread(target=handle_invite_logic, args=(ip, nick, type, extra)).start()

                elif cmd == "INVITE_ACC":
                    # args: R_NICK, R_STATUS
                    debug_log(f"[RED] Recibido INVITE_ACC de {ip}. Procesando aceptaci贸n...")
                    if len(args) >= 2:
                            r_nick, r_stat = args[0], args[1]
                            
                            # Buscar invitacion pendiente mia hacia esa IP?
                            # Asumimos que si llega INVITE_ACC es porque invitamos.
                            # Creamos sala PRIV
                            cid = str(uuid.uuid4())[:8]
                            cdata = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': r_nick}
                            ACTIVE_CHATS[cid] = cdata
                            
                            # LINK ROUTING
                            if ip not in PEERS: PEERS[ip] = {'nick': r_nick, 'chats': set()}
                            if isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].add(cid)
                                debug_log(f"[RED] Vinculada IP {ip} a CID {cid} (INVITE_ACC)")
                            
                            # TRUSTED PEERS (Add logic)
                            TRUSTED_PEERS.add(ip); save_config()

                            # Threading spawn to avoid blocking TCP loop (Fix Slowness)
                            debug_log(f"[PROCESO] Iniciando consola hija para chat confirmado {cid}")
                            threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
                            refresh_ui(f"{Colors.G}[*] {r_nick} acept贸 tu invitaci贸n.{Colors.E}")
                            
                            # TRIGGER UPDATE CHECK (Private)
                            # Esperar un poco para estabilidad TCP
                            # threading.Thread(target=lambda: (time.sleep(3), try_trigger_updates([ip]))).start(); 
                            write_log(f"Privado ok {r_nick}", "SYS")

                elif cmd == "INVITE_REJ":
                    # args: NICK, REASON
                    reason = args[1] if len(args)>1 else "?"
                    safe_print(f"{Colors.F}[X] {args[0]} rechaz贸 la invitaci贸n ({reason}).{Colors.E}")
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    PENDING_INVITE = None

                elif cmd == "INVITE_TOUT":
                    # args: NICK, STATUS
                    n = args[0] if len(args)>0 else curr_nick
                    st = args[1] if len(args)>1 else "AFK"
                    safe_print(f"{Colors.W}[!] {n} no respondi贸 (Timeout). Estado: {st}{Colors.E}")
                    update_memory(ip, n, st)
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]

                elif cmd == "GRP_INVITE_ACC":
                        # args: NICK
                        safe_print(f"{Colors.G}[] {args[0]} se uni贸 al grupo.{Colors.E}")
                        # UDP SEARCH_GROUP will handle the actual peer linkage.

                elif cmd == "JOINED":
                    # args: NICK, STATUS
                    PEERS[ip]['nick'] = args[0]
                    st = args[1] if len(args)>1 else ""
                    PEER_STATUSES[ip] = st
                    update_memory(ip, args[0], st)

                    pdata = PEERS.get(ip)
                    if pdata and isinstance(pdata, dict):
                        for cid in pdata.get('chats', set()):
                            if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                                if ACTIVE_CHATS[cid]['type'] == 'GROUP':
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.G}[+] {args[0]} entr贸 al grupo.{Colors.E}"
                                    send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

                    safe_print(f"{Colors.G}[+] {args[0]} entr贸.{Colors.E}") # Lobby Log

                elif cmd == "CHILD_EXIT":
                    cid = args[0]
                    if cid in ACTIVE_CHATS:
                        # Clean up
                        if 'port' in ACTIVE_CHATS[cid]: del ACTIVE_CHATS[cid]
                        # No borramos de PEERS aqui, solo la sesi贸n activa
                        pass

                    # Usamos safe_print antes del refresh para historial
                    safe_print(f"{Colors.G}[*] Chat cerrado (CID: {cid}).{Colors.E}")
                    refresh_ui()

                elif cmd == "GRP_MSG":
                    # args: GID, MSG
                    if len(args) >= 2:
                        gid, msg_content = args[0], args[1]
                        # Buscar localmente el chat que tiene remote_id == gid_target
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                            curr_nick = PEERS.get(ip, {}).get('nick', '?')
                            tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"
                            send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg_content}", ACTIVE_CHATS[target_cid]['port'])
                            write_log(f"[{curr_nick} @ {gid}]: {msg_content}", "CHAT")

                elif cmd == "STATUS_UPDATE":
                    # args: NICK, STATUS
                    if len(args) >= 2:
                        PEERS[ip]['nick'] = args[0]
                        PEER_STATUSES[ip] = args[1]
                        update_memory(ip, args[0], args[1])
                    elif len(args) == 1:
                        PEER_STATUSES[ip] = args[0]
                        update_memory(ip, curr_nick, args[0])

                elif cmd == "LEAVE_PRIV":
                    # args: NICK
                    safe_print(f"{Colors.W}[!] Un chat privado ha sido cerrado por {args[0]}.{Colors.E}")
                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]
                    refresh_ui()

                elif cmd == "LEAVE_GRP":
                    # args: GID, NICK
                    if len(args) >= 2:
                        gid, nick = args[0], args[1]
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid:
                            tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                            msg = f"{Colors.F}[] {nick} sali贸 del grupo.{Colors.E}"
                            if 'port' in ACTIVE_CHATS[target_cid]:
                                send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[target_cid]['port'])

                            if ip in PEERS and isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].discard(target_cid)
                        refresh_ui()

                elif cmd == "DISCONNECT_NOW":
                    # args: NICK
                    nick_disc = args[0] if args else "?"
                    safe_print(f"{Colors.F}[!] {nick_disc} se desconect贸 globalmente.{Colors.E}")

                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)
                        elif cdata['type'] == 'GROUP':
                            pdata = PEERS.get(ip)
                            if pdata and cid in pdata.get('chats', set()):
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.F}[] {nick_disc} se desconect贸.{Colors.E}"
                                    if 'port' in cdata: send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", cdata['port'])

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]

                    if ip in PEERS: del PEERS[ip]
                    if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    refresh_ui()

                elif cmd == "VER_CHECK" or cmd == "REQ_UPDATE" or cmd == "PUSH_UPDATE" or cmd == "VER_INFO":
                        pass # Deprecated P2P Update Commands
                    
                elif cmd == "WHOIS":
                    debug_log(f"Received WHOIS from {ip}")
                    pass

                elif cmd == "FILE_TRANSFER":
                    # args: FNAME, SIZE, [HASH, TYPE]
                    if len(args) >= 2:
                        fname = args[0]
                        fsize = int(args[1])
                        fhash = args[2] if len(args) > 2 else None
                        ftype = args[3] if len(args) > 3 else 'FILE'

                        target_cid = None
                        pdata = PEERS.get(ip)
                        if pdata and isinstance(pdata, dict):
                            for cid in pdata.get('chats', set()):
                                    if cid in ACTIVE_CHATS: target_cid = cid; break
                        
                        display_name = fname + " (Carpeta)" if ftype == 'DIR' else fname
                        safe_print(f"{Colors.W}[] Recibiendo '{display_name}' ({fsize} bytes)...{Colors.E}")
                        threading.Thread(target=dl_file, args=(fname, fsize, c, get_peer_name(ip), ip, fhash, ftype)).start()
                        return True # Keep socket open for thread

            else:
                # 2. NO ES COMANDO V27 -> Mensaje de Chat Privado (Texto Plano)
                debug_log(f"[TCP_ROUTING] Recibido mensaje plano de {ip}: '{raw[:20]}...'")
                
                target_cid = None
                pdata = PEERS.get(ip)
                if pdata:
                    chats = pdata.get('chats', set())
                    debug_log(f"[TCP_ROUTING] Chats asociados a IP {ip}: {chats}")
                    for cid in chats:
                            if cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'PRIV':
                                target_cid = cid
                                break
                else:
                        debug_log(f"[TCP_ROUTING] IP {ip} no encontrada en PEERS.")
                
                curr_nick = PEERS.get(ip, {}).get('nick', '?')
                tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"

                if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                        debug_log(f"[TCP_ROUTING] Reenviando por IPC a CID {target_cid} (Port {ACTIVE_CHATS[target_cid]['port']})")
                        send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{raw}{SEP}{ip}", ACTIVE_CHATS[target_cid]['port'])
                        write_log(f"[{curr_nick}] (FWD {target_cid}): {raw}", "CHAT")
                else:
                    debug_log(f"[TCP_ROUTING] Fallo de enrutamiento para {ip}: CID={target_cid}")
                    safe_print(f"{tag}: {raw}"); popup(f"MSG: {curr_nick}", raw, source_ip=ip); write_log(f"[{curr_nick}]: {raw}", "CHAT")

    except Exception as e:
        # safe_print(f"Err TCP: {e}")
        pass
    
    return False # Default close

def send_file(arg, target_cid=None):
    path = os.path.expanduser(arg.strip().strip("'\""))
    if not os.path.exists(path): return safe_print(f"{Colors.F}[X] No existe.{Colors.E}") # isfile -> exists (for dirs)
    
    # v36.0: Folder Support
    is_dir = os.path.isdir(path)
    to_send_path = path
    file_type = 'FILE'
    
    if is_dir:
        safe_print(f"{Colors.W}[*] Comprimiendo carpeta '{os.path.basename(path)}'...{Colors.E}")
        # Crear zip temporal
        # make_archive (base_name, format, root_dir)
        # shutil.make_archive generar谩 filename + .zip
        tmp_zip_base = f".gwc_tmp_{int(time.time())}"
        shutil.make_archive(tmp_zip_base, 'zip', path)
        to_send_path = tmp_zip_base + ".zip"
        file_type = 'DIR'
    
    # Calculate integrity
    f_hash = calculate_file_hash(to_send_path)
    n, s = os.path.basename(to_send_path) if not is_dir else os.path.basename(path) + ".zip", os.path.getsize(to_send_path)

    # Target logic same as send_all
    targets = []
    
    # Use explicit target_cid if provided, else rely on global (legacy)
    cid_to_use = target_cid if target_cid else CURRENT_CHAT_ID
    
    if cid_to_use:
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and cid_to_use in pdata.get('chats', []):
                targets.append(ip)

    if not targets: return safe_print(f"{Colors.F}[X] Nadie en el chat actual.{Colors.E}")

    safe_print(f"{Colors.W}[] Enviando '{n}' ({s} bytes, Hash: {f_hash[:8]})...{Colors.E}"); write_log(f"Send {n}", "FILE")

    cnt = 0
    for ip in [i for i in targets if i != MY_IP]:
        try:
            k = socket.socket(socket.AF_INET, socket.SOCK_STREAM); k.settimeout(2); k.connect((ip, TCP_PORT))
            # PACKET v36: FILE_TRANSFER | NAME | SIZE | HASH | TYPE
            k.send(build_packet("FILE_TRANSFER", n, s, f_hash, file_type)); time.sleep(0.1)
            with open(to_send_path, "rb") as f:
                while True:
                    d = f.read(BUFFER);
                    if not d: break
                    k.sendall(d)
            k.close(); cnt += 1
        except Exception as e: safe_print(f"Err Send: {e}")
    safe_print(f"{Colors.G}[] Enviado a {cnt}.{Colors.E}")
    
    # Cleanup tmp zip
    if is_dir and os.path.exists(to_send_path):
        os.remove(to_send_path)

def send_ipc(msg, port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # No necesario para enviar
        s.sendto(msg.encode(), ('127.0.0.1', port))
        s.close()
    except: pass

# --- ACTUALIZACIN DE SISTEMA (REPO APT) ---
VERSION_URL = "https://omarsaez.github.io/ghostwhisperchat-repo/version.txt"

def perform_system_update():
    """Ejecuta los comandos de sistema para actualizar"""
    safe_print(f"{Colors.M}[*] Ejecutando actualizaci贸n de sistema...{Colors.E}")
    try:
        # Encadenamos update e install
        # apt install --only-upgrade asegura que no instale cosas nuevas, solo actualice lo que hay
        cmd = "sudo apt update && sudo apt install ghostwhisperchat --only-upgrade -y"
        
        subprocess.run(cmd, shell=True, check=True)
        
        safe_print(f"{Colors.G}[] Actualizaci贸n lista. Reiniciando...{Colors.E}")
        # Reiniciar el script autom谩ticamente
        os.execv(sys.executable, ['python3'] + sys.argv)
        
    except subprocess.CalledProcessError:
        safe_print(f"{Colors.F}[X] Error en la actualizaci贸n (驴Contrase帽a incorrecta?){Colors.E}")
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error inesperado: {e}{Colors.E}")

def check_repo_update():
    """Verifica silenciosamente si el repo tiene una versi贸n mayor"""
    if platform.system() != "Linux": return # Solo apt por ahora
    
    # safe_print(f"{Colors.W}[*] Buscando actualizaciones en repositorio...{Colors.E}")
    try:
        # 1. Bajar el numerito (timeout corto para no congelar la app)
        # Usamos el alias 'request' cargado por lazy_import
        with request.urlopen(VERSION_URL, timeout=3) as response:
            content = response.read().decode().strip()
            # Manejar posibles saltos de linea o espacios
            latest_ver = float(content)
            
        # 2. Comparar con la constante local
        if latest_ver > APP_VER_NUM:
            safe_print(f"{Colors.W}[!] Nueva versi贸n disponible: v{latest_ver}{Colors.E}")
            # Preguntar al usuario - INPUT bloquea?
            # En run_lobby estamos en hilo principal antes del input loop.
            # Podemos usar input simple.
            try:
                # Flush input buffer
                if platform.system() == "Linux": subprocess.run("tcflush", shell=True, stderr=subprocess.DEVNULL) 
            except: pass
            
            raw_print(f"{Colors.G}驴Deseas actualizar ahora? se necesitaran permisos ROOT (sudo) [s/n]: {Colors.E}")
            # Usamos input builtin directo
            do_up = input()
            
            if do_up.lower().startswith('s'):
                perform_system_update()
            else:
                 safe_print(f"{Colors.W}[*] Actualizaci贸n pospuesta.{Colors.E}")

    except Exception as e:
        # Si falla internet o github, no hacemos nada, seguimos normal
        # safe_print(f"Update Check Fail: {e}")
        pass

# ... existing code ...

def toggle_autostart(enable, target_cid=None):
    """Activa o desactiva el inicio autom谩tico en Linux (.config/autostart)"""
    if platform.system() != "Linux":
        return reply_print(f"{Colors.F}[!] Solo disponible en Linux por ahora.{Colors.E}", target_cid)
        
    autostart_dir = os.path.expanduser("~/.config/autostart")
    desktop_file = os.path.join(autostart_dir, "inter_chat_auto.desktop")
    
    if enable:
        try:
            if not os.path.exists(autostart_dir): os.makedirs(autostart_dir)
            
            # Obtener rutas absolutas
            exe = sys.executable
            script = os.path.abspath(sys.argv[0])
            
            content = f"""[Desktop Entry]
Type=Application
Name=InterChat Auto
Exec={exe} "{script}"
Terminal=true
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Comment=Auto-start InterChat Lobby
"""
            with open(desktop_file, "w") as f:
                f.write(content)
            
            # Dar permisos de ejecuci贸n al script por si acaso
            # os.chmod(script, 0o755) # Comentado: Falla en /usr/bin/ si no eres root. Ya deber铆a ser ejecutable.
            
            reply_print(f"{Colors.G}[] Autolevantado ACTIVADO (Inicio de sesi贸n).{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error activando autostart: {e}{Colors.E}", target_cid)
    else:
        try:
            if os.path.exists(desktop_file):
                os.remove(desktop_file)
                reply_print(f"{Colors.W}[] Autolevantado DESACTIVADO.{Colors.E}", target_cid)
            else:
                reply_print(f"{Colors.W}[!] No estaba activado.{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error desactivando: {e}{Colors.E}", target_cid)

# --- COMANDOS LOBBY CENTRALIZADOS ---
def exec_lobby_cmd(inp, origin_cid=None):
    import gw_cmd
    gw_cmd.process(inp, origin_cid, LOBBY_ADAPTER)

class LobbyAdapter:
    def reply(self, msg, cid):
        # Lobby context reply
        if not cid: safe_print(msg)
        else:
             # If target is child, IPC forwarding?
             # But Adapter.reply usually means "Print to Console or Send to Child Console"
             # If msg comes from Lobby Logic, we print to Lobby.
             # If msg target is Child CID, we IPC to child?
             if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                  # Forward as System Message
                  send_ipc(f"MSG_IN{gw_comm.SEP}{msg}", ACTIVE_CHATS[cid]['port'])
             else:
                  safe_print(msg)

    def create_group(self, remote_id, password):
        # UX: Animation "Connecting"
        with Loader(f"{Colors.C}[*] Sincronizando grupo '{remote_id}'{Colors.E}"):
             time.sleep(2.0)
             
             # 1. Create Local Session
             cid = str(uuid.uuid4())[:8]
             cdata = {
                'type': 'GROUP', 'remote_id': remote_id, 'pass': password, 
                'created_at': time.time(), 'remote_nick': f"Grupo {remote_id}"
             }
             ACTIVE_CHATS[cid] = cdata
        
             # 2. Spawn Child
             threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
        
             # 3. Network Discovery (V2)
             gw_comm.send_cmd(None, "SEARCH_GROUP", get_my_mpp(), remote_id, password)
             
        # Restore Prompt
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def find_global(self, args): return find_global(args)

    def join_group(self, cid): pass # Unused, create_group handles join logic

    def invite_priv(self, ip, nick, status):
        # V2 Logic + Loader
        with Loader(f"{Colors.C}[*] Conectando con {nick} ({ip})...{Colors.E}"):
             time.sleep(1.5)
             gw_comm.send_cmd(ip, "INVITE", get_my_mpp(), "PRIV")
        
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def get_chat(self, cid): return ACTIVE_CHATS.get(cid)
    def get_my_info(self): return MY_NICK, MY_IP, MY_STATUS
    def get_mpp(self): return get_my_mpp()
    def get_peers(self): return PEERS
    
    def show_lobby_summary(self):
         safe_print(f"{Colors.G}--- RESUMEN DE RED ---{Colors.E}")
         safe_print(f"Total de Usuarios Conocidos: {len(PEERS) + 1}")
         safe_print(f"{Colors.BO} > {MY_NICK} ({MY_IP}) [Yo]{Colors.E}")
         for ip, d in PEERS.items():
             est = d.get('status','?') # PEERS structure update V40
             # In V40 we use PEERS[ip] = {nick, ver, status?}
             # Fallback to PEER_STATUSES[ip] if simpler
             est = PEER_STATUSES.get(ip, est)
             n = d.get('nick', '?')
             safe_print(f" - {n} ({ip}) [{est}]")
             
         safe_print(f"\n{Colors.G}Sesiones de Chat Activas ({len(ACTIVE_CHATS)}):{Colors.E}")
         for cid, d in ACTIVE_CHATS.items():
             safe_print(f" - [{cid}] {d['type']}: {d.get('remote_nick', d['remote_id'])}")

    def get_known_users(self): 
        # Merge Saved (KNOWN_USERS) + Runtime (PEERS)
        ku = KNOWN_USERS.copy()
        for ip, d in PEERS.items():
            ku[ip] = {
                'nick': d.get('nick','?'), 
                'status': PEER_STATUSES.get(ip, d.get('status', '?')), 
                't': time.time()
            }
        return ku

    def scan_network(self, cid):
        def _scan_task():
            global SCANNING_NOW, SCAN_BUFFER
            SCAN_BUFFER = []
            SCANNING_NOW = True
            
            initial_peers = len(PEERS)
            
            # Send Broadcast
            gw_comm.send_cmd_all("WHOIS", get_my_mpp())
            
            # Animation Wait (3s)
            if not cid:
                with Loader(f"{Colors.C}[*] Escaneando red{Colors.E}"):
                    time.sleep(3)
            else:
                time.sleep(3)
                
            SCANNING_NOW = False
            
            # Flush Buffer
            for m in SCAN_BUFFER:
                if cid: self.reply(m, cid)
                else: safe_print(m)
            
            # Check delta
            final_peers = len(PEERS)
            new_found = final_peers - initial_peers
            
            if new_found > 0:
                self.reply(f"{Colors.G}[] Escaneo finalizado. {new_found} nuevos dispositivos detectados.{Colors.E}", cid)
            else:
                if len(PEERS) > 0:
                     self.reply(f"{Colors.G}[] Escaneo finalizado. {len(PEERS)} dispositivos activos en lista.{Colors.E}", cid)
                else:
                     self.reply(f"{Colors.W}[!] Escaneo finalizado. No se detectaron nodos activos.{Colors.E}", cid)
                
            # Restore Prompt if in Lobby
            if not cid:
                sys.stdout.write(PROMPT)
                sys.stdout.flush()
        
        threading.Thread(target=_scan_task, daemon=True).start()
    
    def set_config(self, key, val):
        global VISIBLE_IN_SCAN, MY_STATUS, MY_NICK, LOG_ON, AUTO_DL, USER_OFF
        if key == 'visible': VISIBLE_IN_SCAN = val
        elif key == 'status': MY_STATUS = val
        elif key == 'nick': MY_NICK = val
        elif key == 'log_on': LOG_ON = val
        elif key == 'pop_on': 
            gw_pop.POP.set_active(val)
            return
        elif key == 'auto_dl': AUTO_DL = val
        save_config()

    def broadcast_status(self, st=None): 
        # V2 STATUS_UPDATE: [CMD]STATUS_UPDATE|1|[MPP][CMD]
        # MPP already contains new Status/Nick
        gw_comm.send_cmd(None, "STATUS_UPDATE", get_my_mpp())

    def update_title(self): set_terminal_title(f"GWC Lobby - {MY_NICK}")
    def toggle_autostart(self, val, cid): toggle_autostart(val, cid)
    
    def clear_screen(self, cid):
        global LOBBY_HISTORY
        LOBBY_HISTORY = []
        if cid: self.reply(f"{Colors.G}Pantalla limpiada.{Colors.E}", cid)
        else: refresh_ui()

    def invite_users(self, args_str, cid):
        # Logic V2: Parse args (Nick/IPs) -> Send INVITE
        targets = args_str.replace(",", " ").split()
        
        # UX Animation
        if not cid:
             # Only loader if inside Lobby (otherwise child does its own thing or stream interrupts)
             # But if User types help in child, here we are in LobbyAdapter?
             # invite_users from Child passes cid.
             # If cid is active, Loader inside Lobby text is weird for child user.
             # Child user expects reply "Invitando...".
             pass
        
        # Universal Loader if CID is None (Lobby Command)
        if not cid:
            loader = Loader(f"{Colors.C}[*] Enviando invitaciones{Colors.E}")
            loader.__enter__()
            time.sleep(1.5)
        
        for t in targets:
            # Check if IP or Nick
            target_ip = None
            if "." in t and len(t.split(".")) == 4: target_ip = t
            else:
                # Resolve Nick
                for ip, p in PEERS.items():
                    if p.get('nick') == t: target_ip = ip; break
            
            if target_ip:
                # Send V2 INVITE
                gw_comm.send_cmd(target_ip, "INVITE", get_my_mpp(), "PRIV")
                self.reply(f"{Colors.G}[] Invitaci贸n enviada a {t} ({target_ip}){Colors.E}", cid)
            else:
                self.reply(f"{Colors.R}[X] No encontrado: {t}{Colors.E}", cid)
        
        if not cid:
            loader.__exit__(None, None, None)
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def send_file(self, args, cid): send_file(args, target_cid=cid)
    def leave_sess(self, cid): leave_sess(target_cid=cid)
    def shutdown_app(self): shutdown_lobby()
    
    def handle_accept(self, cid):
        global PENDING_INVITE
        if not PENDING_INVITE: return reply_print(f"{Colors.W}No tienes invitaciones pendientes.{Colors.E}", cid)
        
        # UX Animation (Only if Lobby)
        if not cid:
            with Loader(f"{Colors.C}[*] Sincronizando sesi贸n{Colors.E}"):
                time.sleep(1.5)
        else:
             reply_print(f"{Colors.G}[*] Aceptando...{Colors.E}", cid)

        if PENDING_INVITE['type'] == 'GROUP':
             self.create_group(PENDING_INVITE['data'][0], PENDING_INVITE['data'][1])
             self.reply(f"{Colors.G}[*] Grupo creado/unido.{Colors.E}", cid)
        else:
             start_private_chat(PENDING_INVITE['ip'], PENDING_INVITE.get('nick','?'))
        PENDING_INVITE = None
        
        # Restore prompt if Lobby
        if not cid:
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def handle_deny(self, cid):
        global PENDING_INVITE
        if PENDING_INVITE:
             reply_print(f"{Colors.W}[*] Invitaci贸n rechazada.{Colors.E}", cid)
             send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Rechazado")
             PENDING_INVITE = None
        else:
             reply_print(f"{Colors.W}Nada que rechazar.{Colors.E}", cid)

    def get_var(self, name):
        if name == 'visible': return VISIBLE_IN_SCAN
        if name == 'auto_dl': return AUTO_DL
        if name == 'pop_on': return POPUP_ON
        if name == 'log_on': return LOG_ON
        return None

    def get_active_chats(self): return ACTIVE_CHATS
    def get_version_str(self): return APP_VERSION
    
    def show_contacts(self, cid):
        users = self.get_known_users()
        self.reply(f"{Colors.G}[*] Historial de Sesi贸n ({len(users)}):{Colors.E}", cid)
        for ip, d in users.items(): 
            msg = f"   - {d['nick']} ({ip}) [{d['status']}] (Visto: {time.strftime('%H:%M', time.localtime(d['t']))})"
            self.reply(msg, cid)

    def show_global_status(self, cid):
        import gw_cmd
        gw_cmd.show_global_status(self, cid)

    def toggle_debug(self):
        global DEBUG_MODE
        DEBUG_MODE = not DEBUG_MODE
        # Logic from command
        # dsk = get_desktop_path()... we assume caller handles logging the toggle status via reply
        return DEBUG_MODE

LOBBY_ADAPTER = LobbyAdapter()

# --- PROCESOS & LOBBY ---

def check_child_health():
    """Vigila si los procesos hijos siguen vivos. Si no, limpia la sesi贸n."""
    while True:
        time.sleep(2) # v37.26: Faster check (2s)
        to_kill = []
        for cid, data in list(ACTIVE_CHATS.items()):
            if 'pid' in data:
                pid = data['pid']
                try:
                    # Check if process exists (signal 0 does nothing but checks access)
                    os.kill(pid, 0)
                except OSError:
                    # Process died
                    to_kill.append(cid)
                    
        for cid in to_kill:
             if cid in ACTIVE_CHATS:
                 cdata = ACTIVE_CHATS[cid]
                 rem_nick = cdata.get('remote_nick', cdata.get('remote_id', '?'))
                 type_s = cdata.get('type', '?')
                 
                 safe_print(f"\n{Colors.W}[Info] Se detect贸 cierre de ventana ({type_s}: {rem_nick}). Limpiando sesi贸n...{Colors.E}")
                 
                 # v37.26: Use consistent disconnect logic
                 # Using leave_sess logic manually here to avoid modifying dict while iterating if leave_sess does strange things,
                 # but actually leave_sess removes from ACTIVE_CHATS.
                 # Let's replicate safe leave logic:
                 
                 # Avisar al remoto si es privado
                 if cdata['type'] == 'PRIV':
                     if 'remote_id' in cdata:
                         send_cmd(cdata['remote_id'], "DISCONNECT_NOW", MY_NICK)
                 elif cdata['type'] == 'GROUP':
                     if 'remote_id' in cdata:
                          send_cmd_all("LEAVE_GRP", cdata['remote_id'], MY_NICK)
                 
                 # Remove local
                 del ACTIVE_CHATS[cid]

def spawn_child_process(cid, cdata):
    # Asignar puerto 煤nico para este hijo (IPC)
    # Buscamos puerto libre o usamos hash/incremental
    child_port = IPC_PORT + 1
    # Optimization: Limited search range
    for i in range(100): 
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', child_port))
            break # Free
        except: child_port += 1
    
    cdata['port'] = child_port
    rnick = cdata.get('remote_nick', '?')

    script_path = os.path.abspath(sys.argv[0])
    
    # Create Child Environment with correct PYTHONPATH for source execution
    child_env = os.environ.copy()
    repo_lib = os.path.join(os.path.dirname(os.path.dirname(script_path)), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
         old_pp = child_env.get("PYTHONPATH", "")
         child_env["PYTHONPATH"] = f"{repo_lib}{os.pathsep}{old_pp}" if old_pp else repo_lib
    
    cmd_args = [
        sys.executable, script_path, 
        "--child", cid,
        "--type", cdata['type'],
        "--remote", cdata['remote_id'],
        "--pass", str(cdata['pass']),
        "--nick", MY_NICK,
        "--status", MY_STATUS,
        "--port", str(child_port),
        "--rnick", rnick
    ]
    debug_log(f"Spawn start ({time.time()}) CMD: {cmd_args}")
    
    # Detectar terminal
    try:
        terminal_cmd = None
        if shutil.which("gnome-terminal"):
            # v37.24 FIX: Use --wait
            terminal_cmd = ["gnome-terminal", "--wait", "--"] + cmd_args
        elif shutil.which("konsole"):
            terminal_cmd = ["konsole", "--nofork", "-e"] + cmd_args
        elif shutil.which("xfce4-terminal"):
             terminal_cmd = ["xfce4-terminal", "--disable-server", "--"] + cmd_args
        elif shutil.which("xterm"):
             terminal_cmd = ["xterm", "-e"] + cmd_args
        elif shutil.which("x-terminal-emulator"):
             terminal_cmd = ["x-terminal-emulator", "-e"] + cmd_args
        
        if terminal_cmd:
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            try:
                 dlog = open(log_path, "a")
                 dlog.write(f"\n[{time.time()}] Launching Primary: {' '.join(terminal_cmd)}\n")
                 proc = subprocess.Popen(terminal_cmd, stdout=dlog, stderr=dlog, env=child_env)
            except:
                 proc = subprocess.Popen(terminal_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, env=child_env)
            
            time.sleep(0.5)
            poll_res = proc.poll()
            
            if poll_res is not None and poll_res != 0:
                print(f"{Colors.F}[!] Error: La terminal fall贸 (Code {proc.returncode}).{Colors.E}")
                # Fallback to background
                log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
                with open(log_path, "a") as err_log:
                    # Also pass env to fallback
                    proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid
        else:
            print(f"{Colors.F}[!] No se encontr贸 terminal compatible.{Colors.E}")
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            with open(log_path, "a") as err_log:
                proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid

        # Feedback
        if cdata['type'] == 'GROUP':
            gid = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir谩 una nueva consola para el chat grupal {gid}.{Colors.E}")
        else:
            target = cdata.get('remote_nick', '?')
            if target == '?': target = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir谩 una nueva consola para el chat privado con {target}.{Colors.E}") 

    except Exception as e:
        print(f"{Colors.F}[!] Error lanzando terminal: {e}{Colors.E}")

def ipc_listen_parent():
    global ACTIVE_CHATS
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: u.bind(('127.0.0.1', IPC_PORT))
    except: return print(f"{Colors.F}[!] Error binding IPC {IPC_PORT}{Colors.E}")
    
    while True:
        try:
            d, _ = u.recvfrom(4096); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "CHILD_EXIT":
                cid = p[1]
                if cid in ACTIVE_CHATS:
                    # v37.26 Fix: Notify peers correctly before local deletion
                    # Using leave_sess ensures DISCONNECT_NOW/LEAVE_GRP is sent.
                    leave_sess(target_cid=cid, silent=False) 
                    refresh_ui()
            
            elif cmd == "FWD_CMD":
                if len(p) >= 3:
                     cstr = p[2]
                     # print(f"\\n{Colors.M}[IPC] Ejecutando comando remoto: {cstr}{Colors.E}")
                     exec_lobby_cmd(cstr, origin_cid=p[1])

        except Exception as e:
            debug_log(f"[IPC_ERROR] Error en listener IPC del Lobby: {e}")

def ipc_listen_child(my_port, lock_state):
    # lock_state es un dict compartido con el thread principal del hijo para leer/escribir estado de POPs
    global MY_CHILD_ID
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try: u.bind(('127.0.0.1', int(my_port)))
    except Exception as e: 
        print(f"Error bind child IPC: {e}")
        return
    
    while True:
        try:
            d, _ = u.recvfrom(8192); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "FWD_MSG":
                if len(p) >= 4:
                    cid, tag, text = p[1], p[2], p[3]
                    if cid == MY_CHILD_ID:
                        safe_print(f"{tag}: {text}") 
                        
                        # LOGICA SMART POPUP
                        now = time.time()
                        last_in = lock_state.get('last_input', 0)
                        last_rx = lock_state.get('last_rx', 0)
                        manual_off = lock_state.get('pop_off', False)
                        ctype = lock_state.get('type', 'PRIV')
                        
                        # Actualizamos last_rx AHORA (actividad reciente en el chat)
                        lock_state['last_rx'] = now
                        
                        should_pop = False

                        # 1. Chequeo Manual Override (Prioridad Alta)
                        if manual_off:
                            # Si activado 'mute', solo suena si pasaron 5 mins (300s) de TOTAL SILENCIO previo
                            # Ojo: last_rx se acaba de actualizar, asi que comparamos con el last_rx *antes* de este msg?
                            # El usuario dijo: "pasan 5 minutos sin actividad... se vuelven a activar".
                            # Significa que si entre el mensaje ANTERIOR y ESTE pasaron > 300s, reactivamos.
                            if (now - last_rx) > TIMERS['MANUAL']:
                                lock_state['pop_off'] = False # Reactivar
                                safe_print(f"{Colors.W}[i] Popups reactivados por inactividad prolongada.{Colors.E}")
                                should_pop = True
                        else:
                            # 2. Chequeo Smart (Solo si no escrib铆 yo recientemente)
                            limit = TIMERS['PRIV'] if ctype == 'PRIV' else TIMERS['GROUP']
                            if (now - last_in) > limit:
                                should_pop = True
                        
                        if should_pop:
                             # Limpiar colores (ANSI escape codes) PRIMERO
                             # Si quitamos corchetes antes, rompemos la secuencia \033[...m
                             ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                             
                             tag_clean = ansi_escape.sub('', tag)
                             text_clean = ansi_escape.sub('', text)
                             
                             # Ahora sacar los corchetes decorativos del tag
                             sender_clean = tag_clean.replace('[','').replace(']','')
                             
                             title = ""
                             if ctype == 'GROUP':
                                 # Necesitamos el ID del grupo
                                 rid = lock_state.get('remote_id', '?')
                                 title = f"Mensaje grupal ({rid}) de {sender_clean}"
                             else:
                                 title = f"Mensaje privado de {sender_clean}"

                             popup(title, text_clean)

            elif cmd == "FWD_FILE":
                if len(p) >= 4 and p[1] == MY_CHILD_ID:
                    safe_print(f"{Colors.W}[] Archivo '{p[3]}' de {p[2]} recibido en Lobby.{Colors.E}")
            
            elif cmd == "FWD_PEER":
                if len(p) >= 4:
                    rmt_ip, rmt_nick, rmt_stat = p[1], p[2], p[3]
                    if rmt_ip not in PEERS: PEERS[rmt_ip] = {'nick': rmt_nick, 'chats': {MY_CHILD_ID}}
                    else: 
                         if isinstance(PEERS[rmt_ip], dict):
                             PEERS[rmt_ip]['nick'] = rmt_nick
                             PEERS[rmt_ip]['chats'].add(MY_CHILD_ID)
                    safe_print(f"{Colors.G}[+] Detectado: {rmt_nick}{Colors.E}")
            
            elif cmd == "CMD_CLOSE_NOW":
                # Fuerza cierre (ej: peer desconectado en privado)
                # Usamos global REMOTE_NICK seteada en run_child
                safe_print(f"\n{Colors.F}[] {REMOTE_NICK} ha abandonado el chat.{Colors.E}")
                # print(f"\n{Colors.F}[!] Cierre remoto: {p[1] if len(p)>1 else ''}{Colors.E}")
                time.sleep(3)
                # No mandamos exit signal propia para evitar bucle, solo salimos
                os._exit(0)

        except: pass

def shutdown_lobby():
    # Animated Exit
    with Loader(f"{Colors.W}[*] Cerrando todas las sesiones y saliendo{Colors.E}"):
        
        # 1. Notificar a peers remotos (Global Disconnect)
        active_targets = []
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and pdata.get('chats'):
                 active_targets.append(ip)

        for ip in active_targets:
            # send_cmd legacy compatible or V2?
            # V2 DISCONNECT_ALL: [CMD]DISCONNECT_ALL|1|[MPP][CMD]
            # send_cmd wrapper handles MPP?
            # send_cmd(ip, cmd, *args) -> build_cmd
            # If we reuse old DISCONNECT_NOW for compatibility
            send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
            
        # 2. Cerrar hijos locales
        for cid, cdata in list(ACTIVE_CHATS.items()):
            if 'port' in cdata:
                # Mandar se帽al de cierre suicida al hijo
                send_ipc("CMD_CLOSE_NOW", cdata['port'])
        
        time.sleep(1.0) # Dar tiempo a que salgan los mensajes

    restore_terminal()
    print(f"\n{Colors.G}[] Todo cerrado. Hasta luego.{Colors.E}")
    sys.exit(0)

def restore_terminal():
    """Restaura el eco de la terminal en Linux si se perdi贸"""
    if platform.system() != "Windows":
        os.system("stty echo")

# Asegurar restauraci贸n al salir brusco
atexit.register(restore_terminal)


def liberate_ports():
    """Detecta y elimina procesos zombies ocupando nuestros puertos"""
    ports = [TCP_PORT, UDP_PORT]
    try:
        if platform.system() == "Linux":
            for p in ports:
                subprocess.run(f"fuser -k {p}/tcp", shell=True, stderr=subprocess.DEVNULL)
                subprocess.run(f"fuser -k {p}/udp", shell=True, stderr=subprocess.DEVNULL)
        elif platform.system() == "Windows":
             for p in ports:
                 try:
                     r = subprocess.check_output(f"netstat -ano | findstr :{p}", shell=True, stderr=subprocess.DEVNULL).decode(errors='ignore')
                     lines = r.strip().split('\n')
                     for line in lines:
                         parts = line.split()
                         if len(parts) > 4:
                             pid = parts[-1]
                             if pid != "0": # No matar System
                                 subprocess.run(f"taskkill /F /PID {pid}", shell=True, stderr=subprocess.DEVNULL)
                 except: pass
    except: pass

def enable_win_visuals():
    """Fuerza UTF-8 y ANSI Colors en consola de Windows"""
    if platform.system() == "Windows":
        try:
            # 1. UTF-8
            os.system("chcp 65001 > nul") 
            # 2. ANSI VT100
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except: pass

def setup_autocomplete():
    """Configura el autocompletado para la l铆nea de comandos del lobby."""
    if platform.system() != "Windows": # Readline no est谩 disponible en Windows por defecto
        try:
            import readline
            
            # Obtener todos los comandos y sus alias
            all_commands = []
            for cmd_key, data in COMMAND_DEFS.items():
                all_commands.append(f"--{cmd_key.lower()}") # Comando principal
                for alias in data['aliases']:
                    if alias.startswith('--'):
                        all_commands.append(alias)
            
            # Funci贸n de autocompletado Inteligente
            def completer(text, state):
                buffer = readline.get_line_buffer()
                line_parts = buffer.lstrip().split()
                
                options = []
                
                # Contexto: 驴Es el inicio de la l铆nea o un comando?
                # Si estamos escribiendo la primera palabra
                if not line_parts or (len(line_parts) == 1 and not buffer.endswith(' ')):
                    options = [i for i in all_commands if i.startswith(text)]
                
                else:
                    # Contexto: Argumentos
                    cmd_str = line_parts[0]
                    cmd_key = resolve_cmd(cmd_str)
                    
                    # Si el comando es INVITE o CHAT_PRIV, sugerir Usuarios
                    if cmd_key in ['INVITE', 'CHAT_PRIV']:
                        # Prioridad 1: Contactos Conocidos (Memoria + Peers)
                        prio_candidates = set()
                        for d in KNOWN_USERS.values(): prio_candidates.add(d['nick'])
                        for p in PEERS.values(): 
                            if isinstance(p, dict): prio_candidates.add(p.get('nick', '?'))
                        
                        options_prio = [n for n in prio_candidates if n.startswith(text)]
                        
                        # Prioridad 2: Resultados de Escaneo Reciente (DISC_TEMP)
                        # "si no encuentra nada similar... busca en listado de quienes interno"
                        sec_candidates = set()
                        global DISC_TEMP
                        for item in DISC_TEMP:
                            # item structure depends on scan func: (ip, nick, stat)
                            if len(item) >= 2: sec_candidates.add(item[1])
                            
                        options_sec = [n for n in sec_candidates if n.startswith(text) and n not in prio_candidates]
                        
                        # Combinar: Primero contactos, luego descubiertos
                        options = options_prio + options_sec
                
                if state < len(options):
                    return options[state]
                else:
                    return None

            readline.set_completer(completer)
            readline.parse_and_bind("tab: complete")
            # Configurar delimitadores: espacio, tab, salto linea y COMA (para invites multiples)
            # El guion (-) se quit贸 para permitir comandos con guiones
            readline.set_completer_delims(' \t\n,')
            
            safe_print(f"{Colors.G}[] Autocompletado activado (presiona TAB).{Colors.E}")
        except ImportError:
            safe_print(f"{Colors.W}[!] M贸dulo 'readline' no encontrado. Autocompletado no disponible.{Colors.E}")
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error al configurar autocompletado: {e}{Colors.E}")

# --- V40 LOGIC HELPERS ---

def get_my_mpp():
    """Genera mi [MPP] actualizado"""
    # IP, Nick, Status, Version
    return gw_comm.build_mpp(MY_IP, MY_NICK, MY_STATUS, APP_VERSION)

def handle_v2_logic(pkt_type, cmd_name, args, source_ip):
    """Central V2 Logic: Process Parsed Packet"""
    if source_ip == MY_IP: return # Prevent Self-Loop
    
    try:
        # Extract MPP if present (Most commands have it as Arg 0)
        sender_mpp = None
        if len(args) > 0:
            sender_mpp = gw_comm.extract_mpp(args[0])
            
        # Update Knowledge Base (Auto-Discovery)
        if sender_mpp:
            # save/update peer info
            if source_ip not in PEERS: PEERS[source_ip] = {}
            PEERS[source_ip]['nick'] = sender_mpp['nick']
            PEERS[source_ip]['ver']  = sender_mpp['ver']
            PEER_STATUSES[source_ip] = sender_mpp['status']
            # update_memory(...) # Optional persistence
            
        if pkt_type == 'CMD':
            debug_log(f"[V2] CMD: {cmd_name} Args: {len(args)}")
            
            if cmd_name == "SEARCH_GROUP":
                # Args: [MPP], GID, PASS
                if len(args) < 3: return
                gid, gpass = args[1], args[2]
                
                # Check if I have this group
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid and cdata['pass'] == gpass:
                        # Found! Send I_EXIST
                        # For now, Simple Response (No I_ANSWER delay)
                        # Build Local LS
                        # TODO: LS Builder from Peer list
                         
                        local_ls = [] # Placeholder
                        ls_pkt = gw_comm.build_ls(local_ls) # Placeholder
                        
                        gw_comm.send_cmd(source_ip, "I_EXIST", get_my_mpp(), gid, gpass, ls_pkt)
                        debug_log(f"[V2] Respondido I_EXIST a {source_ip} por grupo {gid}")
                        break

            elif cmd_name == "INVITE":
                # Args: [MPP], TYPE (PRIV/GROUP), [GID, PASS]
                if len(args) < 2: return
                itype = args[1]
                
                global PENDING_INVITE
                PENDING_INVITE = {
                    'ip': source_ip, 'nick': sender_mpp['nick'], 
                    'type': 'GROUP' if itype == 'GROUP' else 'PRIV',
                    'data': args[2:] if len(args)>2 else None
                }
                
                txt_type = "Privado" if itype == "PRIV" else f"Grupo {args[2] if len(args)>2 else '?'}"
                msg_text = f"{sender_mpp['nick']} te invita a un Chat {txt_type}"
                safe_print(f"{Colors.G}[!] {msg_text}. Responde en el popup o usa --aceptar.{Colors.E}")
                
                # Interactive Popup via gw_pop
                gw_pop.POP.show_question("Invitaci贸n Entrante", msg_text,
                                       lambda: LOBBY_ADAPTER.handle_accept(None) if LOBBY_ADAPTER else None,
                                       lambda: LOBBY_ADAPTER.handle_deny(None) if LOBBY_ADAPTER else None)
                
                sys.stdout.write('\a') # Beep

            elif cmd_name == "I_EXIST":
                # Args: [MPP], GID, PASS, [LS]
                if len(args) < 3: return
                gid = args[1]
                
                # Check if we are interested in this group
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                        # Found a peer for our group!
                        safe_print(f"{Colors.G}[*] Grupo {gid}: Encontrado peer {sender_mpp['nick']} ({source_ip}){Colors.E}")
                        break
            
            elif cmd_name == "GRP_MSG":
                # Args: [MPP], GID, TEXT
                if len(args) < 3: return
                gid, text = args[1], args[2]
                
                # Route to compatible chats
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                         # MSG_IN format for Child
                         tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                         ipc_payload = f"MSG_IN{gw_comm.SEP}{cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{text}"
                         if 'port' in cdata:
                             send_ipc(ipc_payload, cdata['port'])
                         
            elif cmd_name == "INVITE_ACC":
                # Args: [MPP]
                # Invitee accepted. Start chat without sending ACK back.
                safe_print(f"{Colors.G}[!] {sender_mpp['nick']} acept贸 tu invitaci贸n.{Colors.E}")
                start_private_chat(source_ip, sender_mpp['nick'], sender_mpp['status'], send_ack=False)

            elif cmd_name == "WHOIS":
                 # V2 Scan Request
                 if VISIBLE_IN_SCAN:
                     gw_comm.send_cmd(source_ip, "IAM_HERE", get_my_mpp())

            elif cmd_name == "IAM_HERE":
                 # Scan Response. MPP Parser already updated PEERS.
                 # Just notify User.
                 msg = f"{Colors.G}[+] Detectado: {sender_mpp['nick']} ({source_ip}){Colors.E}"
                 if SCANNING_NOW:
                      SCAN_BUFFER.append(msg)
                 else:
                      safe_print(msg)


        elif pkt_type == 'MSJ':
            # Args: MPP, TYPE, [PKG_ID, GID/DEST...], LEN, BODY
            # Last arg is BODY.
            msg_body = args[-1]
            msg_type = cmd_name # parse_packet returns Subtype as name for MSJ
            
            debug_log(f"[V2] MSJ {msg_type} de {sender_mpp['nick']}: {msg_body}")
            
            # Routing Logic
            target_cid = None
            
            if msg_type == 'PRIV':
                # Route by IP map
                # Find chat with remote_id == source_ip
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                         target_cid = cid; break
                         
            elif msg_type == 'GRUP':
                # Route by GID (Arg 3 usually: MPP|GRUP|PKID|GID)
                if len(args) >= 4:
                    gid = args[3]
                    for cid, cdata in ACTIVE_CHATS.items():
                         if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                              target_cid = cid; break
            
            if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                # Forward to Child
                # Format: FWD_MSG<SEP>CID<SEP>TAG<SEP>BODY
                tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                
                # V2 IPC uses same FWD_MSG or new?
                # Let's reuse FWD_MSG for compatibility with gw_child v39
                full_ipc = f"FWD_MSG{gw_comm.SEP}{target_cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{msg_body}"
                send_ipc(full_ipc, ACTIVE_CHATS[target_cid]['port'])
            else:
                 debug_log(f"[V2] Drop MSJ: No Chat Found for {source_ip}")

    except Exception as e:
        safe_print(f"Err V2 Logic: {e}")


def handle_v2_priv(conn, ip, raw):
    """TCP 44494: Privado y Control"""
    if LOG_ON: debug_log(f"[RX TCP PRIV] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

def handle_v2_disc(data, ip):
    """UDP 44495: Discovery"""
    if LOG_ON:
         try: dstr = data.decode('utf-8', errors='ignore').strip()
         except: dstr = f"<Bytes {len(data)}>"
         debug_log(f"[RX UDP DISC] {ip}: {dstr}")

    parsed = gw_comm.parse_packet(data)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)

def handle_v2_grp(conn, ip, raw):
    """TCP 44496: Group Mesh"""
    if LOG_ON: debug_log(f"[RX TCP GRP] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

# --- GLOBALS ---
LOBBY_ADAPTER = None



def run_lobby():
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE, LOBBY_ADAPTER
    # atexit.register(lambda: print(f"{Colors.W}Lobby cerrado.{Colors.E}")) # Reemplazado por shutdown manual
    
    # Self-Healing Checks
    enable_win_visuals()
    liberate_ports()
    
    # Capturar Ctrl+C en Lobby para shutdown limpio
    import signal
    signal.signal(signal.SIGINT, lambda s, f: shutdown_lobby())
    
    lazy_import() # Load heavy libraries only when needed (Lobby or Child)
    global hashlib
    import hashlib # v36.0 Integrity check
    
    adapter = LobbyAdapter()
    LOBBY_ADAPTER = adapter # Expose globally for callbacks
    os.system('cls' if os.name == 'nt' else 'clear'); fw_cfg(); MY_IP = get_ip()
    set_terminal_title(f"GWC Lobby - {MY_NICK}")
    
    # Kali/Network Check
    if MY_IP.startswith("127.") and platform.system() == "Linux":
         print(f"{Colors.W}[!] ADVERTENCIA: IP local ({MY_IP}) detectada.{Colors.E}")
         print(f"{Colors.W}[!] Si usas Kali Linux, verifica que no est茅s en 'Modo Monitor' (airmon-ng stop wlan0).{Colors.E}")
         print(f"{Colors.W}[!] La visibilidad en red estar谩 limitada.{Colors.E}")
         time.sleep(3)
    
    global LOBBY_HISTORY, PROMPT
    PROMPT = f"{Colors.B}Lobby > {Colors.E}"
    
    val_nick = MY_NICK if MY_NICK.strip() else socket.gethostname()
    
    if not load_config():
        while True:
            try: 
                if n := input("Tu Nickname: ").strip(): MY_NICK = n; break
            except: sys.exit()
        save_config()
    else:
        # Fallback if config loaded empty nick
        if not MY_NICK.strip(): MY_NICK = socket.gethostname()
    
    # Check Network Security on Startup
    global SILENT_UPDATES_ALLOWED
    SILENT_UPDATES_ALLOWED = check_network_trust()
    if SILENT_UPDATES_ALLOWED:
        pass # safe_print(f"{Colors.G}[Sec] Actualizaciones silenciosas ACTIVAS en esta red.{Colors.E}")
    else:
        pass # safe_print(f"{Colors.W}[Sec] Actualizaciones silenciosas DESACTIVADAS.{Colors.E}")

    refresh_ui() # Clean start with Dashboard
    
    # Aseguramos limpieza al inicio tambi茅n por si acaso
    restore_terminal()
    
    # Setup Autocomplete (v35.0)
    setup_autocomplete()

    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    # v37.23 Modular Logic - Start Listeners via gw_comm
    # v40.0 Protocol V2 Listeners
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_PRIV, handle_v2_priv)
    gw_comm.start_udp_listener(gw_comm.UDP_PORT_DISC, handle_v2_disc)
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_GRP,  handle_v2_grp)
    
    threading.Thread(target=check_child_health, daemon=True).start() # Health check
    
    check_repo_update()

    while True:
        try:
            inp = input(f"{Colors.B}Lobby > {Colors.E}").strip()
            if inp: LOBBY_HISTORY.append(f"{Colors.B}Lobby > {Colors.E}{inp}") # Guardar input usuario
            
            restore_from_afk()
            exec_lobby_cmd(inp)
        except KeyboardInterrupt: sys.exit()
        except Exception as e: safe_print(f"Err Lobby: {e}")



def main():
    # v37.18: Clear debug log on startup (Real location)
    try:
        if "--child" not in sys.argv: # Only lobby clears it
            dsk = get_desktop_path()
            path = os.path.join(dsk, "gwc_lobby_debug.log")
            if os.path.exists(path):
                with open(path, "w") as f: f.write(f"--- NUEVA EJECUCIN {time.ctime()} ---\n")
    except: pass

    # Parsing manual de args para no depender de argparse complejo
    if "--child" in sys.argv:
        try:
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            
            port = sys.argv[sys.argv.index("--port")+1]
            
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Check for silent updates flag passed from parent
            global SILENT_UPDATES_ALLOWED
            # if "--updates-ok" in sys.argv: SILENT_UPDATES_ALLOWED = True 
            # Deprecated flag logic

            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

if __name__ == "__main__": main()

if __name__ == "__main__": main()
