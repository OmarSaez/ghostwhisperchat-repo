#!/usr/bin/env python3
APP_VER_NUM = 37.26
APP_VER_TAG = "Fix Graceful Exit"
APP_VERSION = f"v{APP_VER_NUM} ({APP_VER_TAG})"

import socket, threading, subprocess, sys, os, time, platform, atexit, re, signal, ctypes, shutil
import json, difflib
import urllib.request # Lazy loaded usually, but kept for updater
import uuid
import unicodedata
try:
    import readline
except ImportError:
    pass # Readline not available (Windows or no Lib)

# v37.0: Modularizaci√≥n
# v37.10: Robust Import Logic (Auto-detect ../lib)
try:
    import gw_comm
except ImportError:
    # Logic for manual path resolution
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. Check system install
    if os.path.exists("/usr/lib/ghostwhisperchat"):
        sys.path.append("/usr/lib/ghostwhisperchat")
    
    # 2. Check repo structure (../lib/ghostwhisperchat relative to bin)
    # script_dir is ".../usr/bin"
    # we want ".../usr/lib/ghostwhisperchat"
    repo_lib = os.path.join(os.path.dirname(script_dir), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
        sys.path.append(repo_lib)

    # 3. Check CWD fallback (Dev root)
    if os.path.exists("ghostwhisperchat_pkg/usr/lib/ghostwhisperchat"):
        sys.path.append("ghostwhisperchat_pkg/usr/lib/ghostwhisperchat")
        
    try:
        import gw_comm
    except ImportError as e:
        print(f"CRITICAL ERROR: Could not import gw_comm module. Paths tried: {sys.path}")
        print(f"Error detail: {e}")
        # Log to file for child process visibility (Desktop)
        dsk = os.path.join(os.path.expanduser("~"), "Desktop")
        if not os.path.exists(dsk): dsk = os.path.join(os.path.expanduser("~"), "Escritorio")
        
        with open(os.path.join(dsk, "gwc_import_crash.log"), "a") as f:
            f.write(f"[{time.time()}] CRITICAL: gw_comm import failed. Env: {os.environ.get('PATH')}\n")
            f.write(f"Error: {e}\n")
        sys.exit(1)

from gw_comm import PKT_PREFIX, SEP, TAG_MARK, LEN_MARK, UDP_PORT
from gw_comm import build_packet, parse_packet

# --- CONFIGURACI√ìN ---
TCP_PORT = 44494
IPC_PORT = 5000 # Puerto base para IPC (Hijos) -> UDP
multicast_group = ('224.0.0.1', 44496) # Multicast opcional (futuro)
BUFFER, LOG_FILE, CONFIG_FILE = 4096, "cyberdei_history.log", "cyberdei_config.json"

# Detectar Escritorio
def get_desktop_path():
    if platform.system() == "Linux":
        try:
            return subprocess.check_output(["xdg-user-dir", "DESKTOP"]).decode().strip()
        except: pass
    elif platform.system() == "Windows":
        try:
            return os.path.join(os.environ['USERPROFILE'], 'Desktop')
        except: pass
    
    # Fallback
    home = os.path.expanduser("~")
    for d in ["Desktop", "Escritorio"]:
        p = os.path.join(home, d)
        if os.path.exists(p): return p
    return home

def find_free_port(start_port=5001, max_tries=50):
    for p in range(start_port, start_port + max_tries):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', p))
                return p
        except: continue
    return start_port # Fallback

DL_ROOT = get_desktop_path()
DL_DIR = os.path.join(DL_ROOT, "GhostWhisper_Recibidos")
if not os.path.exists(DL_DIR):
    try: os.makedirs(DL_DIR)
    except: pass
TIMERS = {'PRIV': 60, 'GROUP': 120, 'MANUAL': 300, 'INVITE': 15, 'BAN': 60}

# --- ESTADO PROCESOS ---
IS_CHILD = False
MY_CHILD_ID = None
PARENT_PID = None
CHILD_PROCESSES = {} # {ChatID: {'pid': PID, 'port': Port}} for Parent logic

# --- PILAS DE DATOS ---
PEERS = {}              # CONECTADOS: {IP: {'nick': Nick, 'chats': [ChatID1, ...]}}
PEER_STATUSES = {}      # ESTADOS CONECTADOS: {IP: Status}
KNOWN_USERS = {}        # HISTORIAL: {IP: {'nick': Nick, 'status': Status, 't': time}}
ACTIVE_CHATS = {}       # {ChatID: {'type': 'PRIV'/'GROUP', 'remote_id': ..., 'pass': ..., 'created_at': time}}
CURRENT_CHAT_ID = None

# GROUP_ID, GROUP_PASS = None, None # MOVIDO A ACTIVE_CHATS
MY_IP, MY_NICK, MY_STATUS = "", "An√≥nimo", "En l√≠nea"
DISC_TEMP, SCAN_RESULTS, PENDING_INVITE = [], [], None
POPUP_ON, USER_OFF, LAST_ACT = True, False, 0
HAS_ZENITY = False

def ensure_dependencies():
    """Instala zenity si falta en Linux (Debian/Kali/Ubuntu)"""
    if platform.system() == "Linux" and shutil.which("zenity") is None:
        try:
            print("\033[93m[!] Zenity no detectado. Instalando dependencias visuales...\033[0m")
            # Intentar apt-get silencioso
            subprocess.run(["sudo", "apt-get", "update", "-qq"], check=False)
            subprocess.run(["sudo", "apt-get", "install", "zenity", "-y", "-qq"], check=False)
        except: pass

ensure_dependencies()
HAS_ZENITY = shutil.which("zenity") is not None
AUTO_DL, LOG_ON, PENDING_FILES = True, False, []
VISIBLE_IN_SCAN = True 
IS_AFK = False 

class Colors:
    H, B, G, W, F, E, BO = '\033[95m', '\033[94m', '\033[92m', '\033[93m', '\033[91m', '\033[0m', '\033[1m'
    C, M, WH = '\033[96m', '\033[95m', '\033[97m'
    PALETTE = [B, C, M, W, WH]

PROMPT = f"\001{Colors.B}\002Lobby > \001{Colors.E}\002"
print_lock = threading.Lock()

# --- UTILS ---
def set_terminal_title(title):
    """Establece el t√≠tulo de la ventana de la terminal usando secuencias ANSI."""
    if platform.system() == "Windows":
        os.system(f"title {title}")
    else:
        # Secuencia est√°ndar XTerm (funciona en gnome, konsole, xfce, etc)
        sys.stdout.write(f"\x1b]2;{title}\x07")
        sys.stdout.flush()

def normalize_str(s):
    # Quita acentos y pasa a minusculas (ej: S√°ez -> saez)
    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn').lower()

def raw_print(s):
    # Imprime SIN guardar en historial
    # Si es hilo secundario (Async), restauramos el prompt visualmente.
    # Si es Main Thread (Sync), solo imprimimos (el input loop pondr√° el prompt).
    with print_lock:
        if threading.current_thread() is threading.main_thread():
             print(s)
        else:
             sys.stdout.write(f'\r\033[K{s}\n' + PROMPT + (readline.get_line_buffer() if 'readline' in sys.modules else ""))
             sys.stdout.flush()

def safe_print(s):
    # Imprime Y guarda en historial (Eventos publicos)
    LOBBY_HISTORY.append(s)
    raw_print(s)

def reply_print(msg, target_cid=None):
    """
    Imprime en el destino correcto:
    - Si target_cid es None -> Imprime en Lobby (safe_print).
    - Si target_cid existe -> Env√≠a IPC al hijo para que lo muestre.
    """
    if target_cid and target_cid in ACTIVE_CHATS:
        # Enviar al hijo
        cdata = ACTIVE_CHATS[target_cid]
        port = cdata.get('port')
        if port:
            # Usamos MSG_IN con 'Sistema' como remitente
            # Limpiamos colores para IPC? No, el hijo soporta colores.
            send_ipc(f"MSG_IN{SEP}Sistema{SEP}{msg}{SEP}{Colors.C}", port)
        else:
            safe_print(msg) # Fallback
    else:
        safe_print(msg)

def send_ipc(msg, port=IPC_PORT):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(msg.encode(), ('127.0.0.1', int(port)))
    except: pass

# --- DEFINICI√ìN DE COMANDOS Y ALIAS (v34.0) ---
# Estructura centralizada para facilitar mantenimiento y ayuda
COMMAND_DEFS = {
    'CHAT_GROUP': {
        'aliases': ['--chatgrupal', '--grupal', '--grupo', '--chatg', '--g', '-g', '--cg', '-cg', '--group', '--grp', '-grp'],
        'desc': 'Crear/Unirse a sala de Grupal (ID + Pass).'
    },
    'CHAT_PRIV': {
        'aliases': ['--chatpersonal', '--personal', '--chatp', '--p', '-p', '--cp', '-cp', '--dm', '-dm', '--private', '--priv', '-priv', '--msg', '-m'],
        'desc': 'Iniciar chat privado con IP o Nick.'
    },
    'LS': {
        'aliases': ['--ls', '-l', '--l', '--list', '--lista', '--members'],
        'desc': 'Listar chats activos (Lobby) o miembros (Chat).'
    },
    'SCAN': {
        'aliases': ['--quienes', '-q', '--q', '--who', '-w', '--scan'],
        'desc': 'Escanear red en busca de usuarios.'
    },
    'CONTACTS': {
        'aliases': ['--contactos', '--c', '-c', '--history', '--historial', '--k', '-k', '--contacts'],
        'desc': 'Ver historial de usuarios conocidos.'
    },
    'NICK': {
        'aliases': ['--nick', '--nombre', '--nickname', '--name', '-n', '--n'],
        'desc': 'Cambiar tu nombre de usuario visible.'
    },
    'STATUS': {
        'aliases': ['--estado', '--status', '--st', '-e', '--e', '-s', '--s'],
        'desc': 'Cambiar tu estado (ej: Ocupado).'
    },
    'INVITE': {
        'aliases': ['--invite', '--invitar', '--inv', '-i', '--i'],
        'desc': 'Invitar usuarios a la sala actual.'
    },
    'FILE': {
        'aliases': ['--archivo', '--arch', '--file', '-f', '--f', '-a', '--a', '--send', '--enviar'],
        'desc': 'Enviar archivo a la sala actual.'
    },
    'SCAN_VIS_ON': {
        'aliases': ['--quienes-si', '--visible', '-v', '--v', '--vis-on'],
        'desc': 'Hacerse visible en escaneos.'
    },
    'SCAN_VIS_OFF': {
        'aliases': ['--quienes-no', '--invisible', '--hidden', '-h', '--h', '--vis-off'],
        'desc': 'Ocultarse en escaneos.'
    },
    'LOG_ON': {
        'aliases': ['--log-on', '--logon', '--save-on', '-Lon'],
        'desc': 'Activar guardado de historial.'
    },
    'LOG_OFF': {
        'aliases': ['--log-off', '--logoff', '--save-off', '-Loff'],
        'desc': 'Desactivar guardado de historial.'
    },
    'POP_ON': {
        'aliases': ['--popsi', '--pop-on', '--unmute', '-um', '--noisy'],
        'desc': 'Activar notificaciones/popups.'
    },
    'POP_OFF': {
        'aliases': ['--popno', '--pop-off', '--mute', '-mu', '--silent'],
        'desc': 'Desactivar notificaciones/popups.'
    },
    'AUTOSTART_ON': {
        'aliases': ['--autolevantado-si', '--boot-on', '--startup-on'],
        'desc': 'Iniciar app al arrancar sistema (Linux).'
    },
    'AUTOSTART_OFF': {
        'aliases': ['--autolevantado-no', '--boot-off', '--startup-off'],
        'desc': 'No iniciar app al arrancar.'
    },
    'DL_ON': {
        'aliases': ['--descarga-si', '--dl-si', '--dl-on', '--auto-dl-on', '--descarga-automatica-si'],
        'desc': 'Aceptar descargas autom√°ticamente (Sin preguntar).'
    },
    'DL_OFF': {
        'aliases': ['--descarga-no', '--dl-no', '--dl-off', '--auto-dl-off', '--descarga-automatica-no'],
        'desc': 'Preguntar antes de descargar cada archivo.'
    },
    'ACCEPT': {
        'aliases': ['--aceptar', '--accept', '--ok', '-y', '--y', '--yes', '--acc'],
        'desc': 'Aceptar invitaci√≥n pendiente.'
    },
    'DENY': {
        'aliases': ['--rechazar', '--deny', '--no', '-no', '-d', '--d', '--cancel'],
        'desc': 'Rechazar invitaci√≥n pendiente.'
    },
    'EXIT': {
        'aliases': ['--salir', '--exit', '--quit', '-x', '--x', '--close'],
        'desc': 'Salir del chat o cerrar app.'
    },
    'CLEAR': {
        'aliases': ['--limpiar', '--limpieza', '--clear', '--cls', '-cls', '--clean'],
        'desc': 'Limpiar pantalla.'
    },
    'SHORTCUTS': {
        'aliases': ['--abreviaciones', '--shortcuts', '--alias', '-ab', '--ab', '--help-alias'],
        'desc': 'Ver lista de comandos y sus variantes.'
    },
    'HELP': {
        'aliases': ['--help', '--ayuda', '-?', '--?', '--comandos'],
        'desc': 'Ver ayuda general.'
    },
    'GLOBAL_STATUS': {
        'aliases': ['--estados-globales', '--global-status', '--gst', '-gst', '--status-full'],
        'desc': 'Ver resumen de toda la configuraci√≥n actual.'
    },
    'DEBUG': {
        'aliases': ['--debug', '--dbg', '-dbg'],
        'desc': 'Activar/Desactivar logs de depuraci√≥n.'
    }
}

# Mapa plano para b√∫squeda r√°pida O(1)
CMD_MAP = {}
for k, v in COMMAND_DEFS.items():
    for alias in v['aliases']:
        CMD_MAP[alias] = k

def resolve_cmd(inp_cmd):
    """Devuelve la KEY can√≥nica del comando o None"""
    return CMD_MAP.get(inp_cmd)

def write_log(txt, type="MSG"):
    if LOG_ON:
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                f.write(f"[{datetime.datetime.now().strftime('%F %T')}] [{type}] {txt}\n")
        except: pass

KNOWN_USERS = {} # {ip: {nick, status, t}}
LOBBY_HISTORY = [] # Buffer para repintar la UI
DISC_TEMP = [] # Buffer para descubrimiento (Scan)
DEBUG_MODE = False # v36.8

# --- UTILS VISUALES ---
def safe_print(msg):
    """Thread-safe print"""
    try:
        sys.stdout.write(msg + '\n')
    except: pass

def debug_log(msg):
    if DEBUG_MODE:
        s = f"{Colors.M}[DEBUG] {msg}{Colors.E}"
        safe_print(s)
        # v37.13: Persist debug to file
        try:
             dsk = get_desktop_path()
             path = os.path.join(dsk, "gwc_lobby_debug.log")
             with open(path, "a", encoding="utf-8") as f:
                 f.write(f"[{time.time()}] {msg}\n")
        except Exception as e:
             safe_print(f"{Colors.F}[!] Error escribiendo log en disco: {e}{Colors.E}")

# --- PROTOCOLO (Delegado a gw_comm) ---
# --- PROTOCOLO (Delegado a gw_comm) ---
# Funciones redirigidas totalmente al m√≥dulo
def send_cmd(ip, cmd, *args):
    gw_comm.send_cmd(ip, cmd, *args)

def send_cmd_all(cmd, *args):
    gw_comm.send_cmd_all(cmd, *args)

def send_raw(ip, d):
    gw_comm.send_tcp_packet(ip, d)

def get_col(n): return Colors.PALETTE[sum(ord(c) for c in n) % len(Colors.PALETTE)] if n else Colors.WH

def popup(t, x, source_ip=None):
    if not POPUP_ON: return
    
    # --- ANTI-SPAM SMART v33.5 ---
    if source_ip:
        now = time.time()
        
        # 1. Check if Banned
        if source_ip in BANNED_IPS:
            if now < BANNED_IPS[source_ip]:
                return # BANNED -> No Popup (Console already printed)
            else:
                del BANNED_IPS[source_ip] # Ban expired
        
        # 2. Update History
        if source_ip not in IP_MSG_HISTORY: IP_MSG_HISTORY[source_ip] = []
        IP_MSG_HISTORY[source_ip].append(now)
        
        # Keep only recent messages (last 3 seconds window is enough for the check)
        IP_MSG_HISTORY[source_ip] = [ts for ts in IP_MSG_HISTORY[source_ip] if now - ts < 3.0]
        
        # 3. Check Burst: 3 messages in less than 2 seconds (User Request)
        # We need at least 3 messages
        if len(IP_MSG_HISTORY[source_ip]) >= 3:
            # Check the span between the last message and the 3rd-to-last
            # [..., t-2, t-1, t0]
            t_last = IP_MSG_HISTORY[source_ip][-1]
            t_start = IP_MSG_HISTORY[source_ip][-3]
            
            if (t_last - t_start) < 2.0:
                 BANNED_IPS[source_ip] = now + TIMERS['BAN'] # Ban configured time
                 safe_print(f"{Colors.F}[Anti-Spam] üõ°Ô∏è IP {source_ip} bloqueada de Popups por {TIMERS['BAN']}s (Burst detectado).{Colors.E}")
                 return # Block this one too
    
    # -----------------------------
    
    if platform.system() == "Linux":
        if HAS_ZENITY: 
            subprocess.Popen(["zenity", "--info", "--title", t, "--text", x, "--width=350"], stderr=subprocess.DEVNULL)
            
    elif platform.system() == "Windows":
        # PowerShell Balloon Tip nativo
        # Escapar comillas simples para que no rompa el string de PS
        t_safe = t.replace("'", "''")
        x_safe = x.replace("'", "''")
        
        ps_script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        Add-Type -AssemblyName System.Drawing
        
        $notify = New-Object System.Windows.Forms.NotifyIcon
        $path = (Get-Process -id $pid).Path
        $notify.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($path)
        $notify.Visible = $True
        $notify.ShowBalloonTip(0, '{t_safe}', '{x_safe}', [System.Windows.Forms.ToolTipIcon]::Info)
        
        # Necesario para que se procese el evento visual
        # Mantiene el script vivo unos segundos
        for ($i=0; $i -lt 40; $i++) {{
             [System.Windows.Forms.Application]::DoEvents()
             Start-Sleep -Milliseconds 100
        }}
        $notify.Dispose()
        """
        # Ejecutar oculto
        try:
            # Quitamos creationflags para debug si es necesario, pero mantenemos hidden
            subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", ps_script], creationflags=subprocess.CREATE_NO_WINDOW)
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error lanzando popup: {e}{Colors.E}")
            subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", ps_script])

# --- CONFIG & STATE ---
CONFIG_FILE = "inter_chat.json"
KNOWN_USERS = {} # {ip: {nick, status, t}}
TRUSTED_PEERS = set() # IPs de gente con chat privado exitoso {ip}
TRUSTED_NETS = {} # {network_id: {'trusted': bool, 'last_seen': ts, 'name': str}}
MY_NICK = socket.gethostname()
# ... rest of vars ...
ACTIVE_CHATS = {} # cid -> {type, remote_id, pass, process_handle, port}
PEERS = {} # ip -> {nick, chats: {cid1, cid2}}
PEER_STATUSES = {} # ip -> status_str
SILENT_UPDATES_ALLOWED = False # Global state

# --- ANTI-SPAM STATE ---
BANNED_IPS = {} # { ip: timestamp_expiry }
IP_MSG_HISTORY = {} # { ip: [timestamp1, timestamp2, ...] }

def load_config():
    global KNOWN_USERS, MY_NICK, MY_STATUS, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, TRUSTED_NETS, TRUSTED_PEERS
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                d = json.load(f)
                KNOWN_USERS = d.get('known_users', {})
                MY_NICK = d.get('nick', MY_NICK)
                MY_STATUS = d.get('status', "En l√≠nea")
                VISIBLE_IN_SCAN = d.get('visible', True)
                LOG_ON = d.get('log_on', True)
                AUTO_DL = d.get('auto_dl', True)
                TRUSTED_NETS = d.get('trusted_nets', {})
                TRUSTED_PEERS = set(d.get('trusted_peers', []))
                return True
        except: pass
    return False

def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump({
                'known_users': KNOWN_USERS,
                'nick': MY_NICK,
                'status': MY_STATUS,
                'visible': VISIBLE_IN_SCAN,
                'log_on': LOG_ON,
                'auto_dl': AUTO_DL,
                'trusted_nets': TRUSTED_NETS,
                'trusted_peers': list(TRUSTED_PEERS)
            }, f, indent=4)
    except: pass

# --- NETWORK IDENTIFICATION ---
def get_network_id():
    """Identifica la red actual (Gateway + SSID/Name)"""
    gw = "UNK_GW"
    ssid = "LAN"
    
    try:
        if platform.system() == "Linux":
            # Gateway
            r = subprocess.check_output("ip route | grep default", shell=True).decode()
            gw = r.split()[2] if len(r.split()) > 2 else "UNK"
            # SSID/Interface
            try:
                w = subprocess.check_output("iwgetid -r", shell=True).decode().strip()
                if w: ssid = w
            except: pass
            
        elif platform.system() == "Windows":
             # 1. Gateway via Powershell (NextHop)
             try:
                 cmd_gw = "Get-NetRoute -DestinationPrefix 0.0.0.0/0 | Select-Object -ExpandProperty NextHop"
                 r = subprocess.check_output(["powershell", "-Command", cmd_gw], creationflags=0x08000000).decode().strip()
                 if r: gw = r
             except: 
                 # Fallback ipconfig parse
                 try:
                     r = subprocess.check_output("ipconfig", creationflags=0x08000000).decode()
                     # Buscar "Default Gateway . . . : 192..."
                     m = re.search(r"Default Gateway.*: ([\d\.]+)", r)
                     if m: gw = m.group(1)
                 except: pass

             # 2. SSID via netsh
             try:
                 r = subprocess.check_output("netsh wlan show interfaces", creationflags=0x08000000).decode()
                 m = re.search(r"^\s+SSID\s+:\s+(.+)$", r, re.MULTILINE)
                 if m: ssid = m.group(1).strip()
             except: pass
    except: pass
    
    return f"{gw}_{ssid}"

def check_network_trust():
    """Verifica si la red actual es confiable para updates"""
    net_id = get_network_id()
    now = time.time()
    
    data = TRUSTED_NETS.get(net_id)
    ask = False
    
    if not data:
        # Nueva red
        ask = True
        msg = f"Se ha detectado una nueva red:\n{net_id}\n\n¬øDesea activar actualizaciones silenciosas en esta red?"
    else:
        # Red conocida, verificar timestamp (3 weeks = 1814400s)
        if (now - data['last_seen']) > 1814400:
            ask = True
            msg = f"No te conectas a esta red ({net_id}) en m√°s de 3 semanas.\n\n¬øMantener actualizaciones silenciosas?"
        else:
            # Update timestamp and proceed
            TRUSTED_NETS[net_id]['last_seen'] = now
            save_config()
            return data['trusted']

    if ask:
        # Popup de pregunta IMPORTANTE
        is_windows = platform.system() == "Windows"
        res = False
        
        # Reutilizamos logica de popup pero bloqueante y con Yes/No pregunta
        # Hack simple usando zenity/powershell directo aqui para bloquear
        try:
            if platform.system() == "Linux" and shutil.which("zenity"):
                ret = os.system(f"zenity --question --title='IMPORTANTE: Seguridad' --text='{msg}'")
                res = (ret == 0)
            elif is_windows:
               # Powershell simple
               script = f"$r=[System.Windows.Forms.MessageBox]::Show('{msg}','Seguridad','YesNo','Question');if($r-eq'Yes'){{exit 0}}else{{exit 1}}"
               ret = subprocess.call(["powershell", "-Command", f"Add-Type -A System.Windows.Forms; {script}"])
               res = (ret == 0)
        except: pass
        
        TRUSTED_NETS[net_id] = {'trusted': res, 'last_seen': now, 'name': net_id}
        save_config()
        return res
    
    return False # Should not reach

def show_help(target_cid=None):
    lines = []
    lines.append(f" {Colors.BO}--- AYUDA Y COMANDOS ---{Colors.E}")
    
    cats = {
        "GESTI√ìN DE CHATS": [
            ("--chatpersonal (Nick y/o IP)", "Crear un chat privado con un usuario."),
            ("--chatgrupal ID CLAVE", "Unirse/Crear sala."), 
            ("--invite (Nick1, Nick2...) y/o IPs", "Invitar gente al grupo actual."),
            ("--aceptar / --rechazar", "Responder a invitaciones pendientes."),
            ("--ls", "Listar usuarios CONECTADOS en el chat."), 
            ("--salir", "Desconectar de la sesi√≥n.")
        ],
        "RED Y CONTACTOS": [
            ("--quienes", "Escanear red (¬øQui√©n est√° online?)."),
            ("--contactos", "Ver historial de gente vista."),
            ("--quienes-si / --quienes-no", "Visibilidad en esc√°ner.")
        ],
        "UTILIDADES Y ARCHIVOS": [
            ("--archivo (Archivo.ext y/o Ruta)", "Enviar archivo."),
            ("--nombre (NuevoNick)", "Cambiar tu nombre visible."),
            ("--estado (Texto)", "Cambiar estado."),
            ("--descarga-si / --descarga-no", "Control descarga autom√°tica."),
            ("--estados-globales", "Ver resumen de configuraci√≥n."),
            ("--abreviaciones", "Ver todos los formatos aceptados por cada comando."),
            ("--limpiar", "Limpiar pantalla.")
        ],
        "SISTEMA Y CONFIGURACI√ìN": [
             ("--log on / off", "Guardar historial."), 
             ("--popno / --popsi", "Control Notificaciones."), 
             ("--autolevantado-si/no", "Iniciar app al encender PC (Linux).")
        ]
    }

    for cat_name, cmds in cats.items():
        lines.append(f"\n {Colors.C}:: {cat_name} ::{Colors.E}")
        for c, d in cmds: 
            lines.append(f"   {Colors.BO}{c:<35}{Colors.E} : {d}")

    lines.append("-" * 60)
    
    full_msg = "\n".join(lines)
    if target_cid: reply_print(full_msg, target_cid)
    else: safe_print(full_msg)

def get_peer_name(ip):
    p = PEERS.get(ip)
    if p and isinstance(p, dict):
        return p.get('nick', ip)
    return ip

    """Imprime y guarda en historial para repintado"""
    safe_print(txt)
    # LOBBY_HISTORY append is handled by safe_print now
    if len(LOBBY_HISTORY) > 200: LOBBY_HISTORY.pop(0) # v37.13 Increased limit

def refresh_ui(msg=None):
    os.system('cls' if os.name == 'nt' else 'clear')

    # Dashboard Format
    vis_txt = f"{Colors.G}SI{Colors.E}" if VISIBLE_IN_SCAN else f"{Colors.F}NO{Colors.E}"

    raw_print(f"{Colors.H}Version: {APP_VERSION}{Colors.E}")
    raw_print(f"Mi IP: {Colors.BO}{MY_IP}{Colors.E} | Nick: {Colors.BO}{MY_NICK}{Colors.E} | Visible en red: {vis_txt} | Estado: {Colors.C}{MY_STATUS}{Colors.E}")
    raw_print(f"Total de chats: {Colors.M}{len(ACTIVE_CHATS)}{Colors.E}")
    raw_print(f"Total de contactos: {Colors.M}{len(KNOWN_USERS)}{Colors.E}")
    raw_print(f"Puedes poner --help para ver los comandos")
    raw_print(f"{Colors.G}Bienvenido al lobby{Colors.E}")
    raw_print("-" * 60)

    # Repintar Historial sin duplicarlo
    for line in LOBBY_HISTORY:
        raw_print(line)

    if msg: 
        safe_print(msg) # Este es nuevo, s√≠ guardar
    
    # Force Prompt restore only if Async (refresh inside refresh?)
    # Actually raw_print handles the logic per line, but for refresh we want clean output.
    # But for now let's trust it.
    
    # If we are async, raw_print appended prompt on the last line.
    # If we are sync, nobody printed prompt. Correct.

# --- RED ---
def lazy_import():
    global json, difflib, urllib, unicodedata, request, datetime, uuid
    import json, difflib, datetime, uuid, unicodedata
    import urllib.request as request
    
def get_ip():
    # Optimization: Use a dummy socket to get preferred outgoing IP without actual connection
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            # Google DNS IP (doesn't need to be reachable)
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except:
        return "127.0.0.1"

def fw_cfg():
    if platform.system() == "Linux":
        # 1. Intentar UFW (Ubuntu/Debian standard)
        try:
            for c in [[f"{p}/tcp", f"{p}/udp"] for p in [TCP_PORT, UDP_PORT]]:
                subprocess.run(["sudo", "ufw", "allow"] + c, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
        # 2. Intentar IPTABLES (Kali/RedHat/Arch fallback)
        # sudo iptables -C INPUT -p tcp --dport 44494 -j ACCEPT 2> /dev/null || sudo iptables -A INPUT -p tcp --dport 44494 -j ACCEPT
        try:
            for p, proto in [(TCP_PORT, 'tcp'), (UDP_PORT, 'udp')]:
                rule = ["sudo", "iptables", "-A", "INPUT", "-p", proto, "--dport", str(p), "-j", "ACCEPT"]
                # Check simple para no duplicar (es complejo en python puro, lanzamos el add y que iptables decida si duplica o no)
                # Mejor intentar solo si no existe, pero para simplificar lanzamos append.
                # Si el user no tiene sudo sin pass, fallara silencioso.
                subprocess.run(rule, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
    elif platform.system() == "Windows":
        subprocess.run(["powershell", f"Start-Process cmd -Verb RunAs -ArgumentList '/c netsh advfirewall firewall add rule name=\"CyberDEI\" dir=in action=allow protocol=ANY localport=\"{TCP_PORT},{UDP_PORT}\"'"], shell=True)

# send_raw eliminado (Replaced by alias above)
def send_all(d, targets=None):
    if targets is None:
        # Enviar solo a usuarios del chat actual
        targets = []
        if CURRENT_CHAT_ID:
            for ip, pdata in PEERS.items():
                if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                    targets.append(ip)

    for ip in [i for i in targets if i != MY_IP]: send_raw(ip, d)

# --- DISCOVERY & MEMORY ---
def update_memory(ip, nick, status):
    """Actualiza memoria y guarda en config"""
    global KNOWN_USERS
    now = time.time()
    
    # Detectar cambio de nombre
    old_nick = None
    if ip in KNOWN_USERS:
        old_nick = KNOWN_USERS[ip].get('nick', nick)
    
    KNOWN_USERS[ip] = {'nick': nick, 'status': status, 't': now}
    
    if old_nick and old_nick != nick:
        safe_print(f"{Colors.C}[Info] '{old_nick}' ahora se llama '{nick}'{Colors.E}")
        # Notificar a los hijos (para que en el chat se vea el cambio)
        # Iterar chats activos y enviar mensaje de sistema
        for cid, cdata in ACTIVE_CHATS.items():
            # Si es privado y es con esa IP:
            if cdata['type'] == 'PRIV' and cdata.get('remote_id') == ip:
                 cdata['remote_nick'] = nick # Actualizar metadata interna
                 # Send alert to child
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}El usuario cambio su nombre a {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))
            
            # Si es grupo, avisar tambien (mas complejo filtrar si esta en el grupo, pero avisamos igual si es relevante)
            if cdata['type'] == 'GROUP':
                 # Verificar si IP esta en grupo? Simplificamos: enviamos a todos los grupos activos
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}{old_nick} ahora es {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))

    if ip in PEERS:
        if isinstance(PEERS[ip], dict):
             PEERS[ip]['nick'] = nick
    save_config()

def handle_incoming_udp(d, ip):
    global PEERS, DISC_TEMP, PEER_STATUSES, SCAN_RESULTS
    
    msg = d.decode('utf-8', errors='ignore')
    debug_log(f"[UDP] Recibido de {ip}: {msg[:100]}") # Show first 100 chars
    
    if ip == MY_IP: return

    is_cmd, cmd, args = parse_packet(msg)

    if not is_cmd: return # Ignorar mensajes no estructurados en UDP

    if cmd == "SEARCH_GROUP":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                    send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

                gw_comm.send_udp_cmd(ip, "I_EXIST", gid, gpass, MY_NICK, MY_STATUS)

    elif cmd == "I_EXIST":
        # args: GID, GPASS, NICK, STATUS
        if len(args) >= 4:
            gid, gpass, nick, st = args[0], args[1], args[2], args[3]
            found_chat_id = None
            for cid, cdata in ACTIVE_CHATS.items():
                if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                    found_chat_id = cid
                    break

            if found_chat_id:
                if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                PEERS[ip]['nick'] = nick
                PEERS[ip]['chats'].add(found_chat_id)

                PEER_STATUSES[ip] = st
                update_memory(ip, nick, st)

                if 'port' in ACTIVE_CHATS[found_chat_id]:
                        send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

    elif cmd == "WHOIS":
        # args[0] = target_nick (puede ser vac√≠o)
        target = args[0].strip().lower() if args else ""

        # Soy yo?
        if not target or target == MY_NICK.lower():
            gw_comm.send_udp_cmd(ip, "USER_HERE", MY_NICK, MY_STATUS)

    elif cmd == "USER_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            # Check duplicate in DISC_TEMP
            if not any(x[0] == ip for x in DISC_TEMP):
                DISC_TEMP.append((ip, nick, st))
            update_memory(ip, nick, st)

    elif cmd == "WHO_ALL" and VISIBLE_IN_SCAN:
        gw_comm.send_udp_cmd(ip, "IAM_HERE", MY_NICK, MY_STATUS)

    elif cmd == "IAM_HERE":
        # args: Nick, Status
        if len(args) >= 2:
            nick, st = args[0], args[1]
            SCAN_RESULTS.append({'ip': ip, 'nick': nick, 'status': st})
            update_memory(ip, nick, st)

def find_global(t):
    target_clean = normalize_str(t)
    
    # 1. Check known
    for ip, d in KNOWN_USERS.items():
        if normalize_str(d['nick']) == target_clean or ip == t: return ip
        
    for ip, p in PEERS.items():
         if isinstance(p, dict) and normalize_str(p.get('nick', '')) == target_clean: return ip
         
    # 2. Discovery UDP
    safe_print(f"{Colors.W}[*] Buscando '{t}'...{Colors.E}")
    global DISC_TEMP
    DISC_TEMP = [] 
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHOIS", t), ('255.255.255.255', UDP_PORT)); u.close()
    
    time.sleep(2)
    
    for res in DISC_TEMP:
        # res = (ip, nick, status)
        # Check MATCH EXACTO (Insensitive)
        if normalize_str(res[1]) == target_clean:
            safe_print(f"{Colors.G}[+] Encontrado: {res[1]} en {res[0]}{Colors.E}")
            return res[0]
            
    safe_print(f"{Colors.F}[X] Usuario '{t}' no encontrado.{Colors.E}")
    
    # --- FUZZY SEARCH / SUGERENCIAS ---
    suggs = set() # (nick, ip)

    # Helper local
    def check_sim(n, ip):
        n_clean = normalize_str(n)
        if target_clean in n_clean: return True # Contenido exacto
        # Similitud > 55%
        if difflib.SequenceMatcher(None, target_clean, n_clean).ratio() > 0.55: return True
        return False

    # 1. Buscar en Resultados UDP
    for res in DISC_TEMP:
        if check_sim(res[1], res[0]): suggs.add((res[1], res[0]))

    # 2. Buscar en Historial Conocidos
    for ip, data in KNOWN_USERS.items():
        if check_sim(data['nick'], ip): suggs.add((data['nick'], ip))

    if suggs:
        safe_print(f"{Colors.W}¬øQuiz√°s quisiste decir?:{Colors.E}")
        for snick, sip in suggs:
            safe_print(f"   > {Colors.BO}{snick}{Colors.E} ({sip})")

    return None

def scan_network(target_cid=None):
    global SCAN_RESULTS
    reply_print(f"{Colors.W}[*] Escaneando red local (1s)...{Colors.E}", target_cid)
    SCAN_RESULTS = []; u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHO_ALL"), ('255.255.255.255', UDP_PORT)); u.close(); time.sleep(1) # Optimizacion 2s -> 1s

    reply_print(f"{Colors.G}[*] Equipos Encontrados ({len(SCAN_RESULTS)}):{Colors.E}", target_cid)
    for res in SCAN_RESULTS:
        reply_print(f"   > {Colors.BO}{res['nick']}{Colors.E} ({res['ip']}) [{res['status']}]", target_cid)
    if not SCAN_RESULTS: reply_print("   (Ninguno visible)", target_cid)

def leave_sess(silent=False, exclude_ip=None, target_cid=None):
    global PEERS, PEER_STATUSES, CURRENT_CHAT_ID
    
    # Si no se especifica CID, usar el global (contexto Lobby)
    cid_to_close = target_cid if target_cid else CURRENT_CHAT_ID
    
    if not cid_to_close or cid_to_close not in ACTIVE_CHATS:
        if not silent: safe_print(f"{Colors.W}[!] Sesi√≥n no v√°lida.{Colors.E}")
        return

    if not silent: safe_print(f"{Colors.W}[*] Cerrando sesi√≥n {cid_to_close}...{Colors.E}")

    # Send disconnect to peers in THIS chat
    c = ACTIVE_CHATS[cid_to_close]
    to_remove = []

    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and cid_to_close in pdata.get('chats', []):
            if ip != exclude_ip:
                if c['type'] == 'GROUP':
                    send_cmd(ip, "LEAVE_GRP", c['remote_id'], MY_NICK)
                else: # PRIV
                    send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
            # Remove chat_id linkage
            pdata['chats'].discard(cid_to_close) # Use discard to be safe
            if not pdata['chats']: # Empty, user gone
                to_remove.append(ip)

    for ip in to_remove:
        if ip in PEERS: del PEERS[ip]
        if ip in PEER_STATUSES: del PEER_STATUSES[ip]

    # Matar proceso hijo si existe y no soy yo mismo el hijo suicid√°ndose
    if 'port' in ACTIVE_CHATS[cid_to_close]:
         # Enviamos kill por si acaso, aunque el hijo ya se haya ido
         send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid_to_close]['port'])

    del ACTIVE_CHATS[cid_to_close]
    
    # Si cerr√© la sesi√≥n activa del Lobby, limpiar variable
    if CURRENT_CHAT_ID == cid_to_close:
        CURRENT_CHAT_ID = None
        
    if not silent: safe_print(f"{Colors.G}[‚úî] Sesi√≥n {cid_to_close} cerrada.{Colors.E}")

def start_private_chat(ip, nick, status="En l√≠nea"):
    global CURRENT_CHAT_ID
    cid = str(uuid.uuid4())[:8]
    ACTIVE_CHATS[cid] = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': nick}
    CURRENT_CHAT_ID = cid

    if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
    if isinstance(PEERS[ip], dict):
        PEERS[ip]['nick'] = nick
        PEERS[ip]['chats'].add(cid)

    PEER_STATUSES[ip] = status
    update_memory(ip, nick, status)
    
    # v36.12 CRITICAL FIX: Send acceptance to inviter so they open their window!
    debug_log(f"[PROTOCOLO] Enviando INVITE_ACC (Confirmaci√≥n) a {ip}...")
    send_cmd(ip, "INVITE_ACC", MY_NICK, MY_STATUS)
    debug_log(f"[PROTOCOLO] INVITE_ACC enviado. Ahora abriendo mi consola...")
    
    spawn_child_process(cid, ACTIVE_CHATS[cid]) # Spawn child immediately
    refresh_ui(f"{Colors.G}[*] Chat privado con {nick} iniciado.{Colors.E}")
    return cid

def join_grp(gid, gp, exclude_ip=None):
    # Ya no salimos de la sesi√≥n anterior forzosamente
    # if PEERS: leave_sess(...) <--- REMOVED

    global CURRENT_CHAT_ID
    global PEERS, PEER_STATUSES

    if not CURRENT_CHAT_ID: return # Should not happen in child context

    safe_print(f"{Colors.G}[*] Conectando a '{gid}'...{Colors.E}")

    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("SEARCH_GROUP", gid, gp, MY_NICK, MY_STATUS), ('255.255.255.255', UDP_PORT)); u.close()

    time.sleep(2)
    # Check if peers found in this chat
    found_any = False
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
            found_any = True
            break

    if found_any:
        safe_print(f"{Colors.G}[‚úî] Unido.{Colors.E}")
        send_cmd_all("JOINED", MY_NICK, MY_STATUS); write_log(f"Grupo {gid}", "SYS")
    else:
        safe_print(f"{Colors.G}[‚úî] Sala creada (esperando peers).{Colors.E}"); write_log(f"Sala {gid}", "SYS")

    # Trigger Update Check on trusted peers in this group
    # Necesitamos la lista de IPs. Si es un join reciente, PEERS se va poblando.
    # Mejor hacerlo tras unos segundos o usar los que ya conocemos que est√°n ah√≠.
    # Disparamos un hilo retardado
    # threading.Thread(target=lambda: (time.sleep(5), try_trigger_updates(list(PEERS.keys())))).start()
    pass

def invite_users(targets_str):
    if not CURRENT_CHAT_ID or CURRENT_CHAT_ID not in ACTIVE_CHATS:
        return safe_print(f"{Colors.F}[!] Debes estar en un chat activo.{Colors.E}")

    chat = ACTIVE_CHATS[CURRENT_CHAT_ID]
    if chat['type'] != 'GROUP':
        return safe_print(f"{Colors.F}[!] Solo puedes invitar en grupos.{Colors.E}")

    gid = chat['remote_id']
    gpass = chat['pass']

    targets = [t.strip() for t in targets_str.split(',')]

    members_list = ", ".join([d['nick'] for d in PEERS.values() if isinstance(d, dict) and CURRENT_CHAT_ID in d.get('chats', [])])
    # payload = f"GRP_INVITE_REQ{SEP}{MY_NICK}{SEP}{gid}{SEP}{gpass}{SEP}{members_list}".encode() # Old

    safe_print(f"{Colors.W}[*] Enviando invitaciones...{Colors.E}")
    count = 0
    for t in targets:
        ip = find_global(t)
        if ip:
            pdata = PEERS.get(ip)
            if pdata and isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                 safe_print(f"   > {t}: Ya est√° en el grupo.")
            else:
                send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, members_list)
                safe_print(f"   > {t}: Invitaci√≥n enviada.")
                count += 1

    if count > 0:
        send_cmd_all("GRP_MSG", gid, f"[Grupo] {MY_NICK} ha invitado a {count} usuarios.")

# --- CORE ---
def set_afk_mode(cause_ip=None, cause_nick=None):
    global MY_STATUS, IS_AFK
    IS_AFK = True
    if not MY_STATUS.endswith("-AFK"): MY_STATUS += "-AFK"
    msg = f"{Colors.W}[!] Solicitud de {Colors.BO}{cause_nick}{Colors.E} {Colors.W}({cause_ip}) auto-rechazada. Entrando en AFK.{Colors.E}" if cause_nick else f"{Colors.W}[!] Timeout. Entrando en AFK.{Colors.E}"
    safe_print(msg); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def restore_from_afk():
    global MY_STATUS, IS_AFK
    if not IS_AFK: return
    IS_AFK = False
    if MY_STATUS == "Ausente (AFK)": MY_STATUS = "En l√≠nea"
    elif MY_STATUS.endswith("-AFK"): MY_STATUS = MY_STATUS[:-4]
    safe_print(f"{Colors.G}[i] Bienvenido de vuelta. Estado: {MY_STATUS}{Colors.E}"); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def handle_invite_logic(ip, nick, type, extra_data=None):
    global PENDING_INVITE, PEER_STATUSES
    inviter_status = PEER_STATUSES.get(ip, "")

    req_text = ""
    if type == "PRIV": 
        req_text = f"üí¨ ¬°Hey! {nick} ({ip}) quiere iniciar una conversaci√≥n contigo.\n\n¬øTe gustar√≠a aceptar la conexi√≥n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat PRIV de {nick} ({ip})")
    else: 
        gid, gpass, members = extra_data
        req_text = f"üì¢ {nick} quiere que formes parte del grupo \"{gid}\".\n\n¬øTe unes a la conversaci√≥n?"
        debug_log(f"[INVITE_LOGIC] Solicitando al usuario aceptar chat GROUP {gid} de {nick}")

    # --- GUI HANDLING (v26.1 Style: Popen + Polling) ---
    proc = None
    if platform.system() == "Linux" and HAS_ZENITY:
        try:
            proc = subprocess.Popen(["zenity", "--question", "--title=Invitaci√≥n CyberDEI", f"--text={req_text}", "--timeout=30"], stderr=subprocess.DEVNULL)
        except: pass

    elif platform.system() == "Windows":
        # Windows Popen non-blocking
        # Strip emojis for Windows compatibility (PowerShell encoding issues)
        txt_win = req_text.encode('ascii', 'ignore').decode() 
        t_safe = txt_win.replace("\n", "`n").replace("'", "''")
        
        script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        $res = [System.Windows.Forms.MessageBox]::Show('{t_safe}', 'Invitaci√≥n', 'YesNo', 'Question')
        if ($res -eq 'Yes') {{ exit 0 }} else {{ exit 1 }}
        """
        try:
             proc = subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", script], stderr=subprocess.DEVNULL)
        except: pass

    # Wait for GUI response if launched
    if proc:
        start_t = time.time()
        answered = False
        while time.time() - start_t < 30: # 30s timeout
            if proc.poll() is not None:
                answered = True
                debug_log(f"[INVITE_LOGIC] GUI process finished (Return Code: {proc.returncode})")
                break
            time.sleep(0.5) # Evitar consumo CPU 100%

        if answered:
            if proc.returncode == 0: # YES
                # Construir dict temporal y llamar yes
                safe_print(f"{Colors.M}[GUI] Aceptando invitaci√≥n...{Colors.E}")
                debug_log(f"[INVITE_LOGIC] Usuario acept√≥ en GUI. Ejecutando --y")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--y")
            else:
                debug_log(f"[INVITE_LOGIC] Usuario rechaz√≥ en GUI. Ejecutando --n")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--n") # NO
            return
        else:
            # Timeout GUI -> AFK PROTOCOL
            try: proc.terminate()
            except: pass
            
            safe_print(f"{Colors.W}[!] Sin respuesta. Entrando en modo AFK.{Colors.E}")
            set_afk_mode(cause_ip=ip, cause_nick=nick)
            send_cmd(ip, "INVITE_REJ", MY_NICK, "Auto-AFK")
            return # Evitar fallback a CLI si ya fall√≥ GUI

    # --- CLI FALLBACK (Solo si no hay GUI) ---
    # Set global pending invite DICTIONARY so --y/--n works in Lobby
    PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}

    msg_print(f"\n{Colors.M}**********************************{Colors.E}")
    msg_print(f"{Colors.M}* {req_text.upper()}{Colors.E}")
    msg_print(f"{Colors.M}* Escribe --y para Aceptar o --n para Rechazar{Colors.E}")
    msg_print(f"{Colors.M}**********************************{Colors.E}")
    safe_print("\a") # Beep

    # Loop de espera pasiva para CLI
    start_wait = time.time()
    while time.time() - start_wait < 30:
        if PENDING_INVITE is None: return # Respondido
        time.sleep(1)

    # Timeout CLI
    if PENDING_INVITE and PENDING_INVITE['ip'] == ip:
        msg_print(f"{Colors.F}[!] Invitaci√≥n de {nick} expirada.{Colors.E}")
        send_cmd(ip, "INVITE_REJ", MY_NICK, "Timeout")
        PENDING_INVITE = None




# --- UTILS v36.0 ---
def calculate_file_hash(path):
    sha256_hash = hashlib.sha256()
    with open(path, "rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def dl_file(name, size, sock, sender, sender_ip=None, expected_hash=None, file_type='FILE'):
    if not os.path.exists(DL_DIR): os.makedirs(DL_DIR)
    tmp = os.path.join(DL_DIR, f".tmp_{int(time.time())}_{name}")
    try:
        with open(tmp, "wb") as f:
            r = 0
            while r < size:
                ch = sock.recv(min(BUFFER, size-r)); 
                if not ch: break
                f.write(ch); r += len(ch)
    except Exception as e: return safe_print(f"{Colors.F}Error DL: {e}{Colors.E}")

    # v36.0: Integrity Check
    if expected_hash:
        safe_print(f"{Colors.W}[*] Verificando integridad...{Colors.E}")
        cal_hash = calculate_file_hash(tmp)
        if cal_hash != expected_hash:
             safe_print(f"{Colors.F}[X] ERRO INTEGRIDAD: Hash mismatch.{Colors.E}")
             safe_print(f"    Esperado: {expected_hash[:8]}...")
             safe_print(f"    Recibido: {cal_hash[:8]}...")
             os.remove(tmp)
             return
        else:
             safe_print(f"{Colors.G}[‚úî] Integridad verificada.{Colors.E}")

    final_path = os.path.join(DL_DIR, name)
    
    # v36.0: Folder Logic (Si es DIR, es un zip que debemos descomprimir)
    is_zip_archive = (file_type == 'DIR')
    
    if AUTO_DL:
        if os.path.exists(final_path): 
            base, ext = os.path.splitext(name)
            final_path = os.path.join(DL_DIR, f"{base}_copy_{int(time.time())}{ext}")
        
        # Rename or Unzip
        if is_zip_archive:
             # Es un directorio comprimido. Le quitamos la extension .zip al nombre final si la tiene
             folder_final_path = final_path.replace('.zip', '')
             shutil.unpack_archive(tmp, folder_final_path)
             os.remove(tmp) # Borrar zip temporal
             final_path = folder_final_path + " (Carpeta)"
        else:
             os.rename(tmp, final_path)

        safe_print(f"{Colors.G}[‚úî] Archivo guardado: {final_path}{Colors.E}")
        popup(f"De: {sender}", f"Guardado: {name}", source_ip=sender_ip); write_log(f"Recibido {name}", "FILE")
        
        # Notify Local Chat Windows (Feature Request)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         # Send System Notification to Child
                         tag = f"[{Colors.C}üìÅ{Colors.E}]"
                         msg = f"{Colors.C}{sender} ha enviado {'una carpeta' if is_zip_archive else 'un archivo'}: {name}{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

    else:
        # pending files logic, store hash/type for later accept? 
        # For simplicity, we assume if we are here we already accepted stream or stream happens anyway.
        # But wait, logic says "Wait for accept" BUT tcp stream ALREADY downloaded to tmp.
        # So we just keep tmp stored in PENDING_FILES with the metadata.
        PENDING_FILES.append({'t': tmp, 'r': final_path, 's': sender, 'hash': expected_hash, 'type': file_type})
        safe_print(f"{Colors.W}[?] '{name}' de {sender} espera (--aceptar/--rechazar).{Colors.E}"); popup("Archivo", f"{sender}: {name}", source_ip=sender_ip)
        
        # Notify Local Chat Windows (Manual Wait)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         tag = f"[{Colors.C}üìÅ{Colors.E}]"
                         msg = f"{Colors.C}{sender} env√≠a archivo: {name}. Escribe --aceptar.{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

def handle_incoming_tcp(c, ip, raw):
    global POPUP_ON, LAST_ACT, USER_OFF, PENDING_INVITE

    try:
        if raw:
            # 1. Intentar parsear como Paquete Estructurado v27
            is_cmd, cmd, args = parse_packet(raw)

            if is_cmd:
                # Auto-add to known if interaction happens
                if ip not in PEERS:
                    if ip in KNOWN_USERS:
                        PEERS[ip] = {'nick': KNOWN_USERS[ip]['nick'], 'chats': set()}
                    else:
                        PEERS[ip] = {'nick': "...", 'chats': set()}

                curr_nick = PEERS[ip]['nick']

                if not USER_OFF:
                    # Simple logic for popup, ignoring PRIVATE_PEER timeout logic for now
                    if not POPUP_ON and (time.time()-LAST_ACT > 30): POPUP_ON = True

                # BLOCK MODULAR DE COMANDOS
                if cmd == "INVITE":
                    # args: NICK, TYPE, (GID, GPASS, MEMBERS if group)
                    debug_log(f"[RED] Recibido INVITE de {ip}")
                    if len(args) >= 2:
                        nick, type = args[0], args[1]
                        extra = None
                        if type == "GROUP" and len(args) >= 5:
                            extra = (args[2], args[3], args[4]) # gid, pass, members

                        PEERS[ip]['nick'] = nick
                        st = args[len(args)-1] if type == "PRIV" and len(args) >= 3 else "?" # Status is last arg for PRIV
                        PEER_STATUSES[ip] = st
                        update_memory(ip, PEERS[ip]['nick'], st) # Sync al recibir
                        
                        debug_log(f"[INVITE_LOGIC] Iniciando logica de invitacion para {nick} (Tipo: {type})")
                        threading.Thread(target=handle_invite_logic, args=(ip, nick, type, extra)).start()

                elif cmd == "INVITE_ACC":
                    # args: R_NICK, R_STATUS
                    debug_log(f"[RED] Recibido INVITE_ACC de {ip}. Procesando aceptaci√≥n...")
                    if len(args) >= 2:
                            r_nick, r_stat = args[0], args[1]
                            
                            # Buscar invitacion pendiente mia hacia esa IP?
                            # Asumimos que si llega INVITE_ACC es porque invitamos.
                            # Creamos sala PRIV
                            cid = str(uuid.uuid4())[:8]
                            cdata = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': r_nick}
                            ACTIVE_CHATS[cid] = cdata
                            
                            # LINK ROUTING
                            if ip not in PEERS: PEERS[ip] = {'nick': r_nick, 'chats': set()}
                            if isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].add(cid)
                                debug_log(f"[RED] Vinculada IP {ip} a CID {cid} (INVITE_ACC)")
                            
                            # TRUSTED PEERS (Add logic)
                            TRUSTED_PEERS.add(ip); save_config()

                            # Threading spawn to avoid blocking TCP loop (Fix Slowness)
                            debug_log(f"[PROCESO] Iniciando consola hija para chat confirmado {cid}")
                            threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
                            refresh_ui(f"{Colors.G}[*] {r_nick} acept√≥ tu invitaci√≥n.{Colors.E}")
                            
                            # TRIGGER UPDATE CHECK (Private)
                            # Esperar un poco para estabilidad TCP
                            # threading.Thread(target=lambda: (time.sleep(3), try_trigger_updates([ip]))).start(); 
                            write_log(f"Privado ok {r_nick}", "SYS")

                elif cmd == "INVITE_REJ":
                    # args: NICK, REASON
                    reason = args[1] if len(args)>1 else "?"
                    safe_print(f"{Colors.F}[X] {args[0]} rechaz√≥ la invitaci√≥n ({reason}).{Colors.E}")
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    PENDING_INVITE = None

                elif cmd == "INVITE_TOUT":
                    # args: NICK, STATUS
                    n = args[0] if len(args)>0 else curr_nick
                    st = args[1] if len(args)>1 else "AFK"
                    safe_print(f"{Colors.W}[!] {n} no respondi√≥ (Timeout). Estado: {st}{Colors.E}")
                    update_memory(ip, n, st)
                    if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                            del PEERS[ip]
                            if ip in PEER_STATUSES: del PEER_STATUSES[ip]

                elif cmd == "GRP_INVITE_ACC":
                        # args: NICK
                        safe_print(f"{Colors.G}[‚úî] {args[0]} se uni√≥ al grupo.{Colors.E}")
                        # UDP SEARCH_GROUP will handle the actual peer linkage.

                elif cmd == "JOINED":
                    # args: NICK, STATUS
                    PEERS[ip]['nick'] = args[0]
                    st = args[1] if len(args)>1 else ""
                    PEER_STATUSES[ip] = st
                    update_memory(ip, args[0], st)

                    pdata = PEERS.get(ip)
                    if pdata and isinstance(pdata, dict):
                        for cid in pdata.get('chats', set()):
                            if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                                if ACTIVE_CHATS[cid]['type'] == 'GROUP':
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.G}[+] {args[0]} entr√≥ al grupo.{Colors.E}"
                                    send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

                    safe_print(f"{Colors.G}[+] {args[0]} entr√≥.{Colors.E}") # Lobby Log

                elif cmd == "CHILD_EXIT":
                    cid = args[0]
                    if cid in ACTIVE_CHATS:
                        # Clean up
                        if 'port' in ACTIVE_CHATS[cid]: del ACTIVE_CHATS[cid]
                        # No borramos de PEERS aqui, solo la sesi√≥n activa
                        pass

                    # Usamos safe_print antes del refresh para historial
                    safe_print(f"{Colors.G}[*] Chat cerrado (CID: {cid}).{Colors.E}")
                    refresh_ui()

                elif cmd == "GRP_MSG":
                    # args: GID, MSG
                    if len(args) >= 2:
                        gid, msg_content = args[0], args[1]
                        # Buscar localmente el chat que tiene remote_id == gid_target
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                            curr_nick = PEERS.get(ip, {}).get('nick', '?')
                            tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"
                            send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg_content}", ACTIVE_CHATS[target_cid]['port'])
                            write_log(f"[{curr_nick} @ {gid}]: {msg_content}", "CHAT")

                elif cmd == "STATUS_UPDATE":
                    # args: NICK, STATUS
                    if len(args) >= 2:
                        PEERS[ip]['nick'] = args[0]
                        PEER_STATUSES[ip] = args[1]
                        update_memory(ip, args[0], args[1])
                    elif len(args) == 1:
                        PEER_STATUSES[ip] = args[0]
                        update_memory(ip, curr_nick, args[0])

                elif cmd == "LEAVE_PRIV":
                    # args: NICK
                    safe_print(f"{Colors.W}[!] Un chat privado ha sido cerrado por {args[0]}.{Colors.E}")
                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]
                    refresh_ui()

                elif cmd == "LEAVE_GRP":
                    # args: GID, NICK
                    if len(args) >= 2:
                        gid, nick = args[0], args[1]
                        target_cid = None
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                target_cid = cid
                                break

                        if target_cid:
                            tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                            msg = f"{Colors.F}[üíî] {nick} sali√≥ del grupo.{Colors.E}"
                            if 'port' in ACTIVE_CHATS[target_cid]:
                                send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[target_cid]['port'])

                            if ip in PEERS and isinstance(PEERS[ip], dict):
                                PEERS[ip]['chats'].discard(target_cid)
                        refresh_ui()

                elif cmd == "DISCONNECT_NOW":
                    # args: NICK
                    nick_disc = args[0] if args else "?"
                    safe_print(f"{Colors.F}[!] {nick_disc} se desconect√≥ globalmente.{Colors.E}")

                    to_close = []
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                            to_close.append(cid)
                        elif cdata['type'] == 'GROUP':
                            pdata = PEERS.get(ip)
                            if pdata and cid in pdata.get('chats', set()):
                                    tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                    msg = f"{Colors.F}[üíî] {nick_disc} se desconect√≥.{Colors.E}"
                                    if 'port' in cdata: send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", cdata['port'])

                    for cid in to_close:
                        if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                        del ACTIVE_CHATS[cid]

                    if ip in PEERS: del PEERS[ip]
                    if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                    refresh_ui()

                elif cmd == "VER_CHECK" or cmd == "REQ_UPDATE" or cmd == "PUSH_UPDATE" or cmd == "VER_INFO":
                        pass # Deprecated P2P Update Commands
                    
                elif cmd == "WHOIS":
                    debug_log(f"Received WHOIS from {ip}")
                    pass

                elif cmd == "FILE_TRANSFER":
                    # args: FNAME, SIZE, [HASH, TYPE]
                    if len(args) >= 2:
                        fname = args[0]
                        fsize = int(args[1])
                        fhash = args[2] if len(args) > 2 else None
                        ftype = args[3] if len(args) > 3 else 'FILE'

                        target_cid = None
                        pdata = PEERS.get(ip)
                        if pdata and isinstance(pdata, dict):
                            for cid in pdata.get('chats', set()):
                                    if cid in ACTIVE_CHATS: target_cid = cid; break
                        
                        display_name = fname + " (Carpeta)" if ftype == 'DIR' else fname
                        safe_print(f"{Colors.W}[‚á©] Recibiendo '{display_name}' ({fsize} bytes)...{Colors.E}")
                        threading.Thread(target=dl_file, args=(fname, fsize, c, get_peer_name(ip), ip, fhash, ftype)).start()
                        return True # Keep socket open for thread

            else:
                # 2. NO ES COMANDO V27 -> Mensaje de Chat Privado (Texto Plano)
                debug_log(f"[TCP_ROUTING] Recibido mensaje plano de {ip}: '{raw[:20]}...'")
                
                target_cid = None
                pdata = PEERS.get(ip)
                if pdata:
                    chats = pdata.get('chats', set())
                    debug_log(f"[TCP_ROUTING] Chats asociados a IP {ip}: {chats}")
                    for cid in chats:
                            if cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'PRIV':
                                target_cid = cid
                                break
                else:
                        debug_log(f"[TCP_ROUTING] IP {ip} no encontrada en PEERS.")
                
                curr_nick = PEERS.get(ip, {}).get('nick', '?')
                tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"

                if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                        debug_log(f"[TCP_ROUTING] Reenviando por IPC a CID {target_cid} (Port {ACTIVE_CHATS[target_cid]['port']})")
                        send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{raw}{SEP}{ip}", ACTIVE_CHATS[target_cid]['port'])
                        write_log(f"[{curr_nick}] (FWD {target_cid}): {raw}", "CHAT")
                else:
                    debug_log(f"[TCP_ROUTING] Fallo de enrutamiento para {ip}: CID={target_cid}")
                    safe_print(f"{tag}: {raw}"); popup(f"MSG: {curr_nick}", raw, source_ip=ip); write_log(f"[{curr_nick}]: {raw}", "CHAT")

    except Exception as e:
        # safe_print(f"Err TCP: {e}")
        pass
    
    return False # Default close

def send_file(arg):
    path = os.path.expanduser(arg.strip().strip("'\""))
    if not os.path.exists(path): return safe_print(f"{Colors.F}[X] No existe.{Colors.E}") # isfile -> exists (for dirs)
    
    # v36.0: Folder Support
    is_dir = os.path.isdir(path)
    to_send_path = path
    file_type = 'FILE'
    
    if is_dir:
        safe_print(f"{Colors.W}[*] Comprimiendo carpeta '{os.path.basename(path)}'...{Colors.E}")
        # Crear zip temporal
        # make_archive (base_name, format, root_dir)
        # shutil.make_archive generar√° filename + .zip
        tmp_zip_base = f".gwc_tmp_{int(time.time())}"
        shutil.make_archive(tmp_zip_base, 'zip', path)
        to_send_path = tmp_zip_base + ".zip"
        file_type = 'DIR'
    
    # Calculate integrity
    f_hash = calculate_file_hash(to_send_path)
    n, s = os.path.basename(to_send_path) if not is_dir else os.path.basename(path) + ".zip", os.path.getsize(to_send_path)

    # Target logic same as send_all
    targets = []
    if CURRENT_CHAT_ID:
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                targets.append(ip)

    if not targets: return safe_print(f"{Colors.F}[X] Nadie en el chat actual.{Colors.E}")

    safe_print(f"{Colors.W}[‚áß] Enviando '{n}' ({s} bytes, Hash: {f_hash[:8]})...{Colors.E}"); write_log(f"Send {n}", "FILE")

    cnt = 0
    for ip in [i for i in targets if i != MY_IP]:
        try:
            k = socket.socket(socket.AF_INET, socket.SOCK_STREAM); k.settimeout(2); k.connect((ip, TCP_PORT))
            # PACKET v36: FILE_TRANSFER | NAME | SIZE | HASH | TYPE
            k.send(build_packet("FILE_TRANSFER", n, s, f_hash, file_type)); time.sleep(0.1)
            with open(to_send_path, "rb") as f:
                while True:
                    d = f.read(BUFFER);
                    if not d: break
                    k.sendall(d)
            k.close(); cnt += 1
        except Exception as e: safe_print(f"Err Send: {e}")
    safe_print(f"{Colors.G}[‚úî] Enviado a {cnt}.{Colors.E}")
    
    # Cleanup tmp zip
    if is_dir and os.path.exists(to_send_path):
        os.remove(to_send_path)

def send_ipc(msg, port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # No necesario para enviar
        s.sendto(msg.encode(), ('127.0.0.1', port))
        s.close()
    except: pass

# --- ACTUALIZACI√ìN DE SISTEMA (REPO APT) ---
VERSION_URL = "https://omarsaez.github.io/ghostwhisperchat-repo/version.txt"

def perform_system_update():
    """Ejecuta los comandos de sistema para actualizar"""
    safe_print(f"{Colors.M}[*] Ejecutando actualizaci√≥n de sistema...{Colors.E}")
    try:
        # Encadenamos update e install
        # apt install --only-upgrade asegura que no instale cosas nuevas, solo actualice lo que hay
        cmd = "sudo apt update && sudo apt install ghostwhisperchat --only-upgrade -y"
        
        subprocess.run(cmd, shell=True, check=True)
        
        safe_print(f"{Colors.G}[‚úî] Actualizaci√≥n lista. Reiniciando...{Colors.E}")
        # Reiniciar el script autom√°ticamente
        os.execv(sys.executable, ['python3'] + sys.argv)
        
    except subprocess.CalledProcessError:
        safe_print(f"{Colors.F}[X] Error en la actualizaci√≥n (¬øContrase√±a incorrecta?){Colors.E}")
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error inesperado: {e}{Colors.E}")

def check_repo_update():
    """Verifica silenciosamente si el repo tiene una versi√≥n mayor"""
    if platform.system() != "Linux": return # Solo apt por ahora
    
    # safe_print(f"{Colors.W}[*] Buscando actualizaciones en repositorio...{Colors.E}")
    try:
        # 1. Bajar el numerito (timeout corto para no congelar la app)
        # Usamos el alias 'request' cargado por lazy_import
        with request.urlopen(VERSION_URL, timeout=3) as response:
            content = response.read().decode().strip()
            # Manejar posibles saltos de linea o espacios
            latest_ver = float(content)
            
        # 2. Comparar con la constante local
        if latest_ver > APP_VER_NUM:
            safe_print(f"{Colors.W}[!] Nueva versi√≥n disponible: v{latest_ver}{Colors.E}")
            # Preguntar al usuario - INPUT bloquea?
            # En run_lobby estamos en hilo principal antes del input loop.
            # Podemos usar input simple.
            try:
                # Flush input buffer
                if platform.system() == "Linux": subprocess.run("tcflush", shell=True, stderr=subprocess.DEVNULL) 
            except: pass
            
            raw_print(f"{Colors.G}¬øDeseas actualizar ahora? se necesitaran permisos ROOT (sudo) [s/n]: {Colors.E}")
            # Usamos input builtin directo
            do_up = input()
            
            if do_up.lower().startswith('s'):
                perform_system_update()
            else:
                 safe_print(f"{Colors.W}[*] Actualizaci√≥n pospuesta.{Colors.E}")

    except Exception as e:
        # Si falla internet o github, no hacemos nada, seguimos normal
        # safe_print(f"Update Check Fail: {e}")
        pass

# ... existing code ...

def toggle_autostart(enable, target_cid=None):
    """Activa o desactiva el inicio autom√°tico en Linux (.config/autostart)"""
    if platform.system() != "Linux":
        return reply_print(f"{Colors.F}[!] Solo disponible en Linux por ahora.{Colors.E}", target_cid)
        
    autostart_dir = os.path.expanduser("~/.config/autostart")
    desktop_file = os.path.join(autostart_dir, "inter_chat_auto.desktop")
    
    if enable:
        try:
            if not os.path.exists(autostart_dir): os.makedirs(autostart_dir)
            
            # Obtener rutas absolutas
            exe = sys.executable
            script = os.path.abspath(sys.argv[0])
            
            content = f"""[Desktop Entry]
Type=Application
Name=InterChat Auto
Exec={exe} "{script}"
Terminal=true
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Comment=Auto-start InterChat Lobby
"""
            with open(desktop_file, "w") as f:
                f.write(content)
            
            # Dar permisos de ejecuci√≥n al script por si acaso
            # os.chmod(script, 0o755) # Comentado: Falla en /usr/bin/ si no eres root. Ya deber√≠a ser ejecutable.
            
            reply_print(f"{Colors.G}[‚úî] Autolevantado ACTIVADO (Inicio de sesi√≥n).{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error activando autostart: {e}{Colors.E}", target_cid)
    else:
        try:
            if os.path.exists(desktop_file):
                os.remove(desktop_file)
                reply_print(f"{Colors.W}[‚úî] Autolevantado DESACTIVADO.{Colors.E}", target_cid)
            else:
                reply_print(f"{Colors.W}[!] No estaba activado.{Colors.E}", target_cid)
        except Exception as e:
            reply_print(f"{Colors.F}[!] Error desactivando: {e}{Colors.E}", target_cid)

# --- COMANDOS LOBBY CENTRALIZADOS ---
def exec_lobby_cmd(inp, origin_cid=None):
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, POPUP_ON, USER_OFF
    global LOBBY_HISTORY, DEBUG_MODE # v36.9 Fix SyntaxError

    inp = inp.strip()
    if not inp: return

    parts = inp.split(" ", 1)
    raw_cmd = parts[0]
    args = parts[1] if len(parts) > 1 else ""
    
    # 1. Resolver comando a su KEY interna (v34.0)
    cmd_key = resolve_cmd(raw_cmd)
    
    # Soporte legacy para comandos especiales con espacio (ej: --log on)
    # Aunque ahora tenemos alias mejores como --log-on
    if not cmd_key:
         if inp in ["--log on"]: cmd_key = 'LOG_ON'
         elif inp in ["--log off"]: cmd_key = 'LOG_OFF'

    # --- COMANDOS DE CREACI√ìN DE SESI√ìN (Forcan hijos) ---
    if cmd_key == 'CHAT_GROUP':
        gp_parts = args.split()
        if len(gp_parts) == 2:
            gid, gp = gp_parts[0], gp_parts[1]
            cid = str(uuid.uuid4())[:8]
            cdata = {'type': 'GROUP', 'remote_id': gid, 'pass': gp, 'created_at': time.time()}
            ACTIVE_CHATS[cid] = cdata
            spawn_child_process(cid, cdata)
            reply_print(f"{Colors.G}[*] Grupo creado/unido.{Colors.E}", origin_cid) # FIX BUG 1
        else: reply_print(f"{Colors.F}El formato es ID CLAVE. Ejemplo: --chatgrupal 10 clave123.{Colors.E}", origin_cid)

    elif cmd_key == 'CHAT_PRIV':
        t = find_global(args)
        if t:
            if t == MY_IP: reply_print(f"{Colors.F}Eres t√∫.{Colors.E}", origin_cid)
            else:
                reply_print(f"{Colors.W}[*] Invitando...{Colors.E}", origin_cid)
                debug_log(f"[CMD] Enviando comando INVITE a IP={t} (Contenido del paquete: MiNick={MY_NICK})")
                send_cmd(t, "INVITE", MY_NICK, "PRIV", MY_STATUS)

    # --- COMANDOS GLOBALES / UTILIDADES ---
    elif cmd_key == 'LS':
         if origin_cid:
             # Solicitud desde una ventana hija: Listar miembros de ESE chat specificamente
             cdata = ACTIVE_CHATS.get(origin_cid)
             if not cdata: return
             
             target_port = cdata.get('port')
             if not target_port: return

             # Construir lista de miembros
             members = []
             members.append(f"{Colors.BO}> {MY_NICK} ({MY_IP}) [T√∫]{Colors.E}")
             
             if cdata['type'] == 'PRIV':
                 rid = cdata['remote_id']
                 rnick = cdata.get('remote_nick', '?')
                 members.append(f"- {rnick} ({rid})")
             
             elif cdata['type'] == 'GROUP':
                 gid = cdata['remote_id']
                 # Buscar en PEERS quienes est√°n en este chat
                 count = 1 # Yo
                 for ip, pdata in PEERS.items():
                     if isinstance(pdata, dict) and origin_cid in pdata.get('chats', set()):
                         members.append(f"- {pdata.get('nick', '?')} ({ip})")
                         count += 1
                 
                 # Enviar cabecera con total
                 msg = f"{Colors.H}--- MIEMBROS DEL GRUPO ({count}) ---{Colors.E}\n" + "\n".join(members)
                 # Enviar al hijo via IPC
                 send_ipc(f"MSG_IN{SEP}Sistema{SEP}{msg}{SEP}{Colors.C}", target_port)
                 return

         # Si estamos en lobby (sin origin_cid), mostrar chats activos y lista de usuarios conocidos
         safe_print(f"{Colors.G}--- RESUMEN DE RED ---{Colors.E}")
         safe_print(f"Total de Usuarios Conocidos: {len(KNOWN_USERS) + 1}") # +1 soy yo
         safe_print(f"{Colors.BO} > {MY_NICK} ({MY_IP}) [Yo]{Colors.E}")
         
         # Listar resto
         for ip, d in KNOWN_USERS.items():
             est = d.get('status','?')
             safe_print(f" - {d['nick']} ({ip}) [{est}]")
             
         safe_print(f"\n{Colors.G}Sesiones de Chat Activas ({len(ACTIVE_CHATS)}):{Colors.E}")
         for cid, d in ACTIVE_CHATS.items():
             safe_print(f" - [{cid}] {d['type']}: {d.get('remote_nick', d['remote_id'])}")

    elif cmd_key == 'CONTACTS':
        reply_print(f"{Colors.G}[*] Historial de Sesi√≥n ({len(KNOWN_USERS)}):{Colors.E}", origin_cid)
        for ip, d in KNOWN_USERS.items(): 
            msg = f"   - {d['nick']} ({ip}) [{d['status']}] (Visto: {time.strftime('%H:%M', time.localtime(d['t']))})"
            reply_print(msg, origin_cid)

    elif cmd_key == 'SCAN': scan_network(target_cid=origin_cid)
    elif cmd_key == 'SCAN_VIS_ON':
        VISIBLE_IN_SCAN=True; save_config()
        # refresh_ui borra pantalla, eso no se puede redirigir facil al chat, asi que enviamos solo texto
        if origin_cid: reply_print(f"{Colors.G}[‚úî] Visible en esc√°ner.{Colors.E}", origin_cid)
        else: refresh_ui(f"{Colors.G}[‚úî] Visible en esc√°ner.{Colors.E}")
        
    elif cmd_key == 'SCAN_VIS_OFF':
        VISIBLE_IN_SCAN=False; save_config()
        if origin_cid: reply_print(f"{Colors.W}[‚úî] Oculto en esc√°ner.{Colors.E}", origin_cid)
        else: refresh_ui(f"{Colors.W}[‚úî] Oculto en esc√°ner.{Colors.E}")

    elif cmd_key == 'STATUS':
        MY_STATUS = args; save_config()
        if origin_cid: reply_print(f"{Colors.G}[‚úî] Estado actualizado.{Colors.E}", origin_cid)
        else: refresh_ui(f"{Colors.G}[‚úî] Estado actualizado.{Colors.E}")
        send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

    elif cmd_key == 'NICK':
        old_nick = MY_NICK
        MY_NICK = args; save_config()
        
        msg = f"{Colors.G}[‚úî] Nick cambiado de {old_nick} a {MY_NICK}.{Colors.E}"
        if origin_cid: reply_print(msg, origin_cid)
        else: refresh_ui(msg)
        
        # Broadcast cambio inmediato
        send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS) # Esto notifica a todos
        # Y avisar a mis propias ventanas hijas para que sepan el cambio?
        # Bueno, el refresco de UI lo maneja lobby, pero el title bar...
        set_terminal_title(f"GWC Lobby - {MY_NICK}")

    elif cmd_key == 'LOG_ON': LOG_ON=True; save_config(); reply_print(f"{Colors.G}LOG ON - Historial activado.{Colors.E}", origin_cid)
    elif cmd_key == 'LOG_OFF': LOG_ON=False; save_config(); reply_print(f"{Colors.W}LOG OFF - Historial desactivado.{Colors.E}", origin_cid)
    elif cmd_key == 'POP_OFF': POPUP_ON, USER_OFF = False, True; reply_print(f"{Colors.W}Mute Manual.{Colors.E}", origin_cid)
    elif cmd_key == 'POP_ON': POPUP_ON, USER_OFF = True, False; reply_print(f"{Colors.G}Popups ON.{Colors.E}", origin_cid)
    
    # Auto Download
    elif cmd_key == 'DL_ON':
        AUTO_DL = True; save_config()
        reply_print(f"{Colors.G}[‚úî] Descarga autom√°tica ACTIVADA.{Colors.E}", origin_cid)
        
    elif cmd_key == 'DL_OFF':
        AUTO_DL = False; save_config()
        reply_print(f"{Colors.W}[‚úî] Descarga autom√°tica DESACTIVADA (Se preguntar√°).{Colors.E}", origin_cid)

    # AutoStart Commands
    elif cmd_key == 'AUTOSTART_ON': toggle_autostart(True, origin_cid)
    elif cmd_key == 'AUTOSTART_OFF': toggle_autostart(False, origin_cid)
    
    elif cmd_key == 'CLEAR':
        global LOBBY_HISTORY
        LOBBY_HISTORY = [] # Reset total si pide clear manual
        refresh_ui()

    elif cmd_key == 'INVITE':
        if not origin_cid:
             reply_print(f"{Colors.F}[!] Comando disponible solo dentro de una ventana de chat.{Colors.E}", origin_cid)
        else:
             # L√≥gica de invitaci√≥n desde dentro del chat
             # --invite A B C ...
             args_list = [x.strip().replace(',','') for x in args.split()]
             if not args_list: return

             chat_data = ACTIVE_CHATS.get(origin_cid)
             if not chat_data: return

             reply_print(f"{Colors.W}[*] Procesando invitaciones para chat {origin_cid}...{Colors.E}", origin_cid)

             targets_map = {} # IP -> Nick (o 'Unknown')
             unknown_nicks = []

             for arg in args_list:
                 # Es IP? (regex simple o check de puntos)
                 is_ip = False
                 if arg.count('.') == 3 and arg.replace('.','').isdigit():
                     # Asumimos IP
                     targets_map[arg] = "Usuario IP"
                     is_ip = True

                 if not is_ip:
                     # Es un Nick.
                     # 1. Buscar en memoria (R√°pido)
                     target_clean = normalize_str(arg)
                     found = False
                     
                     # Check Global Peers
                     for ip, pdata in PEERS.items():
                         if isinstance(pdata, dict) and normalize_str(pdata.get('nick', '')) == target_clean:
                             targets_map[ip] = pdata.get('nick')
                             found = True
                             break
                     
                     # Check History
                     if not found:
                         for ip, d in KNOWN_USERS.items():
                             if normalize_str(d['nick']) == target_clean:
                                 targets_map[ip] = d['nick']
                                 found = True
                                 break
                     
                     if not found:
                         unknown_nicks.append(arg)
             
             # 2. Escaneo Activo para desconocidos (Lento: 2s)
             if unknown_nicks:
                 reply_print(f"{Colors.W}[*] Escaneando red para: {', '.join(unknown_nicks)}...{Colors.E}", origin_cid)
                 global DISC_TEMP
                 DISC_TEMP = [] # Reset buffer discovery

                 # Enviar WHO a broadcast
                 with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                    s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                    s.settimeout(0.5)
                    try:
                        s.sendto(build_packet("WHOIS", MY_NICK), ('255.255.255.255', UDP_PORT))
                    except: pass
                 
                 time.sleep(2) # Esperar respuestas
                 
                 # DISC_TEMP se llena en udp_loop
                 for d_ip, d_nick, d_stat in DISC_TEMP:
                     update_memory(d_ip, d_nick, d_stat)
                     # Revisar si coincide con lo que buscabamos
                     for unick in unknown_nicks:
                         clean_target = normalize_str(unick)
                         if normalize_str(d_nick) == clean_target:
                             targets_map[d_ip] = d_nick
                             reply_print(f"{Colors.G}[+] Encontrado: {d_nick} ({d_ip}){Colors.E}", origin_cid)
                             break

             if not targets_map:
                 reply_print(f"{Colors.F}[!] Ning√∫n objetivo v√°lido encontrado.{Colors.E}", origin_cid)
                 return

             # Enviar invitaciones finales
             # Si es Group: Manda INVITE GROUP con ID + PASS
             # Si es Priv: No se puede "invitar" a 3ro a un priv (ser√≠a crear grupo). 
             gid = chat_data.get('remote_id') if chat_data['type'] == 'GROUP' else None
             
             for ip, pdata in PEERS.items():
                 # Update map con info real si es peer activo
                 if ip in targets_map:
                     if isinstance(pdata, dict): targets_map[ip] = pdata.get('nick', targets_map[ip])
                     elif 'chat' in pdata: 
                         # Caso donde solo tenemos chat list y no nick (raro)
                         pass
             
             for ip, tnick in targets_map.items():
                 # Validar que no este ya
                 if gid:
                     # Group Logic
                     send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, chat_data['pass'], args) # Args aqui no se usa, deberia ser members list
                     reply_print(f"   > Invitaci√≥n enviada a {tnick} ({ip}).", origin_cid)
                 else:
                     # Priv Logic (Upgrade?)
                     # No se puede invitar a terceros a un chat privado.
                     reply_print(f"   [!] No se puede invitar a terceros a un chat privado.", origin_cid)
             
             if unknown_nicks:
                 reply_print(f"   [!] No encontrados: {', '.join(unknown_nicks)}", origin_cid)

    elif cmd_key == 'FILE':
         if not origin_cid:
             reply_print(f"{Colors.F}[!] Env√≠o de archivos disponible solo dentro de una ventana de chat.{Colors.E}", origin_cid)
         else:
             if args: send_file(args)
             else: reply_print(f"{Colors.F}Falta ruta del archivo.{Colors.E}", origin_cid)

    elif cmd_key == 'EXIT':
        if origin_cid:
            # Comando viene de una ventana hija -> Cerrar SOLO esa ventana
            leave_sess(target_cid=origin_cid)
        else:
            # Comando en el Lobby -> Apagar APP
            shutdown_lobby()

    # --- RESPUESTAS A INVITACIONES ---
    elif cmd_key == 'ACCEPT':
        if not PENDING_INVITE:
            reply_print(f"{Colors.W}No tienes invitaciones pendientes.{Colors.E}", origin_cid)
        else:
             reply_print(f"{Colors.G}[*] Aceptando...{Colors.E}", origin_cid)
             debug_log(f"[CMD] Ejecutando logic ACCEPT para {PENDING_INVITE['ip']}")
             # PENDING_INVITE: {'ip': ip, 'type': 'GROUP'/'PRIV', 'id': gid/None, 'pass': pass/None}
             if PENDING_INVITE['type'] == 'GROUP':
                  exec_lobby_cmd(f"--chatgrupal {PENDING_INVITE['data'][0]} {PENDING_INVITE['data'][1]}")
             else:
                  start_private_chat(PENDING_INVITE['ip'], PENDING_INVITE.get('nick','?'))
             PENDING_INVITE = None

    elif cmd_key == 'DENY':
        if PENDING_INVITE:
            reply_print(f"{Colors.W}[*] Invitaci√≥n rechazada.{Colors.E}", origin_cid)
            send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Rechazado")
            PENDING_INVITE = None
        else:
            reply_print(f"{Colors.W}Nada que rechazar.{Colors.E}", origin_cid)

    elif cmd_key == 'HELP':
        show_help(origin_cid)

    elif cmd_key == 'SHORTCUTS':
        # Nueva funcionalidad v34.0
        msg_lines = [f"{Colors.H}=== ABREVIACIONES Y ALIAS (v34.x) ==={Colors.E}"]
        msg_lines.append("") # Spacer
        
        # Ordenar keys por nombre
        for key in sorted(COMMAND_DEFS.keys()):
            data = COMMAND_DEFS[key]
            # Mostrar max 5 alias por linea para no saturar
            aliases = data['aliases']
            desc = data['desc']
            msg_lines.append(f"{Colors.BO}‚óè {key}{Colors.E} : {desc}")
            msg_lines.append(f"   ‚Ü≥ Variantes: { Colors.C + ', '.join(aliases) + Colors.E }")
            msg_lines.append("") # Spacer entre comandos para legibilidad
        
        full_msg = "\n".join(msg_lines)
        if origin_cid: reply_print(full_msg, origin_cid)
        else: safe_print(full_msg)

    elif cmd_key == 'CLEAR':
        # global LOBBY_HISTORY -> Moved to top
        LOBBY_HISTORY = []
        os.system('cls' if os.name == 'nt' else 'clear')
        if origin_cid: reply_print(f"{Colors.G}Pantalla limpiada.{Colors.E}", origin_cid) # Virtual clear msg
        else: safe_print(f"{Colors.B}Lobby limpiado.{Colors.E}")
        
    elif cmd_key == 'DEBUG':
        DEBUG_MODE = not DEBUG_MODE
        status = "ACTIVADO" if DEBUG_MODE else "DESACTIVADO"
        dsk = get_desktop_path()
        log_path = os.path.join(dsk, "gwc_lobby_debug.log")
        reply_print(f"{Colors.M}[DEBUG] Modo Debug {status}.{Colors.E}", origin_cid)
        if DEBUG_MODE:
            reply_print(f"{Colors.M}[DEBUG] Guardando logs en: {log_path}{Colors.E}", origin_cid)
            debug_log("--- SESION DE DEBUG INICIADA ---")

    elif cmd_key == 'GLOBAL_STATUS':
        # v35.1 Mejorado
        lines = [f"{Colors.H}=== ESTADO GLOBAL DEL SISTEMA ==={Colors.E}"]
        lines.append(f" {Colors.BO}Versi√≥n:{Colors.E} {APP_VERSION}")
        lines.append(f" {Colors.BO}Usuario:{Colors.E} {MY_NICK} ({MY_IP})")
        lines.append(f" {Colors.BO}Estado:{Colors.E} {MY_STATUS}")
        lines.append(f" {Colors.BO}Visibilidad Red:{Colors.E} {'VISIBLE' if VISIBLE_IN_SCAN else 'OCULTO (Ghost Mode)'}")
        lines.append(f" {Colors.BO}Auto-Descargas:{Colors.E} {'ACTIVADAS' if AUTO_DL else 'DESACTIVADAS (Preguntar)'}")
        lines.append(f" {Colors.BO}Notificaciones:{Colors.E} {'ON' if POPUP_ON else 'OFF (Mute Global)'}")
        lines.append(f" {Colors.BO}Guardar Historial:{Colors.E} {'ON' if LOG_ON else 'OFF'}")
        
        # Determine autostart status on Linux
        auto_st = "?"
        if platform.system() == "Linux":
             p = os.path.expanduser("~/.config/autostart/inter_chat_auto.desktop")
             auto_st = "ACTIVADO" if os.path.exists(p) else "DESACTIVADO"
        else: auto_st = "N/A (No Linux)"
        lines.append(f" {Colors.BO}Auto-Inicio (Linux):{Colors.E} {auto_st}")
        
        lines.append("")
        lines.append(f"{Colors.BO}:: LISTADO DE CONTACTOS Hitoricos (Total: {len(KNOWN_USERS)}) ::{Colors.E}")
        if not KNOWN_USERS:
            lines.append(" (Vac√≠o)")
        else:
            for ip, d in KNOWN_USERS.items():
                seen = time.strftime('%H:%M', time.localtime(d['t']))
                lines.append(f" - {d['nick']} ({ip}) [{d['status']}] (Visto: {seen})")
        
        lines.append("")
        lines.append(f"{Colors.BO}:: CHATS ACTIVOS (Total: {len(ACTIVE_CHATS)}) ::{Colors.E}")
        if not ACTIVE_CHATS:
             lines.append(" (Ninguno)")
        else:
             for cid, d in ACTIVE_CHATS.items():
                 lines.append(f" - [{cid}] {d['type']}: {d.get('remote_nick', d['remote_id'])}")

        full_msg = "\n".join(lines)
        if origin_cid: reply_print(full_msg, origin_cid)
        else: safe_print(full_msg)

    # Si no matchea nada
    elif cmd_key is None and raw_cmd.startswith("-"):
         reply_print(f"{Colors.F}Comando desconocido: {raw_cmd}. Prueba --help o --ab.{Colors.E}", origin_cid)

# --- PROCESOS & LOBBY ---

def check_child_health():
    """Vigila si los procesos hijos siguen vivos. Si no, limpia la sesi√≥n."""
    while True:
        time.sleep(2) # v37.26: Faster check (2s)
        to_kill = []
        for cid, data in list(ACTIVE_CHATS.items()):
            if 'pid' in data:
# ... (rest is same, just skipped for context) ...

# ... inside ipc_listen_parent ...
            if cmd == "CHILD_EXIT":
                cid = p[1]
                if cid in ACTIVE_CHATS:
                    # v37.26 Fix: Notify peers correctly before local deletion
                    # Using leave_sess ensures DISCONNECT_NOW/LEAVE_GRP is sent.
                    leave_sess(target_cid=cid, silent=False) 
                    refresh_ui()
            
            elif cmd == "FWD_CMD":
                if len(p) >= 3:
                     cstr = p[2]
                     print(f"\n{Colors.M}[IPC] Ejecutando comando remoto: {cstr}{Colors.E}")
                     exec_lobby_cmd(cstr, origin_cid=p[1])

        except Exception as e:
            debug_log(f"[IPC_ERROR] Error en listener IPC del Lobby: {e}")

def ipc_listen_child(my_port, lock_state):
    # lock_state es un dict compartido con el thread principal del hijo para leer/escribir estado de POPs
    global MY_CHILD_ID
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try: u.bind(('127.0.0.1', int(my_port)))
    except Exception as e: 
        print(f"Error bind child IPC: {e}")
        return
    
    while True:
        try:
            d, _ = u.recvfrom(8192); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "FWD_MSG":
                if len(p) >= 4:
                    cid, tag, text = p[1], p[2], p[3]
                    if cid == MY_CHILD_ID:
                        safe_print(f"{tag}: {text}") 
                        
                        # LOGICA SMART POPUP
                        now = time.time()
                        last_in = lock_state.get('last_input', 0)
                        last_rx = lock_state.get('last_rx', 0)
                        manual_off = lock_state.get('pop_off', False)
                        ctype = lock_state.get('type', 'PRIV')
                        
                        # Actualizamos last_rx AHORA (actividad reciente en el chat)
                        lock_state['last_rx'] = now
                        
                        should_pop = False

                        # 1. Chequeo Manual Override (Prioridad Alta)
                        if manual_off:
                            # Si activado 'mute', solo suena si pasaron 5 mins (300s) de TOTAL SILENCIO previo
                            # Ojo: last_rx se acaba de actualizar, asi que comparamos con el last_rx *antes* de este msg?
                            # El usuario dijo: "pasan 5 minutos sin actividad... se vuelven a activar".
                            # Significa que si entre el mensaje ANTERIOR y ESTE pasaron > 300s, reactivamos.
                            if (now - last_rx) > TIMERS['MANUAL']:
                                lock_state['pop_off'] = False # Reactivar
                                safe_print(f"{Colors.W}[i] Popups reactivados por inactividad prolongada.{Colors.E}")
                                should_pop = True
                        else:
                            # 2. Chequeo Smart (Solo si no escrib√≠ yo recientemente)
                            limit = TIMERS['PRIV'] if ctype == 'PRIV' else TIMERS['GROUP']
                            if (now - last_in) > limit:
                                should_pop = True
                        
                        if should_pop:
                             # Limpiar colores (ANSI escape codes) PRIMERO
                             # Si quitamos corchetes antes, rompemos la secuencia \033[...m
                             ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                             
                             tag_clean = ansi_escape.sub('', tag)
                             text_clean = ansi_escape.sub('', text)
                             
                             # Ahora sacar los corchetes decorativos del tag
                             sender_clean = tag_clean.replace('[','').replace(']','')
                             
                             title = ""
                             if ctype == 'GROUP':
                                 # Necesitamos el ID del grupo
                                 rid = lock_state.get('remote_id', '?')
                                 title = f"Mensaje grupal ({rid}) de {sender_clean}"
                             else:
                                 title = f"Mensaje privado de {sender_clean}"

                             popup(title, text_clean)

            elif cmd == "FWD_FILE":
                if len(p) >= 4 and p[1] == MY_CHILD_ID:
                    safe_print(f"{Colors.W}[‚á©] Archivo '{p[3]}' de {p[2]} recibido en Lobby.{Colors.E}")
            
            elif cmd == "FWD_PEER":
                if len(p) >= 4:
                    rmt_ip, rmt_nick, rmt_stat = p[1], p[2], p[3]
                    if rmt_ip not in PEERS: PEERS[rmt_ip] = {'nick': rmt_nick, 'chats': {MY_CHILD_ID}}
                    else: 
                         if isinstance(PEERS[rmt_ip], dict):
                             PEERS[rmt_ip]['nick'] = rmt_nick
                             PEERS[rmt_ip]['chats'].add(MY_CHILD_ID)
                    safe_print(f"{Colors.G}[+] Detectado: {rmt_nick}{Colors.E}")
            
            elif cmd == "CMD_CLOSE_NOW":
                # Fuerza cierre (ej: peer desconectado en privado)
                # Usamos global REMOTE_NICK seteada en run_child
                safe_print(f"\n{Colors.F}[üíî] {REMOTE_NICK} ha abandonado el chat.{Colors.E}")
                # print(f"\n{Colors.F}[!] Cierre remoto: {p[1] if len(p)>1 else ''}{Colors.E}")
                time.sleep(3)
                # No mandamos exit signal propia para evitar bucle, solo salimos
                os._exit(0)

        except: pass

def shutdown_lobby():
    print(f"\n{Colors.W}[*] Cerrando todas las sesiones y saliendo...{Colors.E}")
    
    # 1. Notificar a peers remotos (Global Disconnect)
    # Enviamos a todos los peers conocidos que estamos desconectando
    # Esto cerrar√° los privados en su lado y notificar√° en grupos
    # NOTA: Si queremos ser espec√≠ficos, podr√≠amos mandar LEAVE_GRP a grupos
    # y DISCONNECT_NOW a privados, pero un DISCONNECT_NOW global es m√°s seguro para "apagar todo".
    # El receptor ya maneja DISCONNECT_NOW cerrando privados y notificando grupos.
    known_ips = list(PEERS.keys())
    # Filtrar solo IPs que tienen algun chat activo con nosotros
    # Para no mandar paquetes a gente que solo "vimos" en un scan pero no hablamos
    active_targets = []
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and pdata.get('chats'):
             # Tiene al menos 1 chat en comun con nosotros
             active_targets.append(ip)

    for ip in active_targets:
        send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
        
    # 2. Cerrar hijos locales
    for cid, cdata in list(ACTIVE_CHATS.items()):
        if 'port' in cdata:
            # Mandar se√±al de cierre suicida al hijo
            send_ipc("CMD_CLOSE_NOW", cdata['port'])
    
    time.sleep(1) # Dar tiempo a que salgan los mensajes
    restore_terminal()
    print(f"{Colors.G}[‚úî] Todo cerrado. Hasta luego.{Colors.E}")
    sys.exit(0)

def restore_terminal():
    """Restaura el eco de la terminal en Linux si se perdi√≥"""
    if platform.system() != "Windows":
        os.system("stty echo")

# Asegurar restauraci√≥n al salir brusco
atexit.register(restore_terminal)


def liberate_ports():
    """Detecta y elimina procesos zombies ocupando nuestros puertos"""
    ports = [TCP_PORT, UDP_PORT]
    try:
        if platform.system() == "Linux":
            for p in ports:
                subprocess.run(f"fuser -k {p}/tcp", shell=True, stderr=subprocess.DEVNULL)
                subprocess.run(f"fuser -k {p}/udp", shell=True, stderr=subprocess.DEVNULL)
        elif platform.system() == "Windows":
             for p in ports:
                 try:
                     r = subprocess.check_output(f"netstat -ano | findstr :{p}", shell=True, stderr=subprocess.DEVNULL).decode(errors='ignore')
                     lines = r.strip().split('\n')
                     for line in lines:
                         parts = line.split()
                         if len(parts) > 4:
                             pid = parts[-1]
                             if pid != "0": # No matar System
                                 subprocess.run(f"taskkill /F /PID {pid}", shell=True, stderr=subprocess.DEVNULL)
                 except: pass
    except: pass

def enable_win_visuals():
    """Fuerza UTF-8 y ANSI Colors en consola de Windows"""
    if platform.system() == "Windows":
        try:
            # 1. UTF-8
            os.system("chcp 65001 > nul") 
            # 2. ANSI VT100
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except: pass

def setup_autocomplete():
    """Configura el autocompletado para la l√≠nea de comandos del lobby."""
    if platform.system() != "Windows": # Readline no est√° disponible en Windows por defecto
        try:
            import readline
            
            # Obtener todos los comandos y sus alias
            all_commands = []
            for cmd_key, data in COMMAND_DEFS.items():
                all_commands.append(f"--{cmd_key.lower()}") # Comando principal
                for alias in data['aliases']:
                    if alias.startswith('--'):
                        all_commands.append(alias)
            
            # Funci√≥n de autocompletado Inteligente
            def completer(text, state):
                buffer = readline.get_line_buffer()
                line_parts = buffer.lstrip().split()
                
                options = []
                
                # Contexto: ¬øEs el inicio de la l√≠nea o un comando?
                # Si estamos escribiendo la primera palabra
                if not line_parts or (len(line_parts) == 1 and not buffer.endswith(' ')):
                    options = [i for i in all_commands if i.startswith(text)]
                
                else:
                    # Contexto: Argumentos
                    cmd_str = line_parts[0]
                    cmd_key = resolve_cmd(cmd_str)
                    
                    # Si el comando es INVITE o CHAT_PRIV, sugerir Usuarios
                    if cmd_key in ['INVITE', 'CHAT_PRIV']:
                        # Prioridad 1: Contactos Conocidos (Memoria + Peers)
                        prio_candidates = set()
                        for d in KNOWN_USERS.values(): prio_candidates.add(d['nick'])
                        for p in PEERS.values(): 
                            if isinstance(p, dict): prio_candidates.add(p.get('nick', '?'))
                        
                        options_prio = [n for n in prio_candidates if n.startswith(text)]
                        
                        # Prioridad 2: Resultados de Escaneo Reciente (DISC_TEMP)
                        # "si no encuentra nada similar... busca en listado de quienes interno"
                        sec_candidates = set()
                        global DISC_TEMP
                        for item in DISC_TEMP:
                            # item structure depends on scan func: (ip, nick, stat)
                            if len(item) >= 2: sec_candidates.add(item[1])
                            
                        options_sec = [n for n in sec_candidates if n.startswith(text) and n not in prio_candidates]
                        
                        # Combinar: Primero contactos, luego descubiertos
                        options = options_prio + options_sec
                
                if state < len(options):
                    return options[state]
                else:
                    return None

            readline.set_completer(completer)
            readline.parse_and_bind("tab: complete")
            # Configurar delimitadores: espacio, tab, salto linea y COMA (para invites multiples)
            # El guion (-) se quit√≥ para permitir comandos con guiones
            readline.set_completer_delims(' \t\n,')
            
            safe_print(f"{Colors.G}[‚úî] Autocompletado activado (presiona TAB).{Colors.E}")
        except ImportError:
            safe_print(f"{Colors.W}[!] M√≥dulo 'readline' no encontrado. Autocompletado no disponible.{Colors.E}")
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error al configurar autocompletado: {e}{Colors.E}")

def run_lobby():
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE
    # atexit.register(lambda: print(f"{Colors.W}Lobby cerrado.{Colors.E}")) # Reemplazado por shutdown manual
    
    # Self-Healing Checks
    enable_win_visuals()
    liberate_ports()
    
    # Capturar Ctrl+C en Lobby para shutdown limpio
    import signal
    signal.signal(signal.SIGINT, lambda s, f: shutdown_lobby())
    
    lazy_import() # Load heavy libraries only when needed (Lobby or Child)
    global hashlib
    import hashlib # v36.0 Integrity check


    os.system('cls' if os.name == 'nt' else 'clear'); fw_cfg(); MY_IP = get_ip()
    set_terminal_title(f"GWC Lobby - {MY_NICK}")
    
    # Kali/Network Check
    if MY_IP.startswith("127.") and platform.system() == "Linux":
         print(f"{Colors.W}[!] ADVERTENCIA: IP local ({MY_IP}) detectada.{Colors.E}")
         print(f"{Colors.W}[!] Si usas Kali Linux, verifica que no est√©s en 'Modo Monitor' (airmon-ng stop wlan0).{Colors.E}")
         print(f"{Colors.W}[!] La visibilidad en red estar√° limitada.{Colors.E}")
         time.sleep(3)
    
    global LOBBY_HISTORY, PROMPT
    PROMPT = f"{Colors.B}Lobby > {Colors.E}"
    
    val_nick = MY_NICK if MY_NICK.strip() else socket.gethostname()
    
    if not load_config():
        while True:
            try: 
                if n := input("Tu Nickname: ").strip(): MY_NICK = n; break
            except: sys.exit()
        save_config()
    else:
        # Fallback if config loaded empty nick
        if not MY_NICK.strip(): MY_NICK = socket.gethostname()
    
    # Check Network Security on Startup
    global SILENT_UPDATES_ALLOWED
    SILENT_UPDATES_ALLOWED = check_network_trust()
    if SILENT_UPDATES_ALLOWED:
        pass # safe_print(f"{Colors.G}[Sec] Actualizaciones silenciosas ACTIVAS en esta red.{Colors.E}")
    else:
        pass # safe_print(f"{Colors.W}[Sec] Actualizaciones silenciosas DESACTIVADAS.{Colors.E}")

    refresh_ui() # Clean start with Dashboard
    
    # Aseguramos limpieza al inicio tambi√©n por si acaso
    restore_terminal()
    
    # Setup Autocomplete (v35.0)
    setup_autocomplete()

    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    # v37.23 Modular Logic - Start Listeners via gw_comm
    gw_comm.start_tcp_listener(handle_incoming_tcp)
    gw_comm.start_udp_listener(handle_incoming_udp)
    
    threading.Thread(target=check_child_health, daemon=True).start() # Health check
    
    check_repo_update()

    while True:
        try:
            inp = input(f"{Colors.B}Lobby > {Colors.E}").strip()
            if inp: LOBBY_HISTORY.append(f"{Colors.B}Lobby > {Colors.E}{inp}") # Guardar input usuario
            
            restore_from_afk()
            exec_lobby_cmd(inp)
        except KeyboardInterrupt: sys.exit()
        except Exception as e: safe_print(f"Err Lobby: {e}")

def handle_child_sigint(cid):
    # Enviar se√±al de salida al lobby y morir
    try:
        send_ipc(f"CHILD_EXIT{SEP}{cid}", IPC_PORT)
    except: pass
    print(f"{Colors.W}[*] Cerrando chat...{Colors.E}")
    time.sleep(0.2)
    os._exit(0)

def run_child(cid, ctype, remote, password, mynick, mystatus, myport, rnick="?"):
    global MY_NICK, MY_STATUS, MY_IP, CURRENT_CHAT_ID, IS_CHILD, MY_CHILD_ID, PROMPT, REMOTE_NICK
    IS_CHILD = True
    MY_CHILD_ID = cid
    CURRENT_CHAT_ID = cid
    
    lazy_import() # Ensure libs are loaded in child too
    global hashlib
    import hashlib # v36.2 Fix: Explicit import in child
    
    MY_NICK = mynick
    MY_STATUS = mystatus
    MY_IP = get_ip()
    REMOTE_NICK = rnick # Global para uso en IPC
    
    # Override Global Prompt for Child Windows
    PROMPT = f"\001{Colors.B}\002T√∫: \001{Colors.E}\002"
    
    # Signals for Child
    signal.signal(signal.SIGINT, lambda s, f: handle_child_sigint(cid))
    
    # Estado compartido para Popups
    pop_state = {'last_input': 0, 'last_rx': time.time(), 'pop_off': False, 'type': ctype, 'remote_id': remote}

    # Configurar estado solo para este chat
    ACTIVE_CHATS[cid] = {'type': ctype, 'remote_id': remote, 'pass': password}
    CURRENT_CHAT_ID = cid
    
    # Header Lindo y Titulo de Ventana
    if ctype == 'GROUP':
        header_txt = f"== CHAT GRUPAL {remote} =="
        set_terminal_title(f"GRUP {remote}")
    else:
        # Intentar obtener nick remoto del argumento o peers
        header_txt = f"== CHAT PRIVADO CON {rnick} =="
        set_terminal_title(f"PRIV {rnick}")
        
    print(f"{Colors.H}{header_txt}{Colors.E}")
    # print(f"{Colors.H}--- CHAT {ctype} ({cid}) IPC:{myport} ---{Colors.E}") # Legacy line commented
    
    # Iniciar listener IPC (Chat receive) en puerto UNICO, pasando el estado compartido
    threading.Thread(target=ipc_listen_child, args=(myport, pop_state), daemon=True).start()
    
    # NO iniciar tcp_loop ni udp_loop en hijo (conflicto de puertos)
    
    # Si es grupo, iniciar b√∫squeda/anuncio inmediato
    if ctype == 'GROUP':
        threading.Thread(target=join_grp, args=(remote, password), daemon=True).start()
    elif ctype == 'PRIV':
        if remote not in PEERS: 
             PEERS[remote] = {'nick': rnick, 'chats': {cid}}
        else:
             if isinstance(PEERS[remote], dict): PEERS[remote]['chats'].add(cid)
        send_cmd(remote, "WHOIS", MY_IP) 

    while True:
        try:
            inp = input(PROMPT).strip()
            if not inp: continue
            
            restore_from_afk()
            
            # Actualizar last_input siempre
            pop_state['last_input'] = time.time()
            
            # Resolve command for child
            parts = inp.split(" ", 1)
            raw_cmd = parts[0]
            args = parts[1] if len(parts) > 1 else ""
            cmd_key = resolve_cmd(raw_cmd)

            if cmd_key == 'EXIT':
                print(f"{Colors.W}[*] Saliendo...{Colors.E}")
                # Enviar se√±al de Leave al resto si es necesario
                # Pero la l√≥gica central est√° en leave_sess del Lobby.
                # Aqu√≠ simplemente matamos al hijo y el Lobby manejar√° CHILD_EXIT.
                
                # Pero espera, si matamos al hijo abruptamente, el Lobby solo sabe que muri√≥.
                # Lo mejor es decir al Lobby "Quiero Salir".
                send_ipc(f"FWD_CMD{SEP}{cid}{SEP}--exit", IPC_PORT)
                time.sleep(0.5)
                os._exit(0)         # Comandos Locales de Popups
            elif cmd_key == 'POP_OFF':
                pop_state['pop_off'] = True
                print(f"{Colors.W}[i] Popups DESACTIVADOS (hasta nuevo aviso o 5 min inactividad).{Colors.E}")
                continue
            elif cmd_key == 'POP_ON':
                pop_state['pop_off'] = False
                print(f"{Colors.G}[i] Popups ACTIVADOS.{Colors.E}")
                continue
            
            elif cmd_key == 'FILE':
                 if args: send_file(args)
                 else: print(f"{Colors.F}Falta ruta del archivo.{Colors.E}")
                 continue
            
            elif cmd_key == 'CLEAR':
                os.system('cls' if os.name == 'nt' else 'clear')
                print(f"{Colors.H}--- CHAT {ctype} ({cid}) IPC:{myport} ---{Colors.E}")
                continue

            # Comandos Remotos (Reenviados al Lobby)
            # v34.0: Usamos el sistema de resoluci√≥n del lobby para saber si es v√°lido
            
            # Chequeamos si la primera parte es un comando v√°lido en CMD_MAP
            # O si es --log con args (caso especial)
            potential_cmd_key = resolve_cmd(raw_cmd)
            
            if potential_cmd_key or (raw_cmd == "--log" and len(inp.split())>1):
                 print(f"{Colors.W}[IPC] Enviando comando al Lobby...{Colors.E}")
                 send_ipc(f"FWD_CMD{SEP}{cid}{SEP}{inp}", IPC_PORT)
                 continue
            
            if cmd_key == 'HELP':
                # Usamos la misma ayuda que el lobby, ya que los comandos son reenviados
                show_help()
                print(f"{Colors.W}[!] Nota: Algunos comandos globales mostrar√°n su resultado en la ventana del Lobby.{Colors.E}")
                # print(" --exit / --salir : Salir del chat")
                # print(" --clear          : Limpiar pantalla")
                # print(" (Comandos globales como --estado o --nick se sincronizan con Lobby)")
                continue

            # Si llegamos aqu√≠, es texto normal para el chat
            # print(msg) # Local echo (handled by UI now?) no, input returns.
            # No, we print explicit echo or rely on sync?
            # Standard chat: Local echo immediately.
            # Pero antes enviamos por red.
            
            # Send TCP Msg
            # ... (Resto del c√≥digo original de envio de mensaje)
            
            # print(f"{Colors.WH}T√∫: {inp}{Colors.E}") # Fix double echo
            
            if ctype == 'GROUP':
                 # print(f"{Colors.W}[DEBUG] Enviando mensaje de GRUPO.{Colors.E}")
                 send_cmd_all("GRP_MSG", remote, inp)
            else:
                 # print(f"{Colors.W}[DEBUG] Intentando enviar mensaje PRIVADO a {remote}...{Colors.E}")
                 try:
                     # print(f"{Colors.W}[DEBUG] Llamando a send_all...{Colors.E}")
                     send_all(inp.encode())
                     # print(f"{Colors.W}[DEBUG] send_all completado.{Colors.E}")
                 except Exception as e:
                     print(f"{Colors.F}[DEBUG] ERROR en send_all: {e}{Colors.E}")

        except KeyboardInterrupt:
             # Handle Ctrl+C clean exit from child loop
             send_ipc(f"FWD_CMD{SEP}{cid}{SEP}--exit", IPC_PORT)
             try: sys.exit(0)
             except: os._exit(0)
        except Exception as e:
            print(f"{Colors.F}Error Child: {e}{Colors.E}")

def main():
    # v37.18: Clear debug log on startup (Real location)
    try:
        if "--child" not in sys.argv: # Only lobby clears it
            dsk = get_desktop_path()
            path = os.path.join(dsk, "gwc_lobby_debug.log")
            if os.path.exists(path):
                with open(path, "w") as f: f.write(f"--- NUEVA EJECUCI√ìN {time.ctime()} ---\n")
    except: pass

    # Parsing manual de args para no depender de argparse complejo
    if "--child" in sys.argv:
        try:
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            
            port = sys.argv[sys.argv.index("--port")+1]
            
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Check for silent updates flag passed from parent
            global SILENT_UPDATES_ALLOWED
            # if "--updates-ok" in sys.argv: SILENT_UPDATES_ALLOWED = True 
            # Deprecated flag logic

            run_child(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

if __name__ == "__main__": main()
