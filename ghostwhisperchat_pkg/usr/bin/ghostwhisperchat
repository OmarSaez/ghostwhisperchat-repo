#!/usr/bin/env python3
import os
import sys
import platform
import subprocess
import threading
import time
import socket
import json
import uuid
import re
import signal
import shutil
import unicodedata
import atexit
import ctypes
import urllib.request as request

# ... Imports ...
try:
    import gw_comm
    import gw_shared
    import gw_child
    import gw_pop
except ImportError:
    # Logic for manual path resolution
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. Check system install
    if os.path.exists("/usr/lib/ghostwhisperchat"):
        sys.path.append("/usr/lib/ghostwhisperchat")
    
    # 2. Check repo structure (../lib/ghostwhisperchat relative to bin)
    # script_dir is ".../usr/bin"
    # we want ".../usr/lib/ghostwhisperchat"
    repo_lib = os.path.join(os.path.dirname(script_dir), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
        sys.path.insert(0, repo_lib)

    # 3. Check CWD fallback (Dev root)
    if os.path.exists("ghostwhisperchat_pkg/usr/lib/ghostwhisperchat"):
        sys.path.insert(0, "ghostwhisperchat_pkg/usr/lib/ghostwhisperchat")
        
    try:
        import gw_comm
        import gw_shared
        import gw_child
        import gw_pop
        import gw_display
        import gw_complete
    except ImportError as e:
        print(f"CRITICAL ERROR: Could not import gw_comm/gw_shared module. Paths tried: {sys.path}")
        print(f"Error detail: {e}")
        # Log to file for child process visibility (Desktop)
        dsk = os.path.join(os.path.expanduser("~"), "Desktop")
        if not os.path.exists(dsk): dsk = os.path.join(os.path.expanduser("~"), "Escritorio")
        
        try:
            with open(os.path.join(dsk, "gwc_import_crash.log"), "a") as f:
                f.write(f"[{time.time()}] CRITICAL: Modules import failed. Env: {os.environ.get('PATH')}\n")
                f.write(f"Error: {e}\n")
        except: pass
        sys.exit(1)

# Aliases for compatibility
from gw_shared import Colors, COMMAND_DEFS, resolve_cmd, IPC_PORT, get_ip, calculate_file_hash, APP_VERSION, APP_VER_NUM, APP_VER_TAG, Loader, get_desktop_path, CMD_MAP
SEP = gw_comm.SEP
UDP_PORT = gw_comm.UDP_PORT
TCP_PORT = gw_comm.TCP_PORT
build_packet = gw_comm.build_packet
parse_packet = gw_comm.parse_packet

# ... (Rest of globals) ...

# ... (Functions like spawn_child_process need to use gw_shared vars) ...

def main():
    # ...
    if "--child" in sys.argv:
        try:
            # ... Parse args ...
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            port = sys.argv[sys.argv.index("--port")+1]
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Delegate to Module
            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

# --- CONFIGURACI√ìN ---


multicast_group = ('224.0.0.1', 44496) # Multicast opcional (futuro)
BUFFER, LOG_FILE, CONFIG_FILE = 4096, "cyberdei_history.log", "cyberdei_config.json"



def find_free_port(start_port=5001, max_tries=50):
    for p in range(start_port, start_port + max_tries):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', p))
                return p
        except: continue
    return start_port # Fallback

DL_ROOT = get_desktop_path()
DL_DIR = os.path.join(DL_ROOT, "GhostWhisper_Recibidos")
if not os.path.exists(DL_DIR):
    try: os.makedirs(DL_DIR)
    except: pass
TIMERS = {'PRIV': 60, 'GROUP': 120, 'MANUAL': 300, 'INVITE': 15, 'BAN': 60}

# --- ESTADO PROCESOS ---
IS_CHILD = False
MY_CHILD_ID = None
PARENT_PID = None
CHILD_PROCESSES = {} # {ChatID: {'pid': PID, 'port': Port}} for Parent logic

# --- PILAS DE DATOS ---
PEERS = {}              # CONECTADOS: {IP: {'nick': Nick, 'chats': [ChatID1, ...]}}
PEER_STATUSES = {}      # ESTADOS CONECTADOS: {IP: Status}
KNOWN_USERS = {}        # HISTORIAL: {IP: {'nick': Nick, 'status': Status, 't': time}}
ACTIVE_CHATS = {}       # {ChatID: {'type': 'PRIV'/'GROUP', 'remote_id': ..., 'pass': ..., 'created_at': time}}
CURRENT_CHAT_ID = None

# GROUP_ID, GROUP_PASS = None, None # MOVIDO A ACTIVE_CHATS
MY_IP, MY_NICK, MY_STATUS = "", "An√≥nimo", "En l√≠nea"
DISC_TEMP, SCAN_RESULTS, PENDING_INVITE = [], [], None
POPUP_ON, USER_OFF, LAST_ACT = True, False, 0
HAS_ZENITY = False

def ensure_dependencies():
    """Instala zenity si falta en Linux (Debian/Kali/Ubuntu)"""
    if platform.system() == "Linux" and shutil.which("zenity") is None:
        try:
            print("\033[93m[!] Zenity no detectado. Instalando dependencias visuales...\033[0m")
            # Intentar apt-get silencioso
            subprocess.run(["sudo", "apt-get", "update", "-qq"], check=False)
            subprocess.run(["sudo", "apt-get", "install", "zenity", "-y", "-qq"], check=False)
        except: pass

ensure_dependencies()
HAS_ZENITY = shutil.which("zenity") is not None
AUTO_DL, LOG_ON, PENDING_FILES = True, False, []
VISIBLE_IN_SCAN = True 
SCANNING_NOW = False
SCAN_BUFFER = []
IS_AFK = False 


PROMPT = f"\001{Colors.B}\002Lobby > \001{Colors.E}\002"
print_lock = threading.Lock()

# --- UTILS ---
def set_terminal_title(title):
    """Establece el t√≠tulo de la ventana de la terminal usando secuencias ANSI."""
    if platform.system() == "Windows":
        os.system(f"title {title}")
    else:
        # Secuencia est√°ndar XTerm (funciona en gnome, konsole, xfce, etc)
        sys.stdout.write(f"\x1b]2;{title}\x07")
        sys.stdout.flush()

def normalize_str(s):
    # Quita acentos y pasa a minusculas (ej: S√°ez -> saez)
    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn').lower()

def raw_print(s):
    # Imprime SIN guardar en historial
    # Si es hilo secundario (Async), restauramos el prompt visualmente.
    # Si es Main Thread (Sync), solo imprimimos (el input loop pondr√° el prompt).
    with print_lock:
        if threading.current_thread() is threading.main_thread():
             print(s)
        else:
             try:
                 sys.stdout.write(f'\r\033[K{s}\n' + PROMPT + (readline.get_line_buffer() if 'readline' in sys.modules else ""))
                 sys.stdout.flush()
             except:
                 print(s)

def safe_print(s):
    # Imprime Y guarda en historial (Eventos publicos)
    if gw_display.DISPLAY: gw_display.DISPLAY.add(s)
    raw_print(s)

def reply_print(msg, target_cid=None):
    """
    Imprime en el destino correcto:
    - Si target_cid es None -> Imprime en Lobby (safe_print).
    - Si target_cid existe -> Env√≠a IPC al hijo para que lo muestre.
    """
    if target_cid and target_cid in ACTIVE_CHATS:
        # Enviar al hijo
        cdata = ACTIVE_CHATS[target_cid]
        port = cdata.get('port')
        if port:
            # Usamos MSG_IN con 'Sistema' como remitente
            # Limpiamos colores para IPC? No, el hijo soporta colores.
            send_ipc(f"MSG_IN{SEP}Sistema{SEP}{msg}{SEP}{Colors.C}", port)
        else:
            safe_print(msg) # Fallback
    else:
        safe_print(msg)

def send_ipc(msg, port=IPC_PORT):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(msg.encode(), ('127.0.0.1', int(port)))
    except: pass





def write_log(txt, type="MSG"):
    if LOG_ON:
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                f.write(f"[{datetime.datetime.now().strftime('%F %T')}] [{type}] {txt}\n")
        except: pass

KNOWN_USERS = {} # {ip: {nick, status, t}}
DEBUG_MODE = False # v36.8

# --- UTILS VISUALES ---

def debug_log(msg):
    if DEBUG_MODE:
        s = f"{Colors.M}[DEBUG] {msg}{Colors.E}"
        safe_print(s)
        # v37.13: Persist debug to file
        try:
             dsk = get_desktop_path()
             path = os.path.join(dsk, "gwc_lobby_debug.log")
             with open(path, "a", encoding="utf-8") as f:
                 f.write(f"[{time.time()}] {msg}\n")
        except Exception as e:
             safe_print(f"{Colors.F}[!] Error escribiendo log en disco: {e}{Colors.E}")

# --- PROTOCOLO (Delegado a gw_comm) ---
# --- PROTOCOLO (Delegado a gw_comm) ---
# Funciones redirigidas totalmente al m√≥dulo
def send_cmd(ip, cmd, *args):
    if LOG_ON:
         debug_log(f"[TX] CMD={cmd} DST={ip if ip else 'BCAST'} ARGS={args}")
    gw_comm.send_cmd(ip, cmd, *args)

def send_cmd_all(cmd, *args):
    gw_comm.send_cmd_all(cmd, *args)

def send_raw(ip, d):
    gw_comm.send_tcp_packet(ip, d)

# Popup Logic Delegated to gw_pop
# COLOR LOGIC: Length-Based, Cyclic, No Green (System)
# Colors: C(Cyan), M(Magenta), Y(Yellow), B(Blue), P(Purple), R(Red)
NICK_PALETTE = [Colors.C, Colors.M, Colors.Y, Colors.B, Colors.P, Colors.R]
def get_col(n): 
    if not n: return Colors.WH
    # User requested: Length based cycle
    idx = len(n) % len(NICK_PALETTE)
    return NICK_PALETTE[idx]

# --- CONFIG & STATE ---
    


# --- CONFIG & STATE ---
CONFIG_FILE = "inter_chat.json"
KNOWN_USERS = {} # {ip: {nick, status, t}}
TRUSTED_PEERS = set() # IPs de gente con chat privado exitoso {ip}
TRUSTED_NETS = {} # {network_id: {'trusted': bool, 'last_seen': ts, 'name': str}}
MY_NICK = socket.gethostname()
# ... rest of vars ...
ACTIVE_CHATS = {} # cid -> {type, remote_id, pass, process_handle, port}
PEERS = {} # ip -> {nick, chats: {cid1, cid2}}
PEER_STATUSES = {} # ip -> status_str
# SILENT_UPDATES_ALLOWED removed



def load_config():
    global KNOWN_USERS, MY_NICK, MY_STATUS, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, TRUSTED_NETS, TRUSTED_PEERS
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                d = json.load(f)
                KNOWN_USERS = d.get('known_users', {})
                MY_NICK = d.get('nick', MY_NICK)
                MY_STATUS = d.get('status', "En l√≠nea")
                VISIBLE_IN_SCAN = d.get('visible', True)
                LOG_ON = d.get('log_on', True)
                gw_pop.POP.set_active(d.get('pop_on', True))
                gw_pop.POP.set_active(d.get('pop_on', True))
                AUTO_DL = d.get('auto_dl', True)
                return True
        except: pass
    return False

def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump({
                'known_users': KNOWN_USERS,
                'nick': MY_NICK,
                'status': MY_STATUS,
                'visible': VISIBLE_IN_SCAN,
                'log_on': LOG_ON,
                'pop_on': gw_pop.POP.pop_on,
                'log_on': LOG_ON,
                'pop_on': gw_pop.POP.pop_on,
                'auto_dl': AUTO_DL
            }, f, indent=4)
    except: pass

# --- NETWORK IDENTIFICATION ---
# Funciones get_network_id y check_network_trust ELIMINADAS por solicitud.
# La aplicaci√≥n asume un entorno seguro o gestionado por el usuario.

def show_help(target_cid=None):
    lines = []
    lines.append(f" {Colors.BO}--- AYUDA Y COMANDOS ---{Colors.E}")
    
    cats = {
        "GESTI√ìN DE CHATS": [
            ("--chatpersonal (Nick y/o IP)", "Crear un chat privado con un usuario."),
            ("--chatgrupal ID CLAVE", "Unirse/Crear sala."), 
            ("--invite (Nick1, Nick2...) y/o IPs", "Invitar gente al grupo actual."),
            ("--aceptar / --rechazar", "Responder a invitaciones pendientes."),
            ("--ls", "Listar usuarios CONECTADOS en el chat."), 
            ("--salir", "Desconectar de la sesi√≥n.")
        ],
        "RED Y CONTACTOS": [
            ("--quienes", "Escanear red (¬øQui√©n est√° online?)."),
            ("--contactos", "Ver historial de gente vista."),
            ("--quienes-si / --quienes-no", "Visibilidad en esc√°ner.")
        ],
        "UTILIDADES Y ARCHIVOS": [
            ("--archivo (Ruta)", "Enviar archivo."),
            ("--nombre (NuevoNick)", "Cambiar tu nombre visible."),
            ("--estado (Texto)", "Cambiar estado."),
            ("--estados-globales", "Ver resumen de configuraci√≥n."),
            ("--abreviaciones", "Ver todos los formatos aceptados por cada comando."),
            ("--limpiar", "Limpiar pantalla.")
        ],
        "SISTEMA Y CONFIGURACI√ìN": [
             ("--log on / off", "Guardar historial."),
             ("--descarga-si / --descarga-no", "Control descarga autom√°tica.")
        ]
    }

    for cat_name, cmds in cats.items():
        lines.append(f"\n {Colors.C}:: {cat_name} ::{Colors.E}")
        for c, d in cmds: 
            lines.append(f"   {Colors.BO}{c:<35}{Colors.E} : {d}")

    lines.append("-" * 60)
    
    full_msg = "\n".join(lines)
    if target_cid: reply_print(full_msg, target_cid)
    else: safe_print(full_msg)

def get_peer_name(ip):
    p = PEERS.get(ip)
    if p and isinstance(p, dict):
        return p.get('nick', ip)
    return ip

    """Imprime y guarda en historial para repintado"""
    safe_print(txt)


def get_lobby_status():
    return {
        'ip': MY_IP, 'nick': MY_NICK, 'visible': VISIBLE_IN_SCAN, 
        'status': MY_STATUS, 'chats': len(ACTIVE_CHATS), 
        'contacts': len(KNOWN_USERS),
        'ver': APP_VERSION
    }

def refresh_ui(msg=None):
    if gw_display.DISPLAY: gw_display.DISPLAY.refresh()
    if msg: safe_print(msg)

# --- RED ---
def lazy_import():
    global json, difflib, urllib, unicodedata, request, datetime, uuid
    import json, difflib, datetime, uuid, unicodedata
    import urllib.request as request
    
def get_ip():
    # Optimization: Use a dummy socket to get preferred outgoing IP without actual connection
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            # Google DNS IP (doesn't need to be reachable)
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except:
        return "127.0.0.1"

def fw_cfg():
    if platform.system() == "Linux":
        # 1. Intentar UFW (Ubuntu/Debian standard)
        try:
            for c in [[f"{p}/tcp", f"{p}/udp"] for p in [TCP_PORT, UDP_PORT]]:
                subprocess.run(["sudo", "ufw", "allow"] + c, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
        # 2. Intentar IPTABLES (Kali/RedHat/Arch fallback)
        # sudo iptables -C INPUT -p tcp --dport 44494 -j ACCEPT 2> /dev/null || sudo iptables -A INPUT -p tcp --dport 44494 -j ACCEPT
        try:
            for p, proto in [(TCP_PORT, 'tcp'), (UDP_PORT, 'udp')]:
                rule = ["sudo", "iptables", "-A", "INPUT", "-p", proto, "--dport", str(p), "-j", "ACCEPT"]
                # Check simple para no duplicar (es complejo en python puro, lanzamos el add y que iptables decida si duplica o no)
                # Mejor intentar solo si no existe, pero para simplificar lanzamos append.
                # Si el user no tiene sudo sin pass, fallara silencioso.
                subprocess.run(rule, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
    elif platform.system() == "Windows":
        subprocess.run(["powershell", f"Start-Process cmd -Verb RunAs -ArgumentList '/c netsh advfirewall firewall add rule name=\"CyberDEI\" dir=in action=allow protocol=ANY localport=\"{TCP_PORT},{UDP_PORT}\"'"], shell=True)

# send_raw eliminado (Replaced by alias above)
def send_all(d, targets=None):
    if targets is None:
        # Enviar solo a usuarios del chat actual
        targets = []
        if CURRENT_CHAT_ID:
            for ip, pdata in PEERS.items():
                if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                    targets.append(ip)

    for ip in [i for i in targets if i != MY_IP]: send_raw(ip, d)

# --- DISCOVERY & MEMORY ---
def update_memory(ip, nick, status):
    """Actualiza memoria y guarda en config"""
    global KNOWN_USERS
    now = time.time()
    
    # Detectar cambio de nombre
    old_nick = None
    if ip in KNOWN_USERS:
        old_nick = KNOWN_USERS[ip].get('nick', nick)
    
    KNOWN_USERS[ip] = {'nick': nick, 'status': status, 't': now}
    
    if old_nick and old_nick != nick:
        safe_print(f"{Colors.C}[Info] '{old_nick}' ahora se llama '{nick}'{Colors.E}")
        # Notificar a los hijos (para que en el chat se vea el cambio)
        # Iterar chats activos y enviar mensaje de sistema
        for cid, cdata in ACTIVE_CHATS.items():
            # Si es privado y es con esa IP:
            if cdata['type'] == 'PRIV' and cdata.get('remote_id') == ip:
                 cdata['remote_nick'] = nick # Actualizar metadata interna
                 # Send alert to child
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}El usuario cambio su nombre a {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))
            
            # Si es grupo, avisar tambien (mas complejo filtrar si esta en el grupo, pero avisamos igual si es relevante)
            if cdata['type'] == 'GROUP':
                 # Verificar si IP esta en grupo? Simplificamos: enviamos a todos los grupos activos
                 msg_ipc = f"MSG_IN{SEP}Sistema{SEP}{old_nick} ahora es {nick}{SEP}{Colors.C}"
                 send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{msg_ipc}", cdata.get('port', 0))

    if ip in PEERS:
        if isinstance(PEERS[ip], dict):
             PEERS[ip]['nick'] = nick
    save_config()

def find_global(t):
    target_clean = normalize_str(t)
    
    # 1. Check known
    for ip, d in KNOWN_USERS.items():
        if normalize_str(d['nick']) == target_clean or ip == t: return ip
        
    for ip, p in PEERS.items():
         if isinstance(p, dict) and normalize_str(p.get('nick', '')) == target_clean: return ip
         
    # 2. Discovery UDP
    safe_print(f"{Colors.W}[*] Buscando '{t}'...{Colors.E}")
    global DISC_TEMP
    DISC_TEMP = [] 
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHOIS", t), ('255.255.255.255', UDP_PORT)); u.close()
    
    time.sleep(2)
    
    for res in DISC_TEMP:
        # res = (ip, nick, status)
        # Check MATCH EXACTO (Insensitive)
        if normalize_str(res[1]) == target_clean:
            safe_print(f"{Colors.G}[+] Encontrado: {res[1]} en {res[0]}{Colors.E}")
            return res[0]
            
    safe_print(f"{Colors.F}[X] Usuario '{t}' no encontrado.{Colors.E}")
    
    # --- FUZZY SEARCH / SUGERENCIAS ---
    suggs = set() # (nick, ip)

    # Helper local
    def check_sim(n, ip):
        n_clean = normalize_str(n)
        if target_clean in n_clean: return True # Contenido exacto
        # Similitud > 55%
        if difflib.SequenceMatcher(None, target_clean, n_clean).ratio() > 0.55: return True
        return False

    # 1. Buscar en Resultados UDP
    for res in DISC_TEMP:
        if check_sim(res[1], res[0]): suggs.add((res[1], res[0]))

    # 2. Buscar en Historial Conocidos
    for ip, data in KNOWN_USERS.items():
        if check_sim(data['nick'], ip): suggs.add((data['nick'], ip))

    if suggs:
        safe_print(f"{Colors.W}¬øQuiz√°s quisiste decir?:{Colors.E}")
        for snick, sip in suggs:
            safe_print(f"   > {Colors.BO}{snick}{Colors.E} ({sip})")

    return None

def scan_network(target_cid=None):
    global SCAN_RESULTS
    reply_print(f"{Colors.W}[*] Escaneando red local (1s)...{Colors.E}", target_cid)
    SCAN_RESULTS = []; u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHO_ALL"), ('255.255.255.255', UDP_PORT)); u.close(); time.sleep(1) # Optimizacion 2s -> 1s

    reply_print(f"{Colors.G}[*] Equipos Encontrados ({len(SCAN_RESULTS)}):{Colors.E}", target_cid)
    for res in SCAN_RESULTS:
        reply_print(f"   > {Colors.BO}{res['nick']}{Colors.E} ({res['ip']}) [{res['status']}]", target_cid)
    if not SCAN_RESULTS: reply_print("   (Ninguno visible)", target_cid)

def leave_sess(silent=False, exclude_ip=None, target_cid=None):
    global PEERS, PEER_STATUSES, CURRENT_CHAT_ID
    
    # Si no se especifica CID, usar el global (contexto Lobby)
    cid_to_close = target_cid if target_cid else CURRENT_CHAT_ID
    
    if not cid_to_close or cid_to_close not in ACTIVE_CHATS:
        if not silent: safe_print(f"{Colors.W}[!] Sesi√≥n no v√°lida.{Colors.E}")
        return

    if not silent: safe_print(f"{Colors.W}[*] Cerrando sesi√≥n {cid_to_close}...{Colors.E}")

    # Send disconnect to peers in THIS chat
    c = ACTIVE_CHATS[cid_to_close]
    to_remove = []

    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and cid_to_close in pdata.get('chats', []):
            if ip != exclude_ip:
                if c['type'] == 'GROUP':
                    send_cmd(ip, "LEAVE_GRP", c['remote_id'], MY_NICK)
                else: # PRIV
                    # Use CLOSE_PRIV instead of DISCONNECT_NOW for safer, granular closing
                    send_cmd(ip, "CLOSE_PRIV", MY_NICK, str(time.time()))
            # Remove chat_id linkage
            pdata['chats'].discard(cid_to_close) # Use discard to be safe
            if not pdata['chats']: # Empty, user gone
                to_remove.append(ip)

    for ip in to_remove:
        if ip in PEERS: del PEERS[ip]
        if ip in PEER_STATUSES: del PEER_STATUSES[ip]

    # Matar proceso hijo si existe y no soy yo mismo el hijo suicid√°ndose
    if 'port' in ACTIVE_CHATS[cid_to_close]:
         # Enviamos kill por si acaso, aunque el hijo ya se haya ido
         send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid_to_close]['port'])

    del ACTIVE_CHATS[cid_to_close]
    
    # Si cerr√© la sesi√≥n activa del Lobby, limpiar variable
    if CURRENT_CHAT_ID == cid_to_close:
        CURRENT_CHAT_ID = None
        
    if not silent: safe_print(f"{Colors.G}[‚úî] Sesi√≥n {cid_to_close} cerrada.{Colors.E}")
    refresh_ui()

def start_private_chat(ip, nick, status="En l√≠nea", send_ack=True):
    global CURRENT_CHAT_ID
    cid = str(uuid.uuid4())[:8]
    ACTIVE_CHATS[cid] = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': nick}
    CURRENT_CHAT_ID = cid

    if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
    if isinstance(PEERS[ip], dict):
        PEERS[ip]['nick'] = nick
        PEERS[ip]['chats'].add(cid)

    PEER_STATUSES[ip] = status
    update_memory(ip, nick, status)
    
    if send_ack:
        # v36.12 CRITICAL FIX: Send acceptance to inviter so they open their window!
        debug_log(f"[PROTOCOLO] Enviando INVITE_ACC (Confirmaci√≥n) a {ip}...")
        # V2: INVITE_ACC uses [MPP]
        send_cmd(ip, "INVITE_ACC", get_my_mpp())
    debug_log(f"[PROTOCOLO] INVITE_ACC enviado. Ahora abriendo mi consola...")
    
    spawn_child_process(cid, ACTIVE_CHATS[cid]) # Spawn child immediately
    refresh_ui()
    refresh_ui(f"{Colors.G}[*] Chat privado con {nick} iniciado.{Colors.E}")
    return cid

def join_grp(gid, gp, exclude_ip=None):
    # Ya no salimos de la sesi√≥n anterior forzosamente
    # if PEERS: leave_sess(...) <--- REMOVED

    global CURRENT_CHAT_ID
    global PEERS, PEER_STATUSES

    if not CURRENT_CHAT_ID: return # Should not happen in child context

    safe_print(f"{Colors.G}[*] Conectando a '{gid}'...{Colors.E}")

    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("SEARCH_GROUP", gid, gp, MY_NICK, MY_STATUS), ('255.255.255.255', UDP_PORT)); u.close()

    time.sleep(2)
    # Check if peers found in this chat
    found_any = False
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
            found_any = True
            break

    if found_any:
        safe_print(f"{Colors.G}[‚úî] Unido.{Colors.E}")
        send_cmd_all("JOINED", MY_NICK, MY_STATUS); write_log(f"Grupo {gid}", "SYS")
    else:
        safe_print(f"{Colors.G}[‚úî] Sala creada (esperando peers).{Colors.E}"); write_log(f"Sala {gid}", "SYS")

    # Trigger Update Check on trusted peers in this group
    # Necesitamos la lista de IPs. Si es un join reciente, PEERS se va poblando.
    # Mejor hacerlo tras unos segundos o usar los que ya conocemos que est√°n ah√≠.
    # Disparamos un hilo retardado
    # threading.Thread(target=lambda: (time.sleep(5), try_trigger_updates(list(PEERS.keys())))).start()
    pass

def invite_users(targets_str, target_cid=None):
    cid = target_cid if target_cid else CURRENT_CHAT_ID
    if not cid or cid not in ACTIVE_CHATS:
        return safe_print(f"{Colors.F}[!] Debes estar en un chat activo.{Colors.E}")

    chat = ACTIVE_CHATS[cid]
    if chat['type'] != 'GROUP':
        return safe_print(f"{Colors.F}[!] Solo puedes invitar en grupos.{Colors.E}")

    gid = chat['remote_id']
    gpass = chat['pass']

    targets = [t.strip() for t in targets_str.split(',')]

    members_list = ", ".join([d['nick'] for d in PEERS.values() if isinstance(d, dict) and cid in d.get('chats', [])])
    # payload = f"GRP_INVITE_REQ{SEP}{MY_NICK}{SEP}{gid}{SEP}{gpass}{SEP}{members_list}".encode() # Old

    safe_print(f"{Colors.W}[*] Enviando invitaciones...{Colors.E}")
    count = 0
    for t in targets:
        ip = find_global(t)
        if ip:
            pdata = PEERS.get(ip)
            if pdata and isinstance(pdata, dict) and cid in pdata.get('chats', []):
                 safe_print(f"   > {t}: Ya est√° en el grupo.")
            else:
                send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, members_list)
                safe_print(f"   > {t}: Invitaci√≥n enviada.")
                count += 1
        else:
            gw_complete.suggest_user(t) # Added this line

    if count > 0:
        send_cmd_all("GRP_MSG", gid, f"[Grupo] {MY_NICK} ha invitado a {count} usuarios.")

# --- CORE ---
def set_afk_mode(cause_ip=None, cause_nick=None):
    global MY_STATUS, IS_AFK
    IS_AFK = True
    if not MY_STATUS.endswith("-AFK"): MY_STATUS += "-AFK"
    msg = f"{Colors.W}[!] Solicitud de {Colors.BO}{cause_nick}{Colors.E} {Colors.W}({cause_ip}) auto-rechazada. Entrando en AFK.{Colors.E}" if cause_nick else f"{Colors.W}[!] Timeout. Entrando en AFK.{Colors.E}"
    safe_print(msg); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def restore_from_afk():
    global MY_STATUS, IS_AFK
    if not IS_AFK: return
    IS_AFK = False
    if MY_STATUS == "Ausente (AFK)": MY_STATUS = "En l√≠nea"
    elif MY_STATUS.endswith("-AFK"): MY_STATUS = MY_STATUS[:-4]
    safe_print(f"{Colors.G}[i] Bienvenido de vuelta. Estado: {MY_STATUS}{Colors.E}"); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

    safe_print("\a") # Beep

    # Loop de espera pasiva para CLI
    start_wait = time.time()
    while time.time() - start_wait < 30:
        if PENDING_INVITE is None: return # Respondido
        time.sleep(1)

    # Timeout CLI
    if PENDING_INVITE and PENDING_INVITE['ip'] == ip:
        msg_print(f"{Colors.F}[!] Invitaci√≥n de {nick} expirada.{Colors.E}")
        send_cmd(ip, "INVITE_REJ", MY_NICK, "Timeout")
        PENDING_INVITE = None




# --- UTILS v36.0 ---
def calculate_file_hash(path):
    sha256_hash = hashlib.sha256()
    with open(path, "rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def dl_file(name, size, sock, sender, sender_ip=None, expected_hash=None, file_type='FILE'):
    if not os.path.exists(DL_DIR): os.makedirs(DL_DIR)
    tmp = os.path.join(DL_DIR, f".tmp_{int(time.time())}_{name}")
    try:
        with open(tmp, "wb") as f:
            r = 0
            while r < size:
                ch = sock.recv(min(BUFFER, size-r)); 
                if not ch: break
                f.write(ch); r += len(ch)
    except Exception as e: return safe_print(f"{Colors.F}Error DL: {e}{Colors.E}")

    # v36.0: Integrity Check
    if expected_hash:
        safe_print(f"{Colors.W}[*] Verificando integridad...{Colors.E}")
        cal_hash = calculate_file_hash(tmp)
        if cal_hash != expected_hash:
             safe_print(f"{Colors.F}[X] ERRO INTEGRIDAD: Hash mismatch.{Colors.E}")
             safe_print(f"    Esperado: {expected_hash[:8]}...")
             safe_print(f"    Recibido: {cal_hash[:8]}...")
             os.remove(tmp)
             return
        else:
             safe_print(f"{Colors.G}[‚úî] Integridad verificada.{Colors.E}")

    final_path = os.path.join(DL_DIR, name)
    
    # v36.0: Folder Logic (Si es DIR, es un zip que debemos descomprimir)
    is_zip_archive = (file_type == 'DIR')
    
    if AUTO_DL:
        if os.path.exists(final_path): 
            base, ext = os.path.splitext(name)
            final_path = os.path.join(DL_DIR, f"{base}_copy_{int(time.time())}{ext}")
        
        # Rename or Unzip
        if is_zip_archive:
             # Es un directorio comprimido. Le quitamos la extension .zip al nombre final si la tiene
             folder_final_path = final_path.replace('.zip', '')
             shutil.unpack_archive(tmp, folder_final_path)
             os.remove(tmp) # Borrar zip temporal
             final_path = folder_final_path + " (Carpeta)"
        else:
             os.rename(tmp, final_path)

        safe_print(f"{Colors.G}[‚úî] Archivo guardado: {final_path}{Colors.E}")
        popup(f"De: {sender}", f"Guardado: {name}", source_ip=sender_ip); write_log(f"Recibido {name}", "FILE")
        
        # Notify Local Chat Windows (Feature Request)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         # Send System Notification to Child
                         tag = f"[{Colors.C}üìÅ{Colors.E}]"
                         msg = f"{Colors.C}{sender} ha enviado {'una carpeta' if is_zip_archive else 'un archivo'}: {name}{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

    else:
        # pending files logic, store hash/type for later accept? 
        # For simplicity, we assume if we are here we already accepted stream or stream happens anyway.
        # But wait, logic says "Wait for accept" BUT tcp stream ALREADY downloaded to tmp.
        # So we just keep tmp stored in PENDING_FILES with the metadata.
        PENDING_FILES.append({'t': tmp, 'r': final_path, 's': sender, 'hash': expected_hash, 'type': file_type})
        safe_print(f"{Colors.W}[?] '{name}' de {sender} espera (--aceptar/--rechazar).{Colors.E}"); popup("Archivo", f"{sender}: {name}", source_ip=sender_ip)
        
        # Notify Local Chat Windows (Manual Wait)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         tag = f"[{Colors.C}üìÅ{Colors.E}]"
                         msg = f"{Colors.C}{sender} env√≠a archivo: {name}. Escribe --aceptar.{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

# --- COMANDOS LOBBY CENTRALIZADOS ---
def exec_lobby_cmd(inp, origin_cid=None):
    import gw_cmd
    gw_cmd.process(inp, origin_cid, LOBBY_ADAPTER)

class LobbyAdapter:
    def reply(self, msg, cid):
        # Lobby context reply
        if not cid: safe_print(msg)
        else:
             # Support CLI response
             if cid.startswith("CLI:"):
                 try:
                     _, rip, rport = cid.split(":")
                     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                     s.sendto(str(msg).encode(), (rip, int(rport)))
                     s.close()
                 except: pass
                 return

             if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                  # Forward as System Message
                  # Format: MSG_IN | Sender | Text | Color
                  send_ipc(f"MSG_IN{gw_comm.SEP}Sistema{gw_comm.SEP}{msg}{gw_comm.SEP}{Colors.C}", ACTIVE_CHATS[cid]['port'])
             else:
                  safe_print(msg)

    def create_group(self, remote_id, password):
        # UX: Animation "Connecting"
        with Loader(f"{Colors.C}[*] Sincronizando grupo '{remote_id}'{Colors.E}"):
             time.sleep(3.5)
             
             # 1. Create Local Session
             cid = str(uuid.uuid4())[:8]
             cdata = {
                'type': 'GROUP', 'remote_id': remote_id, 'pass': password, 
                'created_at': time.time(), 'remote_nick': f"Grupo {remote_id}"
             }
             ACTIVE_CHATS[cid] = cdata
        
             # 2. Spawn Child
             threading.Thread(target=spawn_child_process, args=(cid, cdata)).start()
        
             # 3. Network Discovery (V2)
             # Search (Find others to populate my list)
             gw_comm.send_cmd(None, "SEARCH_GROUP", get_my_mpp(), remote_id, password)
             
             # Announce Presence (Tell others to add me)
             # This triggers the JOIN_GROUP handler on peers (Fix Blind Join)
             time.sleep(0.5) # Wait a bit for sockets
             gw_comm.send_cmd(None, "JOIN_GROUP", get_my_mpp(), remote_id, password)
             gw_comm.send_cmd(None, "JOIN_GROUP", get_my_mpp(), remote_id, password) # Redundancy
             
        # Restore Prompt
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def find_global(self, args): return find_global(args)

    def join_group(self, cid): pass # Unused, create_group handles join logic

    def invite_priv(self, ip, nick, status):
        # V2 Logic + Loader
        with Loader(f"{Colors.C}[*] Conectando con {nick} ({ip})...{Colors.E}"):
             time.sleep(1.5)
             gw_comm.send_cmd(ip, "INVITE", get_my_mpp(), "PRIV")
        
        sys.stdout.write(PROMPT)
        sys.stdout.flush()

    def get_chat(self, cid): return ACTIVE_CHATS.get(cid)
    def get_my_info(self): return MY_NICK, MY_IP, MY_STATUS
    def get_mpp(self): return get_my_mpp()
    def get_peers(self): return PEERS
    
    def show_lobby_summary(self):
         safe_print(f"{Colors.G}--- RESUMEN DE RED ---{Colors.E}")
         safe_print(f"Total de Usuarios Conocidos: {len(PEERS) + 1}")
         safe_print(f"{Colors.BO} > {MY_NICK} ({MY_IP}) [Yo]{Colors.E}")
         for ip, d in PEERS.items():
             est = d.get('status','?') # PEERS structure update V40
             # In V40 we use PEERS[ip] = {nick, ver, status?}
             # Fallback to PEER_STATUSES[ip] if simpler
             est = PEER_STATUSES.get(ip, est)
             n = d.get('nick', '?')
             safe_print(f" - {n} ({ip}) [{est}]")
             
         safe_print(f"\n{Colors.G}Sesiones de Chat Activas ({len(ACTIVE_CHATS)}):{Colors.E}")
         for cid, d in ACTIVE_CHATS.items():
             safe_print(f" - [{cid}] {d['type']}: {d.get('remote_nick', d['remote_id'])}")

    def get_known_users(self): 
        # Merge Saved (KNOWN_USERS) + Runtime (PEERS)
        ku = KNOWN_USERS.copy()
        for ip, d in PEERS.items():
            ku[ip] = {
                'nick': d.get('nick','?'), 
                'status': PEER_STATUSES.get(ip, d.get('status', '?')), 
                't': time.time()
            }
        return ku

    def scan_network(self, cid):
        def _scan_task():
            global SCANNING_NOW, SCAN_BUFFER, PEERS
            SCAN_BUFFER = []
            SCANNING_NOW = True
            
            # 1. Purge Ghosts (Fresh Scan Logic)
            # Remove peers not involved in local chats
            to_remove = [ip for ip, d in PEERS.items() if not d.get('chats')]
            for ip in to_remove: 
                if ip in PEERS: del PEERS[ip]

            initial_peers = len(PEERS)
            
            # Send Broadcast
            gw_comm.send_cmd_all("WHOIS", get_my_mpp())
            
            # Animation Wait (3s)
            if not cid:
                with Loader(f"{Colors.C}[*] Escaneando red{Colors.E}"):
                    time.sleep(3)
            else:
                time.sleep(3)
                
            SCANNING_NOW = False
            
            # Flush Buffer
            for m in SCAN_BUFFER:
                if cid: self.reply(m, cid)
                else: safe_print(m)
            
            # SHOW DETAILED LIST
            if PEERS:
                msg_list = [f"{Colors.G}--- RESULTADOS EN RED ({len(PEERS)}) ---{Colors.E}"]
                for ip, d in PEERS.items():
                    msg_list.append(f" - {d.get('nick','?')} ({ip}) [{d.get('status','?')}]")
                final_msg = "\n".join(msg_list)
                self.reply(final_msg, cid)
            else:
                self.reply(f"{Colors.W}[!] No se detectaron nodos activos.{Colors.E}", cid)
            
            # Check delta (Optional Summary)
            final_peers = len(PEERS)
            new_found = final_peers - initial_peers
            if new_found > 0:
                 self.reply(f"{Colors.G}[+] {new_found} nuevos.{Colors.E}", cid)

            # Restore Prompt if in Lobby
            if not cid:
                sys.stdout.write(PROMPT)
                sys.stdout.flush()
        
        threading.Thread(target=_scan_task, daemon=True).start()

    def check_integrity(self, cid):
        report = []
        report.append(f"{Colors.H}=== REPORTE DE INTEGRIDAD ({APP_VERSION}) ==={Colors.E}")
        
        # 1. DEPENDENCIAS
        deps = [("zenity", "Interfaz de Ventanas"), ("python3", "Motor Python"), ("fuser", "Gestor Procesos")]
        report.append(f"\n{Colors.BO}:: Dependencias del Sistema ::{Colors.E}")
        for bin_name, desc in deps:
            found = shutil.which(bin_name)
            st = f"{Colors.G}OK{Colors.E}" if found else f"{Colors.F}‚ö†Ô∏è FALTA{Colors.E}"
            report.append(f" - {desc} ({bin_name}): {st}")

        # 2. PUERTOS (Daemon Health)
        report.append(f"\n{Colors.BO}:: Estado de Puertos (Daemon) ::{Colors.E}")
        ports = [
            (gw_comm.TCP_PORT_PRIV, "TCP Privado (Mensajer√≠a)"),
            (gw_comm.UDP_PORT_DISC, "UDP Discovery (Escaneo)"),
            (gw_comm.TCP_PORT_GRP,  "TCP Mesh (Grupos)")
        ]
        
        for p, d in ports:
             report.append(f" - Puerto {p} ({d}): {Colors.G}EN ESCUCHA{Colors.E}")

        # 3. INTERNALS
        report.append(f"\n{Colors.BO}:: Subsistema IPC & Hijos ::{Colors.E}")
        report.append(f" - IPC Port: {IPC_PORT}")
        
        child_ok_count = 0
        for xcid, xcdata in ACTIVE_CHATS.items():
            if 'pid' in xcdata:
                 try: 
                     os.kill(xcdata['pid'], 0)
                     child_ok_count += 1
                 except: pass
        
        st_child = f"{Colors.G}OK{Colors.E}" if child_ok_count == len(ACTIVE_CHATS) else f"{Colors.W}Mismatch{Colors.E}"
        report.append(f" - Hijos Activos: {len(ACTIVE_CHATS)} (Vivos: {child_ok_count})")
        report.append(f" - Estado General Hijos: {st_child}")

        # 2. SISTEMA DE ARCHIVOS
        report.append(f"\n{Colors.BO}:: Sistema de Archivos ::{Colors.E}")
        
        # Config Dir
        log_dir = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
        if not os.path.exists(log_dir):
            try: os.makedirs(log_dir); st_fs = f"{Colors.G}OK (Creado){Colors.E}"
            except: st_fs = f"{Colors.F}ERROR (No se pudo crear){Colors.E}"
        else:
            if os.access(log_dir, os.W_OK): st_fs = f"{Colors.G}OK (W){Colors.E}"
            else: st_fs = f"{Colors.F}FALLO (R-O){Colors.E}"
        report.append(f" - Config (~/.ghostwhisperchat): {st_fs}")

        # Downloads Dir
        dl_dir = os.path.join(get_desktop_path(), "GhostWhisperChat_Descargas")
        if not os.path.exists(dl_dir):
             try: os.makedirs(dl_dir); st_dl = f"{Colors.G}OK (Creada){Colors.E}"
             except: st_dl = f"{Colors.F}ERROR (No se pudo crear){Colors.E}"
        else:
             if os.access(dl_dir, os.W_OK): st_dl = f"{Colors.G}OK (W){Colors.E}"
             else: st_dl = f"{Colors.F}FALLO (Solo Lectura){Colors.E}"
        report.append(f" - Descargas (~/Escritorio/GhostWhisperChat_Descargas): {st_dl}")

        # 3. RED
        report.append(f"\n{Colors.BO}:: Estado de Red ::{Colors.E}")
        my_ip_detected = get_ip()
        if my_ip_detected == "127.0.0.1": 
             st_net = f"{Colors.W}ALERTA (Loopback){Colors.E}"
        else:
             st_net = f"{Colors.G}OK{Colors.E}"
        report.append(f" - IP Detectada: {my_ip_detected} -> {st_net}")

        # 4. ENTORNO GR√ÅFICO & TERMINAL
        report.append(f"\n{Colors.BO}:: Entorno Gr√°fico ::{Colors.E}")
        
        # Detect Desktop Environment
        de = os.environ.get("XDG_CURRENT_DESKTOP", os.environ.get("DESKTOP_SESSION", "?"))
        report.append(f" - Entorno de Escritorio: {de}")

        # Zenity Test
        try:
             zver = subprocess.check_output(["zenity", "--version"], stderr=subprocess.DEVNULL).decode().strip()
             report.append(f" - Zenity: {Colors.G}OK (v{zver}){Colors.E}")
        except:
             report.append(f" - Zenity: {Colors.F}FALLO{Colors.E}")

        # Popup Test (Direct notify-send)
        if shutil.which("notify-send"):
            try:
                # Test directo sin wrapper gw_pop
                cmd_pop = ["notify-send", "-u", "critical", "-t", "5000", "GWC Integridad", "Test de Notificaci√≥n Visible"]
                res = subprocess.run(cmd_pop, capture_output=True, text=True)
                
                if res.returncode == 0:
                     st_pop = f"{Colors.G}OK (Enviado a DBus){Colors.E}"
                else: 
                     st_pop = f"{Colors.F}FALLO (Exit {res.returncode}: {res.stderr.strip()}){Colors.E}"
            except Exception as e:
                st_pop = f"{Colors.F}ERROR CALL ({e}){Colors.E}"
        else:
            st_pop = f"{Colors.F}FALTA (Instala libnotify-bin){Colors.E}"
        
        report.append(f" - Notificaciones (notify-send): {st_pop}")
        
        
        # Terminal Selection Logic (Mirrored from spawn_child_process)
        term_bin = None
        de_chk = str(de).upper()
        
        # 1. Prioridad por Entorno de Escritorio
        if "MATE" in de_chk and shutil.which("mate-terminal"):
             term_bin = "mate-terminal"
        elif "GNOME" in de_chk and shutil.which("gnome-terminal"):
             term_bin = "gnome-terminal"
        elif "XFCE" in de_chk and shutil.which("xfce4-terminal"):
             term_bin = "xfce4-terminal"
        elif "KDE" in de_chk and shutil.which("konsole"):
             term_bin = "konsole"
        
        # 2. Fallback
        if not term_bin:
             if shutil.which("mate-terminal"): term_bin = "mate-terminal"
             elif shutil.which("gnome-terminal"): term_bin = "gnome-terminal"
             elif shutil.which("tilix"): term_bin = "tilix"
             elif shutil.which("terminator"): term_bin = "terminator"
             elif shutil.which("konsole"): term_bin = "konsole"
             elif shutil.which("xfce4-terminal"): term_bin = "xfce4-terminal"
             elif shutil.which("qterminal"): term_bin = "qterminal"
             elif shutil.which("xterm"): term_bin = "xterm"
             elif shutil.which("x-terminal-emulator"): term_bin = "x-terminal-emulator"
        
        found_term = term_bin
        
        if found_term:
             report.append(f" - Terminal Detectada: {Colors.G}{found_term}{Colors.E} (Prioridad DE)")
             
             try:
                 # TEST LIVE: Intentar abrir una ventana que sobreviva 3 segundos
                 cmd_test = []
                 sleep_cmd = "sleep 3" 
                 
                 # 3. Construir comando test
                 if found_term == "gnome-terminal":
                     cmd_test = [found_term, "--wait", "--", "sh", "-c", sleep_cmd]
                 elif found_term == "mate-terminal":
                     cmd_test = [found_term, "--disable-factory", "--", "sh", "-c", sleep_cmd]
                 elif found_term == "tilix":
                     cmd_test = [found_term, "-e", "sh", "-c", sleep_cmd]
                 elif found_term == "terminator":
                      cmd_test = [found_term, "-x", "sh", "-c", sleep_cmd]
                 elif found_term == "konsole":
                      cmd_test = [found_term, "--nofork", "-e", "sh", "-c", sleep_cmd]
                 elif found_term == "xfce4-terminal":
                      cmd_test = [found_term, "--disable-server", "--", "sh", "-c", sleep_cmd]
                 elif found_term == "qterminal":
                      cmd_test = [found_term, "-e", "sh", "-c", sleep_cmd]
                 elif found_term == "xterm":
                      cmd_test = [found_term, "-e", f"sh -c '{sleep_cmd}'"]
                 else:
                      cmd_test = [found_term, "-e", f"sh -c '{sleep_cmd}'"]
                 
                 report.append(f"   ‚Ü≥ Tecnolog√≠a: {found_term}")
                 report.append(f"   ‚Ü≥ Comando Test: {' '.join(cmd_test)}") 

                 # Ejecutar test
                 p = subprocess.Popen(cmd_test, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                 
                 # Dar tiempo visible (2s)
                 time.sleep(2.0) 
                 
                 ret = p.poll()
                 if ret is not None:
                     # Si termin√≥ antes de 3s:
                     if ret != 0: st_spawn = f"{Colors.F}FALLO (Exit Code {ret}){Colors.E}"
                     else: st_spawn = f"{Colors.W}OK? (Cerr√≥ antes de 3s - ¬øFalta --wait o flag incompatible?){Colors.E}"
                 else:
                     # Sigue corriendo. Exitoso.
                     p.kill() # Limpiar
                     st_spawn = f"{Colors.G}EXITOSO (Ventana persistente detectada){Colors.E}"

             except Exception as e:
                 st_spawn = f"{Colors.F}ERROR ({e}){Colors.E}"

             report.append(f" - Test de Consola Hija: {st_spawn}")
             if "FALLO" in st_spawn or "ERROR" in st_spawn:
                 report.append(f"   {Colors.W}‚Ü≥ Sugerencia: Faltan librer√≠as gr√°ficas o DISPLAY mal configurado.{Colors.E}")
             
        else:
             report.append(f" - Terminal: {Colors.F}NO DETECTADA{Colors.E}")
             report.append(f"   {Colors.W}‚Ü≥ Instala: sudo apt install gnome-terminal (o mate-terminal / xterm){Colors.E}")
        
        # 5. SEGURIDAD (Firewall)
        report.append(f"\n{Colors.BO}:: Diagn√≥stico de Firewall ::{Colors.E}")
        
        # Check UFW
        fw_warn = False
        if shutil.which("ufw"):
             try:
                 # Check status (needs sudo usually, but let's try or handle error)
                 ufw_st = subprocess.check_output(["ufw", "status"], stderr=subprocess.STDOUT).decode().strip()
                 if "inactive" in ufw_st.lower():
                     inf_fw = f"{Colors.G}UFW: Inactivo (Permitido){Colors.E}"
                 elif "active" in ufw_st.lower():
                     inf_fw = f"{Colors.W}UFW: ACTIVO (Puede bloquear conexiones entrantes){Colors.E}"
                     fw_warn = True
                 else:
                     inf_fw = f"UFW: {ufw_st}"
             except Exception:
                 inf_fw = f"{Colors.W}UFW: Detectado (Estado desconocido / Sin Permisos){Colors.E}"
                 fw_warn = True
             
             report.append(f" - {inf_fw}")
        else:
             report.append(f" - UFW: No instalado (Check iptables manualmente)")
             
        if fw_warn:
             report.append(f"   {Colors.W}‚Ü≥ SOLUCI√ìN PARROT/KALI: Ejecuta el siguiente comando para abrir puertos:{Colors.E}")
             report.append(f"     {Colors.BO}sudo ufw allow 44494:44496/tcp && sudo ufw allow 44494:44496/udp{Colors.E}")
        
        self.reply("\n".join(report), cid)
    
    def set_config(self, key, val):
        global VISIBLE_IN_SCAN, MY_STATUS, MY_NICK, LOG_ON, AUTO_DL, USER_OFF
        if key == 'visible': VISIBLE_IN_SCAN = val
        elif key == 'status': MY_STATUS = val
        elif key == 'nick': MY_NICK = val
        elif key == 'log_on': LOG_ON = val

        elif key == 'auto_dl': AUTO_DL = val
        save_config()
        refresh_ui()

    def broadcast_status(self, st=None): 
        # V2 STATUS_UPDATE: [CMD]STATUS_UPDATE|1|[MPP][CMD]
        # MPP already contains new Status/Nick
        gw_comm.send_cmd(None, "STATUS_UPDATE", get_my_mpp())

    def update_title(self): set_terminal_title(f"GWC Lobby - {MY_NICK}")
    def toggle_autostart(self, val, cid): toggle_autostart(val, cid)
    
    def clear_screen(self, cid):
        if gw_display.DISPLAY: gw_display.DISPLAY.history = []
        if cid: self.reply(f"{Colors.G}Pantalla limpiada.{Colors.E}", cid)
        else: refresh_ui()

    def suggest_command(self, invalid):
        if gw_complete.COMPLETER:
             sugs = gw_complete.COMPLETER.suggest_command(invalid)
             if sugs:
                 safe_print(f"{Colors.W}Comando no encontrado. Quiz√°s quisiste decir:{Colors.E}")
                 for s in sugs: safe_print(f"  - {s}")
             else:
                 safe_print(f"{Colors.W}Comando no encontrado. Prueba --help.{Colors.E}")
    
    def suggest_user(self, invalid):
        if gw_complete.COMPLETER:
             sugs = gw_complete.COMPLETER.suggest_user(invalid)
             if sugs:
                 safe_print(f"{Colors.W}Usuario no encontrado. Quiz√°s buscas a:{Colors.E}")
                 for s in sugs: safe_print(f"  - {s}")

    def invite_users(self, args_str, cid):
        # Logic V2: Parse args (Nick/IPs) -> Send INVITE
        targets = args_str.replace(",", " ").split()
        
        # UX Animation
        if not cid:
             # Only loader if inside Lobby (otherwise child does its own thing or stream interrupts)
             # But if User types help in child, here we are in LobbyAdapter?
             # invite_users from Child passes cid.
             # If cid is active, Loader inside Lobby text is weird for child user.
             # Child user expects reply "Invitando...".
             pass
        
        # Universal Loader if CID is None (Lobby Command)
        if not cid:
            loader = Loader(f"{Colors.C}[*] Enviando invitaciones{Colors.E}")
            loader.__enter__()
            time.sleep(1.5)
        
        for t in targets:
            # Check if IP or Nick
            target_ip = None
            if "." in t and len(t.split(".")) == 4: target_ip = t
            else:
                # Resolve Nick
                for ip, p in PEERS.items():
                    if p.get('nick') == t: target_ip = ip; break
            
            if target_ip:
                inv_type = "PRIV"
                extras = []
                if cid and cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'GROUP':
                     inv_type = "GROUP"
                     gid = ACTIVE_CHATS[cid]['remote_id']
                     gp = ACTIVE_CHATS[cid].get('pass', '')
                     extras = [gid, gp]
                     
                gw_comm.send_cmd(target_ip, "INVITE", get_my_mpp(), inv_type, *extras)
                self.reply(f"{Colors.G}[‚ûú] Invitaci√≥n enviada a {t} ({target_ip}){Colors.E}", cid)
            else:
                self.reply(f"{Colors.R}[X] No encontrado: {t}{Colors.E}", cid)
                self.suggest_user(t)
        
        if not cid:
            loader.__exit__(None, None, None)
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def send_file(self, args, cid): send_file(args, target_cid=cid)
    def leave_sess(self, cid): leave_sess(target_cid=cid)
    def shutdown_app(self): shutdown_lobby()
    
    def handle_accept(self, cid):
        global PENDING_INVITE
        if not PENDING_INVITE: return reply_print(f"{Colors.W}No tienes invitaciones pendientes.{Colors.E}", cid)
        
        restore_from_afk() # Restore status if we were AFK
        
        # UX Animation (Only if Lobby)
        if not cid:
            with Loader(f"{Colors.C}[*] Sincronizando sesi√≥n{Colors.E}"):
                time.sleep(1.5)
        else:
             reply_print(f"{Colors.G}[*] Aceptando...{Colors.E}", cid)

        if PENDING_INVITE['type'] == 'GROUP':
             self.create_group(PENDING_INVITE['data'][0], PENDING_INVITE['data'][1])
             
             # Force TCP JOIN to Inviter (Guaranteed Delivery vs UDP Broadcast)
             try:
                 inviter_ip = PENDING_INVITE['ip']
                 gid, gpass = PENDING_INVITE['data'][0], PENDING_INVITE['data'][1]
                 gw_comm.send_cmd(inviter_ip, "JOIN_GROUP", get_my_mpp(), gid, gpass)
                 debug_log(f"[ACEPTAR] Enviado JOIN_GROUP TCP directo a {inviter_ip}")
             except: pass

             self.reply(f"{Colors.G}[*] Grupo creado/unido.{Colors.E}", cid)
        else:
             start_private_chat(PENDING_INVITE['ip'], PENDING_INVITE.get('nick','?'))
        PENDING_INVITE = None
        
        # Restore prompt if Lobby
        if not cid:
            sys.stdout.write(PROMPT)
            sys.stdout.flush()

    def handle_deny(self, cid):
        global PENDING_INVITE
        if PENDING_INVITE:
             reply_print(f"{Colors.W}[*] Invitaci√≥n rechazada.{Colors.E}", cid)
             send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Rechazado")
             PENDING_INVITE = None
        else:
             reply_print(f"{Colors.W}Nada que rechazar.{Colors.E}", cid)

    def get_var(self, name):
        if name == 'visible': return VISIBLE_IN_SCAN
        if name == 'auto_dl': return AUTO_DL

        if name == 'log_on': return LOG_ON
        return None

    def get_active_chats(self): return ACTIVE_CHATS
    def get_version_str(self): return APP_VERSION
    
    def show_contacts(self, cid):
        users = self.get_known_users()
        self.reply(f"{Colors.G}[*] Historial de Sesi√≥n ({len(users)}):{Colors.E}", cid)
        for ip, d in users.items(): 
            msg = f"   - {d['nick']} ({ip}) [{d['status']}] (Visto: {time.strftime('%H:%M', time.localtime(d['t']))})"
            self.reply(msg, cid)

    def show_global_status(self, cid):
        import gw_cmd
        gw_cmd.show_global_status(self, cid)

    def toggle_debug(self):
        global DEBUG_MODE
        DEBUG_MODE = not DEBUG_MODE
        # Logic from command
        # dsk = get_desktop_path()... we assume caller handles logging the toggle status via reply
        return DEBUG_MODE

LOBBY_ADAPTER = LobbyAdapter()

# --- PROCESOS & LOBBY ---

def check_child_health():
    """Vigila si los procesos hijos siguen vivos. Si no, limpia la sesi√≥n."""
    while True:
        time.sleep(2) # v37.26: Faster check (2s)
        to_kill = []
        for cid, data in list(ACTIVE_CHATS.items()):
            if 'pid' in data:
                pid = data['pid']
                try:
                    # Check if process exists (signal 0 does nothing but checks access)
                    os.kill(pid, 0)
                except OSError:
                    # Process died
                    to_kill.append(cid)
                    
        for cid in to_kill:
             if cid in ACTIVE_CHATS:
                 cdata = ACTIVE_CHATS[cid]
                 rem_nick = cdata.get('remote_nick', cdata.get('remote_id', '?'))
                 type_s = cdata.get('type', '?')
                 
                 safe_print(f"\n{Colors.W}[Info] Se detect√≥ cierre de ventana ({type_s}: {rem_nick}). Limpiando sesi√≥n...{Colors.E}")
                 
                 # v37.26: Use consistent disconnect logic
                 # Using leave_sess logic manually here to avoid modifying dict while iterating if leave_sess does strange things,
                 # but actually leave_sess removes from ACTIVE_CHATS.
                 # Let's replicate safe leave logic:
                 
                 # Avisar al remoto si es privado
                 if cdata['type'] == 'PRIV':
                     if 'remote_id' in cdata:
                         send_cmd(cdata['remote_id'], "DISCONNECT_NOW", MY_NICK)
                 elif cdata['type'] == 'GROUP':
                     if 'remote_id' in cdata:
                          send_cmd_all("LEAVE_GRP", cdata['remote_id'], MY_NICK)
                 
                 # Remove local
                 del ACTIVE_CHATS[cid]

def spawn_child_process(cid, cdata):
    # Asignar puerto √∫nico para este hijo (IPC)
    # Buscamos puerto libre o usamos hash/incremental
    child_port = IPC_PORT + 1
    # Optimization: Limited search range
    for i in range(100): 
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', child_port))
            break # Free
        except: child_port += 1
    
    cdata['port'] = child_port
    rnick = cdata.get('remote_nick', '?')

    script_path = os.path.abspath(sys.argv[0])
    
    # Create Child Environment with correct PYTHONPATH for source execution
    child_env = os.environ.copy()
    repo_lib = os.path.join(os.path.dirname(os.path.dirname(script_path)), "lib", "ghostwhisperchat")
    if os.path.exists(repo_lib):
         old_pp = child_env.get("PYTHONPATH", "")
         child_env["PYTHONPATH"] = f"{repo_lib}{os.pathsep}{old_pp}" if old_pp else repo_lib
    
    cmd_args = [
        sys.executable, script_path, 
        "--child", cid,
        "--type", cdata['type'],
        "--remote", cdata['remote_id'],
        "--pass", str(cdata['pass']),
        "--nick", MY_NICK,
        "--status", MY_STATUS,
        "--port", str(child_port),
        "--rnick", rnick
    ]
    
    # CRITICAL FIX for Parrot/MATE & Others: Wrap in shell to handle args correctly
    import shlex
    inner_cmd = " ".join([shlex.quote(str(x)) for x in cmd_args])
    shell_wrapper = ["sh", "-c", f"exec {inner_cmd}"] # exec to replace shell pid

    debug_log(f"Spawn start ({time.time()}) CMD: {inner_cmd}")
    
    # Detectar terminal con inteligencia situacional (DE Aware)
    try:
        terminal_cmd = None
        de = os.environ.get("XDG_CURRENT_DESKTOP", "").upper()
        term_bin = None
        
        # 1. Prioridad por Entorno de Escritorio
        if "MATE" in de and shutil.which("mate-terminal"):
             term_bin = "mate-terminal"
        elif "GNOME" in de and shutil.which("gnome-terminal"):
             term_bin = "gnome-terminal"
        elif "XFCE" in de and shutil.which("xfce4-terminal"):
             term_bin = "xfce4-terminal"
        elif "KDE" in de and shutil.which("konsole"):
             term_bin = "konsole"
        
        # 2. Fallback: B√∫squeda general (Orden de preferencia ajustado para Parrot)
        if not term_bin:
             if shutil.which("mate-terminal"): term_bin = "mate-terminal" # Parrot priority
             elif shutil.which("gnome-terminal"): term_bin = "gnome-terminal"
             elif shutil.which("tilix"): term_bin = "tilix"
             elif shutil.which("terminator"): term_bin = "terminator"
             elif shutil.which("konsole"): term_bin = "konsole"
             elif shutil.which("xfce4-terminal"): term_bin = "xfce4-terminal"
             elif shutil.which("qterminal"): term_bin = "qterminal"
             elif shutil.which("xterm"): term_bin = "xterm"
             elif shutil.which("x-terminal-emulator"): term_bin = "x-terminal-emulator"
        
        # 3. Construir comando seg√∫n binario elegido
        if term_bin == "gnome-terminal":
            terminal_cmd = ["gnome-terminal", "--wait", "--"] + shell_wrapper
        elif term_bin == "mate-terminal":
             terminal_cmd = ["mate-terminal", "--disable-factory", "--"] + shell_wrapper
        elif term_bin == "tilix":
             terminal_cmd = ["tilix", "-e"] + shell_wrapper
        elif term_bin == "terminator":
             terminal_cmd = ["terminator", "-x", "sh", "-c", inner_cmd]
        elif term_bin == "konsole":
             terminal_cmd = ["konsole", "--nofork", "-e"] + shell_wrapper
        elif term_bin == "xfce4-terminal":
             terminal_cmd = ["xfce4-terminal", "--disable-server", "--"] + shell_wrapper
        elif term_bin == "qterminal":
             terminal_cmd = ["qterminal", "-e"] + shell_wrapper
        elif term_bin == "xterm":
             terminal_cmd = ["xterm", "-e"] + shell_wrapper
        elif term_bin == "x-terminal-emulator":
             terminal_cmd = ["x-terminal-emulator", "-e"] + shell_wrapper
        
        if terminal_cmd:
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            try:
                 dlog = open(log_path, "a")
                 dlog.write(f"\n[{time.time()}] Launching Primary: {' '.join(terminal_cmd)}\n")
                 proc = subprocess.Popen(terminal_cmd, stdout=dlog, stderr=dlog, env=child_env)
            except:
                 proc = subprocess.Popen(terminal_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, env=child_env)
            
            time.sleep(0.5)
            poll_res = proc.poll()
            
            if poll_res is not None and poll_res != 0:
                print(f"{Colors.F}[!] Error: La terminal fall√≥ (Code {proc.returncode}).{Colors.E}")
                # Fallback to background
                log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
                with open(log_path, "a") as err_log:
                    # Also pass env to fallback
                    proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid
        else:
            print(f"{Colors.F}[!] No se encontr√≥ terminal compatible.{Colors.E}")
            log_path = os.path.join(get_desktop_path(), "gwc_child_error.log")
            with open(log_path, "a") as err_log:
                proc = subprocess.Popen(cmd_args, stdout=err_log, stderr=err_log, env=child_env)
            ACTIVE_CHATS[cid]['pid'] = proc.pid

        # Feedback
        if cdata['type'] == 'GROUP':
            gid = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir√° una nueva consola para el chat grupal {gid}.{Colors.E}")
        else:
            target = cdata.get('remote_nick', '?')
            if target == '?': target = cdata.get('remote_id', '?')
            reply_print(f"{Colors.G}[*] Se abrir√° una nueva consola para el chat privado con {target}.{Colors.E}") 

    except Exception as e:
        print(f"{Colors.F}[!] Error lanzando terminal: {e}{Colors.E}")

# --- CONFIG POP ---
# Limits from gw_shared are used: POP_RESET_TIME, MAX_POPS_BURST
CHAT_ACTIVITY = {} # cid -> {'last': t, 'pops': n}

def check_pop_allowance(cid):
    now = time.time()
    if cid not in CHAT_ACTIVITY:
         CHAT_ACTIVITY[cid] = {'last': now, 'pops': 0}
         return True # First ever
         
    dt = now - CHAT_ACTIVITY[cid]['last']
    CHAT_ACTIVITY[cid]['last'] = now # Update activity timestamp
    
    if dt > gw_shared.POP_RESET_TIME:
         # Reset counter
         CHAT_ACTIVITY[cid]['pops'] = 0
    
    if CHAT_ACTIVITY[cid]['pops'] < gw_shared.MAX_POPS_BURST:
         CHAT_ACTIVITY[cid]['pops'] += 1
         return True
    
    return False

def register_outgoing_activity(cid):
    # Called when Child sends a msg (via CMD_ACTIVITY)
    # Simply updates timestamp, keeping conversation "Active"
    # This suppression prevents pops if I am replying.
    now = time.time()
    if cid not in CHAT_ACTIVITY: CHAT_ACTIVITY[cid] = {'last': now, 'pops': gw_shared.MAX_POPS_BURST} # Assume active
    else: CHAT_ACTIVITY[cid]['last'] = now

def ipc_listen_parent():
    global ACTIVE_CHATS
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: u.bind(('127.0.0.1', IPC_PORT))
    except: return print(f"{Colors.F}[!] Error binding IPC {IPC_PORT}{Colors.E}")
    
    while True:
        try:
            d, _ = u.recvfrom(4096); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "CHILD_EXIT":
                cid = p[1]
                if cid in ACTIVE_CHATS:
                    # v37.26 Fix: Notify peers correctly before local deletion
                    # Using leave_sess ensures DISCONNECT_NOW/LEAVE_GRP is sent.
                    leave_sess(target_cid=cid, silent=False) 
                    refresh_ui()
            
            elif cmd == "CLI_CMD":
                # CLI_CMD | ReturnIP | ReturnPort | CommandStr
                if len(p) >= 4:
                    rip, rport, cstr = p[1], p[2], p[3]
                    # Create a virtual CID for CLI
                    cli_sig = f"CLI:{rip}:{rport}"
                    try:
                        # Ejecutar comando como si fuera el lobby, pero redirigiendo output
                        exec_lobby_cmd(cstr, origin_cid=cli_sig)
                        # Opcional: Enviar ACK de fin?
                    except Exception as e:
                        try:
                            s_err = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                            s_err.sendto(f"{Colors.F}Error procesando comando: {e}{Colors.E}".encode(), (rip, int(rport)))
                        except: pass

            elif cmd == "CMD_SYNC_PEERS":
                # Child requests sync. Send all known peers.
                if len(p) >= 2:
                    req_cid = p[1]
                    if req_cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[req_cid]:
                         cport = ACTIVE_CHATS[req_cid]['port']
                         # Send all known peers
                         for ip, pg in PEERS.items():
                              nick = pg.get('nick', '?')
                              payload = f"CMD_ADD_PEER{SEP}{ip}{SEP}{nick}"
                              send_ipc(payload, cport)

            elif cmd == "FWD_CMD":
                if len(p) >= 3:
                     cstr = p[2]
                     # print(f"\n{Colors.M}[IPC] Ejecutando comando remoto: {cstr}{Colors.E}")
                     exec_lobby_cmd(cstr, origin_cid=p[1])
            
            elif cmd == "CMD_ACTIVITY":
                # Child reporting activity (User Typed)
                if len(p) >= 2:
                    register_outgoing_activity(p[1])

        except Exception as e:
            debug_log(f"[IPC_ERROR] Error en listener IPC del Lobby: {e}")

def ipc_listen_child(my_port, lock_state):
    # lock_state es un dict compartido con el thread principal del hijo para leer/escribir estado de POPs
    global MY_CHILD_ID
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try: u.bind(('127.0.0.1', int(my_port)))
    except Exception as e: 
        print(f"Error bind child IPC: {e}")
        return
    
    while True:
        try:
            d, _ = u.recvfrom(8192); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "FWD_MSG":
                if len(p) >= 4:
                    cid, tag, text = p[1], p[2], p[3]
                    if cid == MY_CHILD_ID:
                        safe_print(f"{tag}: {text}") 
                        
                        # LOGICA SMART POPUP
                        now = time.time()
                        last_in = lock_state.get('last_input', 0)
                        last_rx = lock_state.get('last_rx', 0)
                        manual_off = lock_state.get('pop_off', False)
                        ctype = lock_state.get('type', 'PRIV')
                        
                        # Actualizamos last_rx AHORA (actividad reciente en el chat)
                        lock_state['last_rx'] = now
                        
                        should_pop = False

                        # 1. Chequeo Manual Override (Prioridad Alta)
                        if manual_off:
                            # Si activado 'mute', solo suena si pasaron 5 mins (300s) de TOTAL SILENCIO previo
                            # Ojo: last_rx se acaba de actualizar, asi que comparamos con el last_rx *antes* de este msg?
                            # El usuario dijo: "pasan 5 minutos sin actividad... se vuelven a activar".
                            # Significa que si entre el mensaje ANTERIOR y ESTE pasaron > 300s, reactivamos.
                            if (now - last_rx) > TIMERS['MANUAL']:
                                lock_state['pop_off'] = False # Reactivar
                                safe_print(f"{Colors.W}[i] Popups reactivados por inactividad prolongada.{Colors.E}")
                                should_pop = True
                        else:
                            # 2. Chequeo Smart (Solo si no escrib√≠ yo recientemente)
                            limit = TIMERS['PRIV'] if ctype == 'PRIV' else TIMERS['GROUP']
                            if (now - last_in) > limit:
                                should_pop = True
                        
                        if should_pop:
                             # Limpiar colores (ANSI escape codes) PRIMERO
                             # Si quitamos corchetes antes, rompemos la secuencia \033[...m
                             ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                             
                             tag_clean = ansi_escape.sub('', tag)
                             text_clean = ansi_escape.sub('', text)
                             
                             # Ahora sacar los corchetes decorativos del tag
                             sender_clean = tag_clean.replace('[','').replace(']','')
                             
                             title = ""
                             if ctype == 'GROUP':
                                 # Necesitamos el ID del grupo
                                 rid = lock_state.get('remote_id', '?')
                                 title = f"Mensaje grupal ({rid}) de {sender_clean}"
                             else:
                                 title = f"Mensaje privado de {sender_clean}"

                             popup(title, text_clean)

            elif cmd == "FWD_FILE":
                if len(p) >= 4 and p[1] == MY_CHILD_ID:
                    safe_print(f"{Colors.W}[‚á©] Archivo '{p[3]}' de {p[2]} recibido en Lobby.{Colors.E}")
            
            elif cmd == "FWD_PEER":
                if len(p) >= 4:
                    rmt_ip, rmt_nick, rmt_stat = p[1], p[2], p[3]
                    if rmt_ip not in PEERS: PEERS[rmt_ip] = {'nick': rmt_nick, 'chats': {MY_CHILD_ID}}
                    else: 
                         if isinstance(PEERS[rmt_ip], dict):
                             PEERS[rmt_ip]['nick'] = rmt_nick
                             PEERS[rmt_ip]['chats'].add(MY_CHILD_ID)
                    safe_print(f"{Colors.G}[+] Detectado: {rmt_nick}{Colors.E}")
            
            elif cmd == "CMD_CLOSE_NOW":
                # Fuerza cierre (ej: peer desconectado en privado)
                # Usamos global REMOTE_NICK seteada en run_child
                safe_print(f"\n{Colors.F}[üíî] {REMOTE_NICK} ha abandonado el chat.{Colors.E}")
                # print(f"\n{Colors.F}[!] Cierre remoto: {p[1] if len(p)>1 else ''}{Colors.E}")
                time.sleep(3)
                # No mandamos exit signal propia para evitar bucle, solo salimos
                os._exit(0)

        except: pass

def shutdown_lobby():
    # Animated Exit
    with Loader(f"{Colors.W}[*] Cerrando todas las sesiones y saliendo{Colors.E}"):
        
        # 1. Notificar a peers remotos (Global Disconnect)
        active_targets = []
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and pdata.get('chats'):
                 active_targets.append(ip)

        for ip in active_targets:
            # send_cmd legacy compatible or V2?
            # V2 DISCONNECT_ALL: [CMD]DISCONNECT_ALL|1|[MPP][CMD]
            # send_cmd wrapper handles MPP?
            # send_cmd(ip, cmd, *args) -> build_cmd
            # If we reuse old DISCONNECT_NOW for compatibility
            send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
            
        # 2. Cerrar hijos locales
        for cid, cdata in list(ACTIVE_CHATS.items()):
            if 'port' in cdata:
                # Mandar se√±al de cierre suicida al hijo
                send_ipc("CMD_CLOSE_NOW", cdata['port'])
        
        time.sleep(1.0) # Dar tiempo a que salgan los mensajes

    restore_terminal()
    print(f"\n{Colors.G}[‚úî] Todo cerrado. Hasta luego.{Colors.E}")
    sys.exit(0)

def restore_terminal():
    """Restaura el eco de la terminal en Linux si se perdi√≥"""
    if platform.system() != "Windows":
        os.system("stty echo")

# Asegurar restauraci√≥n al salir brusco
atexit.register(restore_terminal)


def liberate_ports():
    """Detecta y elimina procesos zombies ocupando nuestros puertos"""
    ports = [TCP_PORT, UDP_PORT]
    try:
        if platform.system() == "Linux":
            for p in ports:
                subprocess.run(f"fuser -k {p}/tcp", shell=True, stderr=subprocess.DEVNULL)
                subprocess.run(f"fuser -k {p}/udp", shell=True, stderr=subprocess.DEVNULL)
        elif platform.system() == "Windows":
             for p in ports:
                 try:
                     r = subprocess.check_output(f"netstat -ano | findstr :{p}", shell=True, stderr=subprocess.DEVNULL).decode(errors='ignore')
                     lines = r.strip().split('\n')
                     for line in lines:
                         parts = line.split()
                         if len(parts) > 4:
                             pid = parts[-1]
                             if pid != "0": # No matar System
                                 subprocess.run(f"taskkill /F /PID {pid}", shell=True, stderr=subprocess.DEVNULL)
                 except: pass
    except: pass

def enable_win_visuals():
    """Fuerza UTF-8 y ANSI Colors en consola de Windows"""
    if platform.system() == "Windows":
        try:
            # 1. UTF-8
            os.system("chcp 65001 > nul") 
            # 2. ANSI VT100
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except: pass

# --- CONFIGURACI√ìN & MAIN ---

def get_complete_ctx():
    """Context provider for Autocomplete"""
    return {
        'known_users': KNOWN_USERS,
        'peers': PEERS,
        'scan_buffer': SCAN_BUFFER # v41.0 Buffer de escaneo
    }

def init_completer():
    """Inicializa autocompletado inteligente v2 (gw_complete)"""
    if platform.system() != "Windows":
        if gw_complete.setup(get_complete_ctx):
             safe_print(f"{Colors.G}[‚úî] Autocompletado Inteligente activado (TAB).{Colors.E}")
        else:
             safe_print(f"{Colors.W}[!] Autocompletado no disponible.{Colors.E}")

def get_my_mpp():
    """Genera mi [MPP] actualizado"""
    # IP, Nick, Status, Version
    return gw_comm.build_mpp(MY_IP, MY_NICK, MY_STATUS, APP_VERSION)


def handle_afk_timeout():
    """Called by Zenity when timeout expires"""
    global MY_STATUS, PENDING_INVITE
    safe_print(f"{Colors.W}[AFK] Invitaci√≥n expirada. Pasando a modo Ausente.{Colors.E}")
    
    # 1. Update Status
    if "-AFK" not in MY_STATUS:
        reason = "Ausente"
        # Avoid circular import or global mess, use adapter if possible or direct
        LOBBY_ADAPTER.set_config('status', f"{reason}-AFK")
        LOBBY_ADAPTER.broadcast_status(f"{reason}-AFK")
        safe_print(f"{Colors.F}[AFK] Estado cambiado a 'Ausente-AFK'.{Colors.E}")
    
    # 2. Reject and Clean Invite
    if PENDING_INVITE:
         # Inform Sender
         gw_comm.send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Ausente (AFK)")
         PENDING_INVITE = None


def restore_from_afk():
    """Checks if we are AFK and restores original status on activity"""
    global MY_STATUS
    if "-AFK" in MY_STATUS:
        original = MY_STATUS.replace("-AFK", "").replace("Ausente", "En l√≠nea") 
        # Si era "Ausente-AFK", restauramos a "En l√≠nea" por defecto, o limpiamos el suffix
        
        LOBBY_ADAPTER.set_config('status', original)
        LOBBY_ADAPTER.broadcast_status(original)
        safe_print(f"{Colors.G}[AFK] Actividad detectada. Estado restaurado a '{original}'.{Colors.E}")


def handle_v2_logic(pkt_type, cmd_name, args, source_ip):
    """Central V2 Logic: Process Parsed Packet"""
    import gw_pop
    if source_ip == MY_IP: return # Prevent Self-Loop
    
    try:
        # Extract MPP if present (Most commands have it as Arg 0)
        sender_mpp = None
        if len(args) > 0:
            sender_mpp = gw_comm.extract_mpp(args[0])
            
        # Update Knowledge Base (Auto-Discovery)
        if sender_mpp:
            # MPP always contains Nick/Status. Update Knowledge.
            if source_ip not in PEERS: PEERS[source_ip] = {'chats': set()}
            PEERS[source_ip]['nick'] = sender_mpp['nick']
            PEERS[source_ip]['ver']  = sender_mpp['ver']
            PEERS[source_ip]['status'] = sender_mpp['status'] # Fix [?] in scan
            PEER_STATUSES[source_ip] = sender_mpp['status']
            
            # Persistencia Autom√°tica + Refresh solo si es nuevo (evitar parpadeo)
            is_new = source_ip not in KNOWN_USERS
            update_memory(source_ip, sender_mpp['nick'], sender_mpp['status'])
            if is_new: refresh_ui()
            
        if pkt_type == 'CMD':
            debug_log(f"[V2] CMD: {cmd_name} Args: {len(args)}")
            
            if cmd_name == "SEARCH_GROUP":
                # Args: [MPP], GID, PASS
                if len(args) < 3: return
                gid, gpass = args[1], args[2]
                
                # Check if I have this group
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid and cdata['pass'] == gpass:
                        # Found! Send I_EXIST
                        local_ls = [] 
                        ls_pkt = gw_comm.build_ls(local_ls)
                        gw_comm.send_cmd(source_ip, "I_EXIST", get_my_mpp(), gid, gpass, ls_pkt)
                        debug_log(f"[V2] Respondido I_EXIST a {source_ip} por grupo {gid}")
                        break
            
            elif cmd_name == "JOIN_GROUP":
                # Args: [MPP], GID, PASS
                # Critical Fix: Register peer immediately when they join
                if len(args) < 3: return
                gid = args[1].strip()
                gpass = args[2].strip()
                
                debug_log(f"[V2] JOIN_GROUP de {sender_mpp['nick']} ({source_ip}) -> '{gid}'")
                
                found_match = False
                for cid, cdata in ACTIVE_CHATS.items():
                    # Normalize pass (None -> "")
                    my_pass = cdata.get('pass', '')
                    if my_pass is None: my_pass = ""
                    req_pass = gpass if gpass else ""
                    
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                        # Check pass
                        if my_pass == req_pass:
                            found_match = True
                            if 'port' in cdata:
                                 # Add Peer Logic
                                 payload = f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}"
                                 send_ipc(payload, cdata['port'])
                                 
                                 # Visual Notification
                                 sys_msg = f"{Colors.G}[+] {sender_mpp['nick']} se ha unido al grupo.{Colors.E}"
                                 ipc_msg = f"MSG_IN{gw_comm.SEP}[SYSTEM]{gw_comm.SEP}{sys_msg}{gw_comm.SEP}{Colors.C}"
                                 send_ipc(ipc_msg, cdata['port'])
                                 
                                 # HANDSHAKE: Send Welcome Back
                                 gw_comm.send_cmd(source_ip, "WELCOME_GROUP", gid)
                        else:
                             debug_log(f"[V2] JOIN_GROUP Pass Mismatch. Local: '{my_pass}', Remote: '{req_pass}'")
                
                if not found_match:
                     debug_log(f"[V2] JOIN_GROUP ignorado: No encuentro grupo '{gid}' activo.")


            elif cmd_name == "INVITE":
                # Args: [MPP], TYPE (PRIV/GROUP), [GID, PASS]
                if len(args) < 2: return
                itype = args[1]
                
                global PENDING_INVITE
                PENDING_INVITE = {
                    'ip': source_ip, 'nick': sender_mpp['nick'], 
                    'type': 'GROUP' if itype == 'GROUP' else 'PRIV',
                    'data': args[2:] if len(args)>2 else None,
                    'ts': time.time()
                }
                
                if itype == "PRIV":
                    msg_text = f"üí¨ ¬°Hey! {sender_mpp['nick']} ({source_ip}) quiere iniciar una conversaci√≥n contigo.\n\n¬øTe gustar√≠a aceptar la conexi√≥n?"
                    log_text = f"{sender_mpp['nick']} te invita a un Chat Privado"
                else:
                    gid = args[2] if len(args)>2 else '?'
                    msg_text = f"üì¢ {sender_mpp['nick']} quiere que formes parte del grupo \"{gid}\".\n\n¬øTe unes a la conversaci√≥n?"
                    log_text = f"{sender_mpp['nick']} te invita a un Chat Grupal '{gid}'"

                safe_print(f"{Colors.G}[!] {log_text}. Responde en el popup o usa --aceptar.{Colors.E}")
                
                # Interactive Popup via gw_pop
                gw_pop.POP.show_question("Invitaci√≥n Entrante", msg_text,
                                       lambda: LOBBY_ADAPTER.handle_accept(None) if LOBBY_ADAPTER else None,
                                       lambda: LOBBY_ADAPTER.handle_deny(None) if LOBBY_ADAPTER else None,
                                       on_timeout=handle_afk_timeout,
                                       timeout=gw_shared.AFK_TIMEOUT)
                
                sys.stdout.write('\a') # Beep

            elif cmd_name == "SEARCH_GROUP":
                # Args: [MPP], GID, PASS
                if len(args) < 2: return
                gid = args[1]; gp = args[2] if len(args)>2 else ""
                
                # Check for match in active groups
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid and cdata.get('pass','') == gp:
                        # Found match!
                        
                        # 1. Reply I_EXIST (Discovery)
                        gw_comm.send_cmd(source_ip, "I_EXIST", gid, gp, "LS_DATA?")
                        
                        # 2. Add Peer Logic (Mesh)
                        if 'port' in cdata:
                             payload = f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}"
                             send_ipc(payload, cdata['port'])
                             
                             # 3. Notify User Joined (Chat Event)
                             msg = f"[+] {sender_mpp['nick']} ({source_ip}) se uni√≥ al grupo."
                             send_ipc(f"MSG_IN{gw_comm.SEP}Sistema{gw_comm.SEP}{msg}{gw_comm.SEP}{Colors.G}", cdata['port'])

                        # Only reply for one matching chat
                        break

            elif cmd_name == "I_EXIST":
                 # Args: [MPP], GID, PASS
                 if len(args) < 3: return
                 gid = args[1]
                 
                 debug_log(f"[V2] I_EXIST recibido de {source_ip} (Grupo {gid})")
                 
                 for cid, cdata in ACTIVE_CHATS.items():
                     if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                          if 'port' in cdata:
                               # Add them to my list
                               send_ipc(f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}", cdata['port'])
                               
                               # VITAL: Notify them via TCP that I joined
                               # This ensures they see the "[+] User joined" message even if UDP Broadcast failed
                               gw_comm.send_cmd(source_ip, "JOIN_GROUP", gid, cdata.get('pass',''))
                               debug_log(f"[I_EXIST] Enviado JOIN_GROUP TCP a {source_ip}")

            elif cmd_name == "WELCOME_GROUP":
                 # Confirmation from Host
                 gid = args[1]
                 safe_print(f"{Colors.G}[‚úî] Conexi√≥n confirmada con grupo '{gid}'.{Colors.E}")

            elif cmd_name == "INVITE_REJ":
                 # Args: [MPP], Reason
                 reason = args[1] if len(args) > 1 else "Rechazado"
                 safe_print(f"{Colors.R}[X] Invitaci√≥n rechazada por {sender_mpp['nick']}: {reason}{Colors.E}")
                 # Notificar visualmente
                 gw_pop.POP.show(f"Invitaci√≥n Rechazada", f"{sender_mpp['nick']} rechaz√≥:\n{reason}", 5)
            
            elif cmd_name == "GRP_MSG":
                # Args: [MPP], GID, TEXT
                if len(args) < 3: return
                gid, text = args[1], args[2]
                
                # Route to compatible chats
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                         # 1. Auto-Add Sender to Peers (Mesh Fix)
                         if 'port' in cdata:
                             payload = f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}"
                             send_ipc(payload, cdata['port'])

                         # 2. Forward Message
                         tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                         ipc_payload = f"MSG_IN{gw_comm.SEP}{cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{text}"
                         if 'port' in cdata:
                             send_ipc(ipc_payload, cdata['port'])
                         
            elif cmd_name == "INVITE_ACC":
                # Args: [MPP]
                # Invitee accepted. Start chat without sending ACK back.
                safe_print(f"{Colors.G}[!] {sender_mpp['nick']} acept√≥ tu invitaci√≥n.{Colors.E}")
                start_private_chat(source_ip, sender_mpp['nick'], sender_mpp['status'], send_ack=False)

            elif cmd_name == "WHOIS":
                 # V2 Scan Request
                 if VISIBLE_IN_SCAN:
                     gw_comm.send_cmd(source_ip, "IAM_HERE", get_my_mpp())

            elif cmd_name == "LEAVE_GROUP":
                 # Args: [MPP], GID, PASS
                 if len(args) < 2: return
                 gid = args[1]
                 # Safe Nick
                 snick = sender_mpp['nick'] if sender_mpp else f"? ({source_ip})"
                 # Notify relevant group chats
                 for cid, cdata in ACTIVE_CHATS.items():
                     if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                          if 'port' in cdata:
                               # Logic Removal (Printing delegated to Child to avoid duplicates)
                               send_ipc(f"CMD_DEL_PEER{gw_comm.SEP}{source_ip}", cdata['port'])

            elif cmd_name == "CLOSE_PRIV" or cmd_name == "DISCONNECT_NOW":
                # Args: [MPP], NICK, [TIMESTAMP]
                snick = sender_mpp['nick'] if sender_mpp else f"? ({source_ip})"
                
                # Check Timestamp to avoid killing new sessions with old packets
                pkt_ts = float(args[1]) if len(args) > 1 and args[1].replace('.','',1).isdigit() else time.time()
                
                # Find Priv chat
                to_remove = []
                for cid, cdata in ACTIVE_CHATS.items():
                     if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                         # Validating Timing
                         created_at = cdata.get('created_at', 0)
                         if pkt_ts < created_at:
                             debug_log(f"[RACE FIX] Ignorando {cmd_name} viejo de {snick}. PktTs: {pkt_ts} < Created: {created_at}")
                             continue
                             
                         safe_print(f"{Colors.F}[!] {snick} cerr√≥ el chat privado.{Colors.E}")
                         if 'port' in cdata:
                              send_ipc("CMD_CLOSE_NOW", cdata['port'])
                         to_remove.append(cid)
                
                for cid in to_remove:
                    del ACTIVE_CHATS[cid]
                if to_remove: refresh_ui()

            elif cmd_name == "IAM_HERE":
                 # Scan Response. MPP Parser already updated PEERS.
                 # Just notify User.
                 msg = f"{Colors.G}[+] Detectado: {sender_mpp['nick']} ({source_ip}){Colors.E}"
                 
                 # Broadcast to all children
                 # (Restored for --quienes visibility inside chats)
                 # Note: CMD_ADD_PEER does NOT add to group roster, only to known peers list.
                 for c_id, c_data in ACTIVE_CHATS.items():
                     if 'port' in c_data:
                          send_ipc(f"CMD_ADD_PEER{gw_comm.SEP}{source_ip}{gw_comm.SEP}{sender_mpp['nick']}", c_data['port'])

                 if SCANNING_NOW:
                      SCAN_BUFFER.append(msg)
                 else:
                      safe_print(msg)



        elif pkt_type == 'MSJ':
            # Args: MPP, TYPE, [PKG_ID, GID/DEST...], LEN, BODY
            # Last arg is BODY.
            msg_body = args[-1]
            msg_type = cmd_name # parse_packet returns Subtype as name for MSJ
            
            debug_log(f"[V2] MSJ {msg_type} de {sender_mpp['nick']}: {msg_body}")
            
            # Routing Logic
            target_cid = None
            
            if msg_type == 'PRIV':
                # Route by IP map
                # Find chat with remote_id == source_ip
                for cid, cdata in ACTIVE_CHATS.items():
                    if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                         target_cid = cid; break
                         
            elif msg_type == 'GRUP':
                # Route by GID (Arg 3 usually: MPP|GRUP|PKID|GID)
                if len(args) >= 4:
                    gid = args[3]
                    for cid, cdata in ACTIVE_CHATS.items():
                         if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                              target_cid = cid; break
            
            if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                # Forward to Child
                # Format: FWD_MSG<SEP>CID<SEP>TAG<SEP>BODY
                tag = f"[{get_col(sender_mpp['nick'])}{sender_mpp['nick']}{Colors.E}]"
                
                # V2 IPC uses same FWD_MSG or new?
                # Let's reuse FWD_MSG for compatibility with gw_child v39
                full_ipc = f"FWD_MSG{gw_comm.SEP}{target_cid}{gw_comm.SEP}{tag}{gw_comm.SEP}{msg_body}"
                send_ipc(full_ipc, ACTIVE_CHATS[target_cid]['port'])
                
                # SMART POP LOGIC (User Request: Anti-Spam)
                if check_pop_allowance(target_cid):
                     try:
                         # Show Pop-up
                         import gw_pop
                         # Determine context for title
                         ctx = "Grupo" if msg_type == 'GRUP' else "Privado"
                         title = f"{ctx}: {sender_mpp['nick']}"
                         gw_pop.show(title, msg_body, duration=4)
                     except: pass
            else:
                 debug_log(f"[V2] Drop MSJ: No Chat Found for {source_ip}")

    except Exception as e:
        safe_print(f"Err V2 Logic: {e}")


# --- FUNCIONES DE ACTUALIZACI√ìN ---
def perform_system_update():
    """Ejecuta los comandos de sistema para actualizar"""
    safe_print(f"{Colors.M}[*] Ejecutando actualizaci√≥n de sistema...{Colors.E}")
    try:
        cmd = "sudo apt update && sudo apt install ghostwhisperchat --only-upgrade -y"
        subprocess.run(cmd, shell=True, check=True)
        safe_print(f"{Colors.G}[‚úî] Actualizaci√≥n lista. Reiniciando servicio...{Colors.E}")
        subprocess.run("systemctl --user restart ghostwhisperchat", shell=True)
        time.sleep(2)
        os.execv(sys.executable, ['python3'] + sys.argv)
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error en actualizaci√≥n: {e}{Colors.E}")

def trigger_manual_update():
    perform_system_update()

def get_rx_folder():
    base = os.path.join(os.path.expanduser("~"), "Desktop")
    if not os.path.exists(base): base = os.path.join(os.path.expanduser("~"), "Escritorio")
    if not os.path.exists(base): base = os.path.expanduser("~") 
    
    rx = os.path.join(base, "GhostWhisper_Recibidos")
    if not os.path.exists(rx): os.makedirs(rx, exist_ok=True)
    return rx

def handle_incoming_file(conn, args, source_ip):
    # Args: Filename, Size, Hash, Type, ...
    if len(args) < 2: return
    fname, fsize = args[0], int(args[1])
    ftype = args[3] if len(args)>3 else 'FILE'
    
    # Notify Start logic?
    safe_print(f"{Colors.C}[‚¨á] Recibiendo archivo '{fname}' ({fsize} bytes) de {source_ip}...{Colors.E}")
    
    dest_path = os.path.join(get_rx_folder(), fname)
    
    # Receive Loop
    recvd = 0
    try:
        with open(dest_path, "wb") as f:
            while recvd < fsize:
                chunk_size = min(4096, fsize - recvd)
                data = conn.recv(chunk_size)
                if not data: break
                f.write(data)
                recvd += len(data)
                
        safe_print(f"{Colors.G}[‚úî] Archivo guardado en: {dest_path}{Colors.E}")
        
        # Notify Children (via broadcast FWD_FILE?)
        # Search relevant child to notify?
        # File transfer is TCP P2P (Priv usually).
        # We can notify all or search for private chat with source_ip.
        
        notify_cid = None
        sender_nick = "?"
        # Try to resolve nick
        if source_ip in PEERS: sender_nick = PEERS[source_ip].get('nick','?')

        # send IPC to all children or specific? 
        # FWD_FILE format: FWD_FILE | CID(Target) | SenderNick | Filename
        # Child IPC expects: cmd == "FWD_FILE": if len(p) >= 4 and p[1] == MY_CHILD_ID: ...
        
        for cid, cdata in ACTIVE_CHATS.items():
            if cdata['type'] == 'PRIV' and cdata['remote_id'] == source_ip:
                 if 'port' in cdata:
                     # Correct CID found
                     send_ipc(f"FWD_FILE{gw_comm.SEP}{cid}{gw_comm.SEP}{sender_nick}{gw_comm.SEP}{fname}", cdata['port'])
                 break
        
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error recibiendo archivo: {e}{Colors.E}")

def handle_v2_priv(conn, ip, raw):
    """TCP 44494: Privado, Control y Archivos"""
    if LOG_ON: debug_log(f"[RX TCP PRIV] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    
    if parsed[0] == 'CMD' and parsed[1] == 'FILE_TRANSFER':
        # Handover to File Handler
        # Takes ownership of Stream
        handle_incoming_file(conn, parsed[2], ip)
        return False # Listener closes socket after we return?
        # Our handler consumed the stream. Listener can close safely.
        
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

def handle_v2_disc(data, ip):
    """UDP 44495: Discovery"""
    if LOG_ON:
         try: dstr = data.decode('utf-8', errors='ignore').strip()
         except: dstr = f"<Bytes {len(data)}>"
         debug_log(f"[RX UDP DISC] {ip}: {dstr}")

    parsed = gw_comm.parse_packet(data)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)

def handle_v2_grp(conn, ip, raw):
    """TCP 44496: Group Mesh"""
    if LOG_ON: debug_log(f"[RX TCP GRP] {ip}: {raw.strip()}")
    parsed = gw_comm.parse_packet(raw)
    if parsed[0] != 'ERR':
        handle_v2_logic(parsed[0], parsed[1], parsed[2], ip)
    return False

# --- GLOBALS ---
LOBBY_ADAPTER = None



def run_lobby():
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE, LOBBY_ADAPTER
    # atexit.register(lambda: print(f"{Colors.W}Lobby cerrado.{Colors.E}")) # Reemplazado por shutdown manual
    
    # Self-Healing Checks
    enable_win_visuals()
    liberate_ports()
    
    # Capturar Ctrl+C en Lobby para shutdown limpio
    import signal
    signal.signal(signal.SIGINT, lambda s, f: shutdown_lobby())
    
    lazy_import() # Load heavy libraries only when needed (Lobby or Child)
    global hashlib
    import hashlib # v36.0 Integrity check
    
    # Init Display Manager
    gw_display.DISPLAY = gw_display.DisplayManager(get_lobby_status)

    adapter = LobbyAdapter()
    LOBBY_ADAPTER = adapter # Expose globally for callbacks
    os.system('cls' if os.name == 'nt' else 'clear'); fw_cfg(); MY_IP = get_ip()
    set_terminal_title(f"GWC Lobby - {MY_NICK}")
    
    # Kali/Network Check
    if MY_IP.startswith("127.") and platform.system() == "Linux":
         print(f"{Colors.W}[!] ADVERTENCIA: IP local ({MY_IP}) detectada.{Colors.E}")
         print(f"{Colors.W}[!] Si usas Kali Linux, verifica que no est√©s en 'Modo Monitor' (airmon-ng stop wlan0).{Colors.E}")
         print(f"{Colors.W}[!] La visibilidad en red estar√° limitada.{Colors.E}")
         time.sleep(3)
    
    global PROMPT
    PROMPT = f"{Colors.B}Lobby > {Colors.E}"
    
    val_nick = MY_NICK if MY_NICK.strip() else socket.gethostname()
    
    if not load_config():
        while True:
            try: 
                if n := input("Tu Nickname: ").strip(): MY_NICK = n; break
            except: sys.exit()
        save_config()
    else:
        # Fallback if config loaded empty nick
        if not MY_NICK.strip(): MY_NICK = socket.gethostname()
    
    # SILENT_UPDATES_ALLOWED logic removed
    pass

    refresh_ui() # Clean start with Dashboard
    
    # Aseguramos limpieza al inicio tambi√©n por si acaso
    # Aseguramos limpieza al inicio tambi√©n por si acaso
    restore_terminal()
    
    # Setup Autocomplete (v41.0)
    init_completer()

    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    # v37.23 Modular Logic - Start Listeners via gw_comm
    # v40.0 Protocol V2 Listeners
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_PRIV, handle_v2_priv)
    gw_comm.start_udp_listener(gw_comm.UDP_PORT_DISC, handle_v2_disc)
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_GRP,  handle_v2_grp)
    
    threading.Thread(target=check_child_health, daemon=True).start() # Health check
    
    check_repo_update()

    while True:
        try:
            inp = input(f"{Colors.B}Lobby > {Colors.E}").strip()
            if inp and gw_display.DISPLAY:
                 gw_display.DISPLAY.add(f"{Colors.B}Lobby > {Colors.E}{inp}")
            
            restore_from_afk()
            exec_lobby_cmd(inp)
        except KeyboardInterrupt: sys.exit()
        except Exception as e: safe_print(f"Err Lobby: {e}")




def is_daemon_alive():
    """Returns True if Daemon is running (Bind fails), False if not (Bind success)"""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.bind(('127.0.0.1', IPC_PORT))
        return False # We could bind, so port was free -> Not running
    except: return True # Port busy -> Running

def launch_daemon_background():
    # Launch self with --daemon
    # Detach process
    # Use setsid to ensure it doesn't get killed when parent exits
    # We pass 'python3' explicitly or sys.executable
    script_abs = os.path.abspath(sys.argv[0])
    cwd_dir = os.path.dirname(script_abs)
    
    # Ensure log dir exists for launch errors
    log_path = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
    if not os.path.exists(log_path): os.makedirs(log_path)
    
    # Redirect stderr to launch_log to catch startup errors (e.g. imports)
    with open(os.path.join(log_path, "launch.err"), "a") as ferr:
        subprocess.Popen([sys.executable, script_abs, "--daemon"], 
                         stdout=subprocess.DEVNULL, stderr=ferr,
                         cwd=cwd_dir,
                         start_new_session=True)

def run_client(cmd_str):
    restore_from_afk() # Any CLI interaction implies activity
    if not cmd_str: cmd_str = "--estados-globales"
    
    # 1. Bind Reply Socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(5.0) # 5s timeout default
    
    # Find free port
    my_port = 0
    try:
        s.bind(('127.0.0.1', 0)) # Ephemeral
        my_port = s.getsockname()[1]
    except:
        print("Error sockets cliente"); return

    # 2. Send Command
    # CLI_CMD | ReturnIP | ReturnPort | CommandStr
    payload = f"CLI_CMD{SEP}127.0.0.1{SEP}{my_port}{SEP}{cmd_str}"
    send_ipc(payload, IPC_PORT)
    
    # 3. Listen for replies

    try:
        while True:
            d, _ = s.recvfrom(65535)
            print(d.decode())
            # For specific commands like --quienes that might have multiple lines, we wait.
            # But normally we just print one reply.
            pass
            
    except socket.timeout:
        pass # End of stream implicit
    except KeyboardInterrupt:
        pass
    finally:
        s.close()

def run_daemon():
    global MY_NICK, MY_STATUS, MY_IP, LOBBY_ADAPTER, PROMPT
    
    # Daemon Hygiene
    liberate_ports()
    
    # Logging
    log_path = os.path.join(os.path.expanduser("~"), ".ghostwhisperchat")
    if not os.path.exists(log_path): os.makedirs(log_path)
    
    # Redirect Stdout/Stderr to log
    sys.stdout = open(os.path.join(log_path, "daemon.log"), "a", buffering=1)
    sys.stderr = open(os.path.join(log_path, "daemon.err"), "a", buffering=1)
    
    print(f"[{time.time()}] Daemon Started (PID: {os.getpid()})")
    
    # Basic Init (No Display)
    lazy_import() 
    global hashlib; import hashlib
    
    gw_display.DISPLAY = None # NO TUI
    
    adapter = LobbyAdapter()
    LOBBY_ADAPTER = adapter
    
    fw_cfg()
    MY_IP = get_ip()
    
    if not load_config():
        MY_NICK = socket.gethostname()
        save_config()
        
    init_completer() # Maybe not needed in daemon, but harmless
    
    # Listeners
    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_PRIV, handle_v2_priv)
    gw_comm.start_udp_listener(gw_comm.UDP_PORT_DISC, handle_v2_disc)
    gw_comm.start_tcp_listener(gw_comm.TCP_PORT_GRP,  handle_v2_grp)
    
    threading.Thread(target=check_child_health, daemon=True).start()
    
    # Ensure DISPLAY for Zenity (if available in env)
    if "DISPLAY" not in os.environ:
        os.environ["DISPLAY"] = ":0"

    # Infinite Loop
    while True:
        # Check Pending Invite Timeout
        # (OBSOLETE: Now handled by gw_pop callback 'on_timeout' -> handle_afk_timeout)
        # We removed the loop to avoid Race Conditions.
        
        time.sleep(1)

def main():
    # v37.18: Clear debug log on startup (only if Lobby/Daemon)
    try:
        if "--child" not in sys.argv and "--daemon" not in sys.argv:
             # CLI triggers debug clear? No, maybe only Daemon should clear it or Lobby.
             # Legacy behavior: Lobby cleared it.
             # Now Daemon clears it.
             pass
    except: pass

    # Parsing
    if "--daemon" in sys.argv:
        try:
            dsk = get_desktop_path()
            path = os.path.join(dsk, "gwc_lobby_debug.log")
            if os.path.exists(path):
                 with open(path, "w") as f: f.write(f"--- DAEMON START {time.ctime()} ---\n")
        except: pass
        run_daemon()

    elif "--child" in sys.argv:
        try:
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            
            port = sys.argv[sys.argv.index("--port")+1]
            
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            global SILENT_UPDATES_ALLOWED

            gw_child.run(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        # CLI / AUTO-DAEMON MODE
        # Check Daemon Status
        is_running = is_daemon_alive()
        
        args = sys.argv[1:]
        
        if not args:
             # DAEMON NO CORRE: INICIARLO
             if not is_running:
                 print(f"{Colors.C}[*] Iniciando GhostWhisperChat Daemon...{Colors.E}")
                 launch_daemon_background()
                 # Esperar a que arranque
                 up = False
                 for _ in range(10):
                     time.sleep(0.5)
                     if is_daemon_alive():
                         up=True; break
                 
                 if up:
                     print(f"{Colors.G}[‚úî] Daemon iniciado en segundo plano.{Colors.E}")
                     # Start default interactive client or just show status
                     args = ["--estados-globales"] 
                 else:
                     print(f"{Colors.F}[X] Fallo al iniciar el Daemon.{Colors.E}")
                     sys.exit(1)
             else:
                 # Default command if running
                 print(f"{Colors.G}[*] Daemon activo. Cliente conectado.{Colors.E}")
                 args = ["--estados-globales"]

        elif not is_running:
             # Args provided but Daemon dead?
             print(f"{Colors.W}[!] Daemon no activo. Iniciando...{Colors.E}")
             launch_daemon_background()
             time.sleep(2)
        
        if "--update" in args or "--actualizar" in args or "update" in args or "actualizar" in args:
             # run update locally
             trigger_manual_update()
        else:
             # Run Client for other commands
             # Pre-process args to support dashless commands (Sugar)
             # E.g. gwc scan -> gwc --scan
             # Only applied in CLI mode, safe for Chat logic.
             new_args = []
             import gw_shared
             for a in args:
                 if not a.startswith("-"):
                     # Try finding canonical command
                     if f"--{a}" in gw_shared.CMD_MAP:
                         new_args.append(f"--{a}")
                     elif f"-{a}" in gw_shared.CMD_MAP:
                         new_args.append(f"-{a}")
                     else:
                         new_args.append(a) # Pass through (e.g. arguments like IP or Nick)
                 else:
                     new_args.append(a)
                     
             run_client(" ".join(new_args))

if __name__ == "__main__": main()
