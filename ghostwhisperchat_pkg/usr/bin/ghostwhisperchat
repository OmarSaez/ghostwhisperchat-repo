#!/usr/bin/env python3
APP_VER_NUM = 33.4
APP_VER_TAG = "Anti spam grupal y personal"
APP_VERSION = f"v{APP_VER_NUM} ({APP_VER_TAG})"

import socket, threading, subprocess, sys, os, time, platform, atexit, difflib, shutil, datetime, json, uuid, re, unicodedata, signal, re, ctypes, urllib.request

try: import readline
except ImportError: pass 

# --- CONFIGURACI칍N & GLOBALES ---
TCP_PORT, UDP_PORT = 44494, 44495
IPC_PORT = 5000
BUFFER, SEP, LOG_FILE, CONFIG_FILE = 4096, "<SEPARATOR>", "cyberdei_history.log", "cyberdei_config.json"
BUFFER, SEP, LOG_FILE, CONFIG_FILE = 4096, "<SEPARATOR>", "cyberdei_history.log", "cyberdei_config.json"

# Detectar Escritorio
def get_desktop_path():
    if platform.system() == "Linux":
        try:
            return subprocess.check_output(["xdg-user-dir", "DESKTOP"]).decode().strip()
        except: pass
    elif platform.system() == "Windows":
        try:
            return os.path.join(os.environ['USERPROFILE'], 'Desktop')
        except: pass
    
    # Fallback
    home = os.path.expanduser("~")
    for d in ["Desktop", "Escritorio"]:
        p = os.path.join(home, d)
        if os.path.exists(p): return p
    return home

DL_ROOT = get_desktop_path()
DL_DIR = os.path.join(DL_ROOT, "GhostWhisper_Recibidos")
if not os.path.exists(DL_DIR):
    try: os.makedirs(DL_DIR)
    except: pass
TIMERS = {'PRIV': 30, 'GROUP': 60, 'MANUAL': 300, 'INVITE': 15}

# --- ESTADO PROCESOS ---
IS_CHILD = False
MY_CHILD_ID = None
PARENT_PID = None
CHILD_PROCESSES = {} # {ChatID: {'pid': PID, 'port': Port}} for Parent logic

# --- PILAS DE DATOS ---
PEERS = {}              # CONECTADOS: {IP: {'nick': Nick, 'chats': [ChatID1, ...]}}
PEER_STATUSES = {}      # ESTADOS CONECTADOS: {IP: Status}
KNOWN_USERS = {}        # HISTORIAL: {IP: {'nick': Nick, 'status': Status, 't': time}}
ACTIVE_CHATS = {}       # {ChatID: {'type': 'PRIV'/'GROUP', 'remote_id': ..., 'pass': ..., 'created_at': time}}
CURRENT_CHAT_ID = None

# GROUP_ID, GROUP_PASS = None, None # MOVIDO A ACTIVE_CHATS
MY_IP, MY_NICK, MY_STATUS = "", "An칩nimo", "En l칤nea"
DISC_TEMP, SCAN_RESULTS, PENDING_INVITE = [], [], None
POPUP_ON, USER_OFF, LAST_ACT = True, False, 0
HAS_ZENITY = False

def ensure_dependencies():
    """Instala zenity si falta en Linux (Debian/Kali/Ubuntu)"""
    if platform.system() == "Linux" and shutil.which("zenity") is None:
        try:
            print("\033[93m[!] Zenity no detectado. Instalando dependencias visuales...\033[0m")
            # Intentar apt-get silencioso
            subprocess.run(["sudo", "apt-get", "update", "-qq"], check=False)
            subprocess.run(["sudo", "apt-get", "install", "zenity", "-y", "-qq"], check=False)
        except: pass

ensure_dependencies()
HAS_ZENITY = shutil.which("zenity") is not None
AUTO_DL, LOG_ON, PENDING_FILES = True, False, []
VISIBLE_IN_SCAN = True 
IS_AFK = False 

class Colors:
    H, B, G, W, F, E, BO = '\033[95m', '\033[94m', '\033[92m', '\033[93m', '\033[91m', '\033[0m', '\033[1m'
    C, M, WH = '\033[96m', '\033[95m', '\033[97m'
    PALETTE = [B, C, M, W, WH]

PROMPT = f"\001{Colors.B}\002Lobby > \001{Colors.E}\002"

# --- UTILIDADES ---
print_lock = threading.Lock() # Added for safe_print

def normalize_str(s):
    # Quita acentos y pasa a minusculas (ej: S치ez -> saez)
    return ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn').lower()

def raw_print(s):
    # Imprime SIN guardar en historial
    # Si es hilo secundario (Async), restauramos el prompt visualmente.
    # Si es Main Thread (Sync), solo imprimimos (el input loop pondr치 el prompt).
    with print_lock:
        if threading.current_thread() is threading.main_thread():
             print(s)
        else:
             sys.stdout.write(f'\r\033[K{s}\n' + PROMPT + (readline.get_line_buffer() if 'readline' in sys.modules else ""))
             sys.stdout.flush()

def safe_print(s):
    # Imprime Y guarda en historial (Eventos publicos)
    LOBBY_HISTORY.append(s)
    raw_print(s)

def send_ipc(msg, port=IPC_PORT):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(msg.encode(), ('127.0.0.1', port))
        s.close()
    except: pass

def write_log(txt, type="MSG"):
    if LOG_ON:
        try:
            with open(LOG_FILE, "a", encoding="utf-8") as f:
                f.write(f"[{datetime.datetime.now().strftime('%F %T')}] [{type}] {txt}\n")
        except: pass

KNOWN_USERS = {} # {ip: {nick: 'x', status: 'y', t: time}}
LOBBY_HISTORY = [] # Buffer para repintar la UI

# --- PROTOCOLO v27.0 ---
PKT_PREFIX = "[CMD]"
TAG_MARK = "<TAG>"
LEN_MARK = "<LEN>"

def build_packet(cmd, *args):
    """Construye un paquete estructurado v27.0"""
    # [CMD]<TAG>COMANDO<TAG><LEN>N_ARGS<LEN><SEP>ARG1<SEP>ARG2...
    valid_args = [str(a) for a in args]
    header = f"{PKT_PREFIX}{TAG_MARK}{cmd}{TAG_MARK}{LEN_MARK}{len(valid_args)}{LEN_MARK}{SEP}"
    payload = SEP.join(valid_args)
    return (header + payload).encode('utf-8')

def parse_packet(raw_str):
    """
    Parsea un string crudo. 
    Retorna: (EsComando, NombreCmd, ListaArgs)
    """
    if not raw_str.startswith(PKT_PREFIX):
        return (False, None, None)
    
    try:
        # Extraer TAG
        # [CMD]<TAG>CMD<TAG>...
        # 01234 5
        # split por TAG_MARK
        parts = raw_str.split(TAG_MARK) 
        # parts[0] = "[CMD]"
        # parts[1] = "NOMBRE_CMD"
        # parts[2] = "<LEN>N<LEN><SEP>ARGS..."
        
        if len(parts) < 3: return (False, None, None)
        cmd_name = parts[1]
        
        rest = parts[2]
        # Extraer LEN
        lparts = rest.split(LEN_MARK)
        # lparts[0] = "" (vac칤o si pegado a TAG, o basura)
        # lparts[1] = "N"
        # lparts[2] = "<SEP>ARGS..."
        
        if len(lparts) < 3: return (False, None, None)
        n_args = int(lparts[1])
        
        # Args raw string est치 en lparts[2], pero empieza con SEP
        args_payload = lparts[2]
        if args_payload.startswith(SEP):
            args_payload = args_payload[len(SEP):]
            
        # Split args
        # Ojo: Si n_args es 0, payload puede ser vac칤o
        if n_args == 0:
            args = []
        else:
            args = args_payload.split(SEP)
            
        # Validaci칩n b치sica de integridad (opcional warning si difiere, pero aceptamos lo que llegue)
        if len(args) != n_args:
            # print(f"[WARN] Protocol mismatch: Header says {n_args}, got {len(args)}")
            pass
            
        return (True, cmd_name, args)
        
    except:
        return (False, None, None)

def send_cmd(ip, cmd, *args):
    """Helper para enviar comando estructurado"""
    pkt = build_packet(cmd, *args)
    send_raw(ip, pkt)

def send_cmd_all(cmd, *args):
    """Helper para enviar comando a todos (STATUS, etc)"""
    pkt = build_packet(cmd, *args)
    send_all(pkt)
def get_col(n): return Colors.PALETTE[sum(ord(c) for c in n) % len(Colors.PALETTE)] if n else Colors.WH

def popup(t, x):
    if not POPUP_ON: return
    
    if platform.system() == "Linux":
        if HAS_ZENITY: 
            subprocess.Popen(["zenity", "--info", "--title", t, "--text", x, "--width=350"], stderr=subprocess.DEVNULL)
            
    elif platform.system() == "Windows":
        # PowerShell Balloon Tip nativo
        # Escapar comillas simples para que no rompa el string de PS
        t_safe = t.replace("'", "''")
        x_safe = x.replace("'", "''")
        
        ps_script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        Add-Type -AssemblyName System.Drawing
        
        $notify = New-Object System.Windows.Forms.NotifyIcon
        $path = (Get-Process -id $pid).Path
        $notify.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($path)
        $notify.Visible = $True
        $notify.ShowBalloonTip(0, '{t_safe}', '{x_safe}', [System.Windows.Forms.ToolTipIcon]::Info)
        
        # Necesario para que se procese el evento visual
        # Mantiene el script vivo unos segundos
        for ($i=0; $i -lt 40; $i++) {{
             [System.Windows.Forms.Application]::DoEvents()
             Start-Sleep -Milliseconds 100
        }}
        $notify.Dispose()
        """
        # Ejecutar oculto
        try:
            # Quitamos creationflags para debug si es necesario, pero mantenemos hidden
            subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", ps_script], creationflags=subprocess.CREATE_NO_WINDOW)
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error lanzando popup: {e}{Colors.E}")
            subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", ps_script])

# --- CONFIG & STATE ---
CONFIG_FILE = "inter_chat.json"
KNOWN_USERS = {} # {ip: {nick, status, t}}
TRUSTED_PEERS = set() # IPs de gente con chat privado exitoso {ip}
TRUSTED_NETS = {} # {network_id: {'trusted': bool, 'last_seen': ts, 'name': str}}
MY_NICK = socket.gethostname()
# ... rest of vars ...
ACTIVE_CHATS = {} # cid -> {type, remote_id, pass, process_handle, port}
PEERS = {} # ip -> {nick, chats: {cid1, cid2}}
PEER_STATUSES = {} # ip -> status_str
SILENT_UPDATES_ALLOWED = False # Global state

def load_config():
    global KNOWN_USERS, MY_NICK, MY_STATUS, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, TRUSTED_NETS, TRUSTED_PEERS
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                d = json.load(f)
                KNOWN_USERS = d.get('known_users', {})
                MY_NICK = d.get('nick', MY_NICK)
                MY_STATUS = d.get('status', "En l칤nea")
                VISIBLE_IN_SCAN = d.get('visible', True)
                LOG_ON = d.get('log_on', True)
                AUTO_DL = d.get('auto_dl', True)
                TRUSTED_NETS = d.get('trusted_nets', {})
                TRUSTED_PEERS = set(d.get('trusted_peers', []))
                return True
        except: pass
    return False

def save_config():
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump({
                'known_users': KNOWN_USERS,
                'nick': MY_NICK,
                'status': MY_STATUS,
                'visible': VISIBLE_IN_SCAN,
                'log_on': LOG_ON,
                'auto_dl': AUTO_DL,
                'trusted_nets': TRUSTED_NETS,
                'trusted_peers': list(TRUSTED_PEERS)
            }, f, indent=4)
    except: pass

# --- NETWORK IDENTIFICATION ---
def get_network_id():
    """Identifica la red actual (Gateway + SSID/Name)"""
    gw = "UNK_GW"
    ssid = "LAN"
    
    try:
        if platform.system() == "Linux":
            # Gateway
            r = subprocess.check_output("ip route | grep default", shell=True).decode()
            gw = r.split()[2] if len(r.split()) > 2 else "UNK"
            # SSID/Interface
            try:
                w = subprocess.check_output("iwgetid -r", shell=True).decode().strip()
                if w: ssid = w
            except: pass
            
        elif platform.system() == "Windows":
             # 1. Gateway via Powershell (NextHop)
             try:
                 cmd_gw = "Get-NetRoute -DestinationPrefix 0.0.0.0/0 | Select-Object -ExpandProperty NextHop"
                 r = subprocess.check_output(["powershell", "-Command", cmd_gw], creationflags=0x08000000).decode().strip()
                 if r: gw = r
             except: 
                 # Fallback ipconfig parse
                 try:
                     r = subprocess.check_output("ipconfig", creationflags=0x08000000).decode()
                     # Buscar "Default Gateway . . . : 192..."
                     m = re.search(r"Default Gateway.*: ([\d\.]+)", r)
                     if m: gw = m.group(1)
                 except: pass

             # 2. SSID via netsh
             try:
                 r = subprocess.check_output("netsh wlan show interfaces", creationflags=0x08000000).decode()
                 m = re.search(r"^\s+SSID\s+:\s+(.+)$", r, re.MULTILINE)
                 if m: ssid = m.group(1).strip()
             except: pass
    except: pass
    
    return f"{gw}_{ssid}"

def check_network_trust():
    """Verifica si la red actual es confiable para updates"""
    net_id = get_network_id()
    now = time.time()
    
    data = TRUSTED_NETS.get(net_id)
    ask = False
    
    if not data:
        # Nueva red
        ask = True
        msg = f"Se ha detectado una nueva red:\n{net_id}\n\n쮻esea activar actualizaciones silenciosas en esta red?"
    else:
        # Red conocida, verificar timestamp (3 weeks = 1814400s)
        if (now - data['last_seen']) > 1814400:
            ask = True
            msg = f"No te conectas a esta red ({net_id}) en m치s de 3 semanas.\n\n쯄antener actualizaciones silenciosas?"
        else:
            # Update timestamp and proceed
            TRUSTED_NETS[net_id]['last_seen'] = now
            save_config()
            return data['trusted']

    if ask:
        # Popup de pregunta IMPORTANTE
        is_windows = platform.system() == "Windows"
        res = False
        
        # Reutilizamos logica de popup pero bloqueante y con Yes/No pregunta
        # Hack simple usando zenity/powershell directo aqui para bloquear
        try:
            if platform.system() == "Linux" and shutil.which("zenity"):
                ret = os.system(f"zenity --question --title='IMPORTANTE: Seguridad' --text='{msg}'")
                res = (ret == 0)
            elif is_windows:
               # Powershell simple
               script = f"$r=[System.Windows.Forms.MessageBox]::Show('{msg}','Seguridad','YesNo','Question');if($r-eq'Yes'){{exit 0}}else{{exit 1}}"
               ret = subprocess.call(["powershell", "-Command", f"Add-Type -A System.Windows.Forms; {script}"])
               res = (ret == 0)
        except: pass
        
        TRUSTED_NETS[net_id] = {'trusted': res, 'last_seen': now, 'name': net_id}
        save_config()
        return res
    
    return False # Should not reach

def show_help():
    print(f" {Colors.BO}--- AYUDA Y COMANDOS ---{Colors.E}")
    
    cats = {
        "GESTI칍N DE CHATS": [
            ("--chatpersonal (Nick y/o IP)", "Crear un chat privado con un usuario."),
            ("--chatgrupal ID CLAVE", "Unirse/Crear sala."), 
            ("--invite (Nick1, Nick2...)", "Invitar gente al grupo actual."),
            ("--ls", "Listar usuarios CONECTADOS en el chat."), 
            ("--salir", "Desconectar de la sesi칩n.")
        ],
        "RED Y CONTACTOS": [
            ("--quienes", "Escanear red (쯈ui칠n est치 online?)."),
            ("--contactos", "Ver historial de gente vista."),
            ("--quienes-si / --quienes-no", "Visibilidad en esc치ner.")
        ],
        "UTILIDADES Y ARCHIVOS": [
            ("--archivo (Archivo.ext y/o Ruta)", "Enviar archivo."),
            ("--estado (Texto)", "Cambiar estado."),
            ("--limpiar", "Limpiar pantalla.")
        ],
        "SISTEMA Y CONFIGURACI칍N": [
             ("--log on / off", "Guardar historial."), 
             ("--popno / --popsi", "Control Notificaciones."), 
             ("--autolevantado-si/no", "Iniciar app al encender PC (Linux).")
        ]
    }

    for cat_name, cmds in cats.items():
        print(f"\n {Colors.C}:: {cat_name} ::{Colors.E}")
        for c, d in cmds: 
            print(f"   {Colors.BO}{c:<35}{Colors.E} : {d}")

    print("-" * 60)

def get_peer_name(ip):
    p = PEERS.get(ip)
    if p and isinstance(p, dict):
        return p.get('nick', ip)
    return ip

def msg_print(txt):
    """Imprime y guarda en historial para repintado"""
    safe_print(txt)
    # LOBBY_HISTORY append is handled by safe_print now
    if len(LOBBY_HISTORY) > 50: LOBBY_HISTORY.pop(0)

def refresh_ui(msg=None):
    os.system('cls' if os.name == 'nt' else 'clear')

    # Dashboard Format
    vis_txt = f"{Colors.G}SI{Colors.E}" if VISIBLE_IN_SCAN else f"{Colors.F}NO{Colors.E}"

    raw_print(f"{Colors.H}Version: {APP_VERSION}{Colors.E}")
    raw_print(f"Mi IP: {Colors.BO}{MY_IP}{Colors.E} | Nick: {Colors.BO}{MY_NICK}{Colors.E} | Visible en red: {vis_txt} | Estado: {Colors.C}{MY_STATUS}{Colors.E}")
    raw_print(f"Total de chats: {Colors.M}{len(ACTIVE_CHATS)}{Colors.E}")
    raw_print(f"Total de contactos: {Colors.M}{len(KNOWN_USERS)}{Colors.E}")
    raw_print(f"Puedes poner --help para ver los comandos")
    raw_print(f"{Colors.G}Bienvenido al lobby{Colors.E}")
    raw_print("-" * 60)

    # Repintar Historial sin duplicarlo
    for line in LOBBY_HISTORY:
        raw_print(line)

    if msg: 
        safe_print(msg) # Este es nuevo, s칤 guardar
    
    # Force Prompt restore only if Async (refresh inside refresh?)
    # Actually raw_print handles the logic per line, but for refresh we want clean output.
    # But for now let's trust it.
    
    # If we are async, raw_print appended prompt on the last line.
    # If we are sync, nobody printed prompt. Correct.

# --- RED ---
def get_ip():
    try: s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(('10.255.255.255',1)); i=s.getsockname()[0]; s.close(); return i
    except: return '127.0.0.1'

def fw_cfg():
    if platform.system() == "Linux":
        # 1. Intentar UFW (Ubuntu/Debian standard)
        try:
            for c in [[f"{p}/tcp", f"{p}/udp"] for p in [TCP_PORT, UDP_PORT]]:
                subprocess.run(["sudo", "ufw", "allow"] + c, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
        # 2. Intentar IPTABLES (Kali/RedHat/Arch fallback)
        # sudo iptables -C INPUT -p tcp --dport 44494 -j ACCEPT 2> /dev/null || sudo iptables -A INPUT -p tcp --dport 44494 -j ACCEPT
        try:
            for p, proto in [(TCP_PORT, 'tcp'), (UDP_PORT, 'udp')]:
                rule = ["sudo", "iptables", "-A", "INPUT", "-p", proto, "--dport", str(p), "-j", "ACCEPT"]
                # Check simple para no duplicar (es complejo en python puro, lanzamos el add y que iptables decida si duplica o no)
                # Mejor intentar solo si no existe, pero para simplificar lanzamos append.
                # Si el user no tiene sudo sin pass, fallara silencioso.
                subprocess.run(rule, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except: pass
        
    elif platform.system() == "Windows":
        subprocess.run(["powershell", f"Start-Process cmd -Verb RunAs -ArgumentList '/c netsh advfirewall firewall add rule name=\"CyberDEI\" dir=in action=allow protocol=ANY localport=\"{TCP_PORT},{UDP_PORT}\"'"], shell=True)

def send_raw(ip, d):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2); s.connect((ip, TCP_PORT))
        if isinstance(d, str): s.send(d.encode())
        else: s.send(d)
        s.close()
    except:
        if ip in PEERS:
             # No borrar inmediatamente en error temporal, o manejar mejor
             pass

def send_all(d, targets=None):
    if targets is None:
        # Enviar solo a usuarios del chat actual
        targets = []
        if CURRENT_CHAT_ID:
            for ip, pdata in PEERS.items():
                if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                    targets.append(ip)

    for ip in [i for i in targets if i != MY_IP]: send_raw(ip, d)

# --- DISCOVERY & MEMORY ---
def update_memory(ip, nick, status):
    """Actualiza memoria y guarda en config"""
    global KNOWN_USERS
    KNOWN_USERS[ip] = {'nick': nick, 'status': status, 't': time.time()}
    save_config()

def udp_loop():
    global PEERS, DISC_TEMP, PEER_STATUSES, SCAN_RESULTS
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    try: u.bind(('', UDP_PORT))
    except: return

    while True:
        try:
            d, a = u.recvfrom(4096); msg, ip = d.decode('utf-8', errors='ignore'), a[0]
            if ip == MY_IP: continue

            is_cmd, cmd, args = parse_packet(msg)

            if not is_cmd: continue # Ignorar mensajes no estructurados en UDP

            if cmd == "SEARCH_GROUP":
                # args: GID, GPASS, NICK, STATUS
                if len(args) >= 4:
                    gid, gpass, nick, st = args[0], args[1], args[2], args[3]
                    found_chat_id = None
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                            found_chat_id = cid
                            break

                    if found_chat_id:
                        if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                        PEERS[ip]['nick'] = nick
                        PEERS[ip]['chats'].add(found_chat_id)

                        PEER_STATUSES[ip] = st
                        update_memory(ip, nick, st)

                        if 'port' in ACTIVE_CHATS[found_chat_id]:
                            send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

                        u.sendto(build_packet("I_EXIST", gid, gpass, MY_NICK, MY_STATUS), (ip, UDP_PORT))

            elif cmd == "I_EXIST":
                # args: GID, GPASS, NICK, STATUS
                if len(args) >= 4:
                    gid, gpass, nick, st = args[0], args[1], args[2], args[3]
                    found_chat_id = None
                    for cid, cdata in ACTIVE_CHATS.items():
                        if cdata['type']=='GROUP' and str(cdata['remote_id'])==str(gid) and str(cdata['pass'])==str(gpass):
                            found_chat_id = cid
                            break

                    if found_chat_id:
                        if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
                        PEERS[ip]['nick'] = nick
                        PEERS[ip]['chats'].add(found_chat_id)

                        PEER_STATUSES[ip] = st
                        update_memory(ip, nick, st)

                        if 'port' in ACTIVE_CHATS[found_chat_id]:
                             send_ipc(f"FWD_PEER{SEP}{ip}{SEP}{nick}{SEP}{st}", ACTIVE_CHATS[found_chat_id]['port'])

            elif cmd == "WHOIS":
                # args[0] = target_nick (puede ser vac칤o)
                target = args[0].strip().lower() if args else ""

                # Soy yo?
                if not target or target == MY_NICK.lower():
                    u.sendto(build_packet("USER_HERE", MY_NICK, MY_STATUS), (ip, UDP_PORT))

            elif cmd == "USER_HERE":
                # args: Nick, Status
                if len(args) >= 2:
                    nick, st = args[0], args[1]
                    # Check duplicate in DISC_TEMP
                    if not any(x[0] == ip for x in DISC_TEMP):
                        DISC_TEMP.append((ip, nick, st))
                    update_memory(ip, nick, st)

            elif cmd == "WHO_ALL" and VISIBLE_IN_SCAN:
                u.sendto(build_packet("IAM_HERE", MY_NICK, MY_STATUS), (ip, UDP_PORT))

            elif cmd == "IAM_HERE":
                # args: Nick, Status
                if len(args) >= 2:
                    nick, st = args[0], args[1]
                    SCAN_RESULTS.append({'ip': ip, 'nick': nick, 'status': st})
                    update_memory(ip, nick, st)

        except: pass

def find_global(t):
    target_clean = normalize_str(t)
    
    # 1. Check known
    for ip, d in KNOWN_USERS.items():
        if normalize_str(d['nick']) == target_clean or ip == t: return ip
        
    for ip, p in PEERS.items():
         if isinstance(p, dict) and normalize_str(p.get('nick', '')) == target_clean: return ip
         
    # 2. Discovery UDP
    safe_print(f"{Colors.W}[*] Buscando '{t}'...{Colors.E}")
    global DISC_TEMP
    DISC_TEMP = [] 
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHOIS", t), ('255.255.255.255', UDP_PORT)); u.close()
    
    time.sleep(2)
    
    for res in DISC_TEMP:
        # res = (ip, nick, status)
        # Check MATCH EXACTO (Insensitive)
        if normalize_str(res[1]) == target_clean:
            safe_print(f"{Colors.G}[+] Encontrado: {res[1]} en {res[0]}{Colors.E}")
            return res[0]
            
    safe_print(f"{Colors.F}[X] Usuario '{t}' no encontrado.{Colors.E}")
    
    # --- FUZZY SEARCH / SUGERENCIAS ---
    suggs = set() # (nick, ip)

    # Helper local
    def check_sim(n, ip):
        n_clean = normalize_str(n)
        if target_clean in n_clean: return True # Contenido exacto
        # Similitud > 55%
        if difflib.SequenceMatcher(None, target_clean, n_clean).ratio() > 0.55: return True
        return False

    # 1. Buscar en Resultados UDP
    for res in DISC_TEMP:
        if check_sim(res[1], res[0]): suggs.add((res[1], res[0]))

    # 2. Buscar en Historial Conocidos
    for ip, data in KNOWN_USERS.items():
        if check_sim(data['nick'], ip): suggs.add((data['nick'], ip))

    if suggs:
        safe_print(f"{Colors.W}쯈uiz치s quisiste decir?:{Colors.E}")
        for snick, sip in suggs:
            safe_print(f"   > {Colors.BO}{snick}{Colors.E} ({sip})")

    return None

def scan_network():
    global SCAN_RESULTS
    safe_print(f"{Colors.W}[*] Escaneando red local (2s)...{Colors.E}")
    SCAN_RESULTS = []; u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("WHO_ALL"), ('255.255.255.255', UDP_PORT)); u.close(); time.sleep(2)

    safe_print(f"{Colors.G}[*] Equipos Encontrados ({len(SCAN_RESULTS)}):{Colors.E}")
    for res in SCAN_RESULTS:
        safe_print(f"   > {Colors.BO}{res['nick']}{Colors.E} ({res['ip']}) [{res['status']}]")
    if not SCAN_RESULTS: safe_print("   (Ninguno visible)")

def leave_sess(silent=False, exclude_ip=None, target_cid=None):
    global PEERS, PEER_STATUSES, CURRENT_CHAT_ID
    
    # Si no se especifica CID, usar el global (contexto Lobby)
    cid_to_close = target_cid if target_cid else CURRENT_CHAT_ID
    
    if not cid_to_close or cid_to_close not in ACTIVE_CHATS:
        if not silent: safe_print(f"{Colors.W}[!] Sesi칩n no v치lida.{Colors.E}")
        return

    if not silent: safe_print(f"{Colors.W}[*] Cerrando sesi칩n {cid_to_close}...{Colors.E}")

    # Send disconnect to peers in THIS chat
    c = ACTIVE_CHATS[cid_to_close]
    to_remove = []

    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and cid_to_close in pdata.get('chats', []):
            if ip != exclude_ip:
                if c['type'] == 'GROUP':
                    send_cmd(ip, "LEAVE_GRP", c['remote_id'], MY_NICK)
                else: # PRIV
                    send_cmd(ip, "LEAVE_PRIV", MY_NICK)
            # Remove chat_id linkage
            pdata['chats'].discard(cid_to_close) # Use discard to be safe
            if not pdata['chats']: # Empty, user gone
                to_remove.append(ip)

    for ip in to_remove:
        if ip in PEERS: del PEERS[ip]
        if ip in PEER_STATUSES: del PEER_STATUSES[ip]

    # Matar proceso hijo si existe y no soy yo mismo el hijo suicid치ndose
    if 'port' in ACTIVE_CHATS[cid_to_close]:
         # Enviamos kill por si acaso, aunque el hijo ya se haya ido
         send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid_to_close]['port'])

    del ACTIVE_CHATS[cid_to_close]
    
    # Si cerr칠 la sesi칩n activa del Lobby, limpiar variable
    if CURRENT_CHAT_ID == cid_to_close:
        CURRENT_CHAT_ID = None
        
    if not silent: safe_print(f"{Colors.G}[九] Sesi칩n {cid_to_close} cerrada.{Colors.E}")

def start_private_chat(ip, nick, status="En l칤nea"):
    global CURRENT_CHAT_ID
    cid = str(uuid.uuid4())[:8]
    ACTIVE_CHATS[cid] = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time()}
    CURRENT_CHAT_ID = cid

    if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
    if isinstance(PEERS[ip], dict):
        PEERS[ip]['nick'] = nick
        PEERS[ip]['chats'].add(cid)

    PEER_STATUSES[ip] = status
    update_memory(ip, nick, status)
    return cid

def join_grp(gid, gp, exclude_ip=None):
    # Ya no salimos de la sesi칩n anterior forzosamente
    # if PEERS: leave_sess(...) <--- REMOVED

    global CURRENT_CHAT_ID
    global PEERS, PEER_STATUSES

    if not CURRENT_CHAT_ID: return # Should not happen in child context

    safe_print(f"{Colors.G}[*] Conectando a '{gid}'...{Colors.E}")

    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    u.sendto(build_packet("SEARCH_GROUP", gid, gp, MY_NICK, MY_STATUS), ('255.255.255.255', UDP_PORT)); u.close()

    time.sleep(2)
    # Check if peers found in this chat
    found_any = False
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
            found_any = True
            break

    if found_any:
        safe_print(f"{Colors.G}[九] Unido.{Colors.E}")
        send_cmd_all("JOINED", MY_NICK, MY_STATUS); write_log(f"Grupo {gid}", "SYS")
    else:
        safe_print(f"{Colors.G}[九] Sala creada (esperando peers).{Colors.E}"); write_log(f"Sala {gid}", "SYS")

    # Trigger Update Check on trusted peers in this group
    # Necesitamos la lista de IPs. Si es un join reciente, PEERS se va poblando.
    # Mejor hacerlo tras unos segundos o usar los que ya conocemos que est치n ah칤.
    # Disparamos un hilo retardado
    # threading.Thread(target=lambda: (time.sleep(5), try_trigger_updates(list(PEERS.keys())))).start()
    pass

def invite_users(targets_str):
    if not CURRENT_CHAT_ID or CURRENT_CHAT_ID not in ACTIVE_CHATS:
        return safe_print(f"{Colors.F}[!] Debes estar en un chat activo.{Colors.E}")

    chat = ACTIVE_CHATS[CURRENT_CHAT_ID]
    if chat['type'] != 'GROUP':
        return safe_print(f"{Colors.F}[!] Solo puedes invitar en grupos.{Colors.E}")

    gid = chat['remote_id']
    gpass = chat['pass']

    targets = [t.strip() for t in targets_str.split(',')]

    members_list = ", ".join([d['nick'] for d in PEERS.values() if isinstance(d, dict) and CURRENT_CHAT_ID in d.get('chats', [])])
    # payload = f"GRP_INVITE_REQ{SEP}{MY_NICK}{SEP}{gid}{SEP}{gpass}{SEP}{members_list}".encode() # Old

    safe_print(f"{Colors.W}[*] Enviando invitaciones...{Colors.E}")
    count = 0
    for t in targets:
        ip = find_global(t)
        if ip:
            pdata = PEERS.get(ip)
            if pdata and isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                 safe_print(f"   > {t}: Ya est치 en el grupo.")
            else:
                send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, members_list)
                safe_print(f"   > {t}: Invitaci칩n enviada.")
                count += 1

    if count > 0:
        send_cmd_all("GRP_MSG", gid, f"[Grupo] {MY_NICK} ha invitado a {count} usuarios.")

# --- CORE ---
def set_afk_mode(cause_ip=None, cause_nick=None):
    global MY_STATUS, IS_AFK
    IS_AFK = True
    if not MY_STATUS.endswith("-AFK"): MY_STATUS += "-AFK"
    msg = f"{Colors.W}[!] Solicitud de {Colors.BO}{cause_nick}{Colors.E} {Colors.W}({cause_ip}) auto-rechazada. Entrando en AFK.{Colors.E}" if cause_nick else f"{Colors.W}[!] Timeout. Entrando en AFK.{Colors.E}"
    safe_print(msg); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def restore_from_afk():
    global MY_STATUS, IS_AFK
    if not IS_AFK: return
    IS_AFK = False
    if MY_STATUS == "Ausente (AFK)": MY_STATUS = "En l칤nea"
    elif MY_STATUS.endswith("-AFK"): MY_STATUS = MY_STATUS[:-4]
    safe_print(f"{Colors.G}[i] Bienvenido de vuelta. Estado: {MY_STATUS}{Colors.E}"); send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

def handle_invite_logic(ip, nick, type, extra_data=None):
    global PENDING_INVITE, PEER_STATUSES
    inviter_status = PEER_STATUSES.get(ip, "")

    req_text = ""
    if type == "PRIV": 
        req_text = f"游눫 춰Hey! {nick} ({ip}) quiere iniciar una conversaci칩n contigo.\n\n쯊e gustar칤a aceptar la conexi칩n?"
    else: 
        gid, gpass, members = extra_data
        req_text = f"游닉 {nick} quiere que formes parte del grupo \"{gid}\".\n\n쯊e unes a la conversaci칩n?"

    # --- GUI HANDLING (v26.1 Style: Popen + Polling) ---
    proc = None
    if platform.system() == "Linux" and HAS_ZENITY:
        try:
            proc = subprocess.Popen(["zenity", "--question", "--title=Invitaci칩n CyberDEI", f"--text={req_text}", "--timeout=30"], stderr=subprocess.DEVNULL)
        except: pass

    elif platform.system() == "Windows":
        # Windows Popen non-blocking
        # Strip emojis for Windows compatibility (PowerShell encoding issues)
        txt_win = req_text.encode('ascii', 'ignore').decode() 
        t_safe = txt_win.replace("\n", "`n").replace("'", "''")
        
        script = f"""
        Add-Type -AssemblyName System.Windows.Forms
        $res = [System.Windows.Forms.MessageBox]::Show('{t_safe}', 'Invitaci칩n', 'YesNo', 'Question')
        if ($res -eq 'Yes') {{ exit 0 }} else {{ exit 1 }}
        """
        try:
             proc = subprocess.Popen(["powershell", "-WindowStyle", "Hidden", "-Command", script], stderr=subprocess.DEVNULL)
        except: pass

    # Wait for GUI response if launched
    if proc:
        start_t = time.time()
        answered = False
        while time.time() - start_t < 30: # 30s timeout
            if proc.poll() is not None:
                answered = True
                pass

        if answered:
            if proc.returncode == 0: # YES
                # Construir dict temporal y llamar yes
                safe_print(f"{Colors.M}[GUI] Aceptando invitaci칩n...{Colors.E}")
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--y")
            else:
                PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}
                exec_lobby_cmd("--n") # NO
            return
        else:
            # Timeout GUI -> AFK PROTOCOL
            try: proc.terminate()
            except: pass
            
            safe_print(f"{Colors.W}[!] Sin respuesta. Entrando en modo AFK.{Colors.E}")
            set_afk_mode(cause_ip=ip, cause_nick=nick)
            send_cmd(ip, "INVITE_REJ", MY_NICK, "Auto-AFK")
            return # Evitar fallback a CLI si ya fall칩 GUI

    # --- CLI FALLBACK (Solo si no hay GUI) ---
    # Set global pending invite DICTIONARY so --y/--n works in Lobby
    PENDING_INVITE = {'ip': ip, 'nick': nick, 'type': type, 'data': extra_data}

    msg_print(f"\n{Colors.M}**********************************{Colors.E}")
    msg_print(f"{Colors.M}* {req_text.upper()}{Colors.E}")
    msg_print(f"{Colors.M}* Escribe --y para Aceptar o --n para Rechazar{Colors.E}")
    msg_print(f"{Colors.M}**********************************{Colors.E}")
    safe_print("\a") # Beep

    # Loop de espera pasiva para CLI
    start_wait = time.time()
    while time.time() - start_wait < 30:
        if PENDING_INVITE is None: return # Respondido
        time.sleep(1)

    # Timeout CLI
    if PENDING_INVITE and PENDING_INVITE['ip'] == ip:
        msg_print(f"{Colors.F}[!] Invitaci칩n de {nick} expirada.{Colors.E}")
        send_cmd(ip, "INVITE_REJ", MY_NICK, "Timeout")
        PENDING_INVITE = None



def dl_file(name, size, sock, sender, sender_ip=None):
    if not os.path.exists(DL_DIR): os.makedirs(DL_DIR)
    tmp = os.path.join(DL_DIR, f".tmp_{int(time.time())}_{name}")
    try:
        with open(tmp, "wb") as f:
            r = 0
            while r < size:
                ch = sock.recv(min(BUFFER, size-r)); 
                if not ch: break
                f.write(ch); r += len(ch)
    except Exception as e: return safe_print(f"{Colors.F}Error DL: {e}{Colors.E}")

    final_path = os.path.join(DL_DIR, name)
    if AUTO_DL:
        if os.path.exists(final_path): 
            base, ext = os.path.splitext(name)
            final_path = os.path.join(DL_DIR, f"{base}_copy_{int(time.time())}{ext}")
        os.rename(tmp, final_path)
        safe_print(f"{Colors.G}[九] Archivo guardado: {final_path}{Colors.E}")
        popup(f"De: {sender}", f"Guardado: {name}"); write_log(f"Recibido {name}", "FILE")
        
        # Notify Local Chat Windows (Feature Request)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         # Send System Notification to Child
                         tag = f"[{Colors.C}游늬{Colors.E}]"
                         msg = f"{Colors.C}{sender} ha enviado un archivo: {name}{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

    else:
        PENDING_FILES.append({'t': tmp, 'r': final_path, 's': sender})
        safe_print(f"{Colors.W}[?] '{name}' de {sender} espera (--aceptar/--rechazar).{Colors.E}"); popup("Archivo", f"{sender}: {name}")
        
        # Notify Local Chat Windows (Manual Wait)
        if sender_ip and sender_ip in PEERS:
            pdata = PEERS[sender_ip]
            if isinstance(pdata, dict):
                for cid in pdata.get('chats', set()):
                    if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                         tag = f"[{Colors.C}游늬{Colors.E}]"
                         msg = f"{Colors.C}{sender} env칤a archivo: {name}. Escribe --aceptar.{Colors.E}"
                         send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

def tcp_loop():
    global POPUP_ON, LAST_ACT, USER_OFF, PENDING_INVITE
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: s.bind(('0.0.0.0', TCP_PORT)); s.listen(10)
    except: safe_print(f"{Colors.F}Puerto ocupado.{Colors.E}"); os._exit(1)

    while True:
        try:
            c, a = s.accept(); ip = a[0]
            raw = c.recv(4096).decode('utf-8', errors='ignore')

            if raw:
                # 1. Intentar parsear como Paquete Estructurado v27
                is_cmd, cmd, args = parse_packet(raw)

                if is_cmd:
                    # Auto-add to known if interaction happens
                    if ip not in PEERS:
                        if ip in KNOWN_USERS:
                            PEERS[ip] = {'nick': KNOWN_USERS[ip]['nick'], 'chats': set()}
                        else:
                            PEERS[ip] = {'nick': "...", 'chats': set()}

                    curr_nick = PEERS[ip]['nick']

                    if not USER_OFF:
                        # Simple logic for popup, ignoring PRIVATE_PEER timeout logic for now
                        if not POPUP_ON and (time.time()-LAST_ACT > 30): POPUP_ON = True
                    # elif time.time()-LAST_ACT > TIMEOUTS['MANUAL']: POPUP_ON, USER_OFF = True, False; safe_print(f"{Colors.W}[i] Popups ON.{Colors.E}") # TIMEOUTS not defined

                    # BLOCK MODULAR DE COMANDOS
                    if cmd == "INVITE":
                        # args: NICK, TYPE, (GID, GPASS, MEMBERS if group)
                        if len(args) >= 2:
                            nick, type = args[0], args[1]
                            extra = None
                            if type == "GROUP" and len(args) >= 5:
                                extra = (args[2], args[3], args[4]) # gid, pass, members

                            PEERS[ip]['nick'] = nick
                            st = args[len(args)-1] if type == "PRIV" and len(args) >= 3 else "?" # Status is last arg for PRIV
                            PEER_STATUSES[ip] = st
                            update_memory(ip, PEERS[ip]['nick'], st) # Sync al recibir
                            threading.Thread(target=handle_invite_logic, args=(ip, nick, type, extra)).start()

                    elif cmd == "INVITE_ACC":
                        # args: R_NICK, R_STATUS
                        if len(args) >= 2:
                             r_nick, r_stat = args[0], args[1]
                             
                             # Buscar invitacion pendiente mia hacia esa IP?
                             # Asumimos que si llega INVITE_ACC es porque invitamos.
                             # Creamos sala PRIV
                             cid = str(uuid.uuid4())[:8]
                             cdata = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time(), 'remote_nick': r_nick}
                             ACTIVE_CHATS[cid] = cdata
                             
                             # LINK ROUTING
                             if ip not in PEERS: PEERS[ip] = {'nick': r_nick, 'chats': set()}
                             if isinstance(PEERS[ip], dict):
                                 PEERS[ip]['chats'].add(cid)
                             
                             # TRUSTED PEERS (Add logic)
                             TRUSTED_PEERS.add(ip); save_config()

                             spawn_child_process(cid, cdata)
                             refresh_ui(f"{Colors.G}[*] {r_nick} acept칩 tu invitaci칩n.{Colors.E}")
                             
                             # TRIGGER UPDATE CHECK (Private)
                             # Esperar un poco para estabilidad TCP
                             # threading.Thread(target=lambda: (time.sleep(3), try_trigger_updates([ip]))).start(); 
                             write_log(f"Privado ok {r_nick}", "SYS")

                    elif cmd == "INVITE_REJ":
                        # args: NICK, REASON
                        reason = args[1] if len(args)>1 else "?"
                        safe_print(f"{Colors.F}[X] {args[0]} rechaz칩 la invitaci칩n ({reason}).{Colors.E}")
                        if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                             del PEERS[ip]
                             if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                        PENDING_INVITE = None

                    elif cmd == "INVITE_TOUT":
                        # args: NICK, STATUS
                        n = args[0] if len(args)>0 else curr_nick
                        st = args[1] if len(args)>1 else "AFK"
                        safe_print(f"{Colors.W}[!] {n} no respondi칩 (Timeout). Estado: {st}{Colors.E}")
                        update_memory(ip, n, st)
                        if ip in PEERS and isinstance(PEERS[ip], dict) and not PEERS[ip].get('chats'):
                             del PEERS[ip]
                             if ip in PEER_STATUSES: del PEER_STATUSES[ip]

                    elif cmd == "GRP_INVITE_ACC":
                         # args: NICK
                         safe_print(f"{Colors.G}[九] {args[0]} se uni칩 al grupo.{Colors.E}")
                         # UDP SEARCH_GROUP will handle the actual peer linkage.

                    elif cmd == "JOINED":
                        # args: NICK, STATUS
                        PEERS[ip]['nick'] = args[0]
                        st = args[1] if len(args)>1 else ""
                        PEER_STATUSES[ip] = st
                        update_memory(ip, args[0], st)

                        pdata = PEERS.get(ip)
                        if pdata and isinstance(pdata, dict):
                            for cid in pdata.get('chats', set()):
                                if cid in ACTIVE_CHATS and 'port' in ACTIVE_CHATS[cid]:
                                    if ACTIVE_CHATS[cid]['type'] == 'GROUP':
                                        tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                        msg = f"{Colors.G}[+] {args[0]} entr칩 al grupo.{Colors.E}"
                                        send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[cid]['port'])

                        safe_print(f"{Colors.G}[+] {args[0]} entr칩.{Colors.E}") # Lobby Log

                    elif cmd == "CHILD_EXIT":
                        cid = args[0]
                        if cid in ACTIVE_CHATS:
                            # Clean up
                            if 'port' in ACTIVE_CHATS[cid]: del ACTIVE_CHATS[cid]
                            # No borramos de PEERS aqui, solo la sesi칩n activa
                            pass

                        # Usamos safe_print antes del refresh para historial
                        safe_print(f"{Colors.G}[*] Chat cerrado (CID: {cid}).{Colors.E}")
                        refresh_ui()

                        # El FIX BUG PROMPT ya est치 dentro de refresh_ui ahora

                    elif cmd == "GRP_MSG":
                        # args: GID, MSG
                        if len(args) >= 2:
                            gid, msg_content = args[0], args[1]
                            # Buscar localmente el chat que tiene remote_id == gid_target
                            target_cid = None
                            for cid, cdata in ACTIVE_CHATS.items():
                                if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                    target_cid = cid
                                    break

                            if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                                curr_nick = PEERS.get(ip, {}).get('nick', '?')
                                tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"
                                send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg_content}", ACTIVE_CHATS[target_cid]['port'])
                                write_log(f"[{curr_nick} @ {gid}]: {msg_content}", "CHAT")

                    elif cmd == "STATUS_UPDATE":
                        # args: NICK, STATUS
                        if len(args) >= 2:
                            PEERS[ip]['nick'] = args[0]
                            PEER_STATUSES[ip] = args[1]
                            update_memory(ip, args[0], args[1])
                        elif len(args) == 1:
                            PEER_STATUSES[ip] = args[0]
                            update_memory(ip, curr_nick, args[0])

                    elif cmd == "LEAVE_PRIV":
                        # args: NICK
                        safe_print(f"{Colors.W}[!] Un chat privado ha sido cerrado por {args[0]}.{Colors.E}")
                        to_close = []
                        for cid, cdata in ACTIVE_CHATS.items():
                           if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                               to_close.append(cid)

                        for cid in to_close:
                           if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                           del ACTIVE_CHATS[cid]
                        refresh_ui()

                    elif cmd == "LEAVE_GRP":
                        # args: GID, NICK
                        if len(args) >= 2:
                            gid, nick = args[0], args[1]
                            target_cid = None
                            for cid, cdata in ACTIVE_CHATS.items():
                                if cdata['type'] == 'GROUP' and cdata['remote_id'] == gid:
                                    target_cid = cid
                                    break

                            if target_cid:
                                tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                msg = f"{Colors.F}[游눖] {nick} sali칩 del grupo.{Colors.E}"
                                if 'port' in ACTIVE_CHATS[target_cid]:
                                    send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{msg}", ACTIVE_CHATS[target_cid]['port'])

                                if ip in PEERS and isinstance(PEERS[ip], dict):
                                    PEERS[ip]['chats'].discard(target_cid)
                            refresh_ui()

                    elif cmd == "DISCONNECT_NOW":
                        # args: NICK
                        nick_disc = args[0] if args else "?"
                        safe_print(f"{Colors.F}[!] {nick_disc} se desconect칩 globalmente.{Colors.E}")

                        to_close = []
                        for cid, cdata in ACTIVE_CHATS.items():
                            if cdata['type'] == 'PRIV' and cdata['remote_id'] == ip:
                                to_close.append(cid)
                            elif cdata['type'] == 'GROUP':
                                pdata = PEERS.get(ip)
                                if pdata and cid in pdata.get('chats', set()):
                                     tag = f"[{Colors.F}SYSTEM{Colors.E}]"
                                     msg = f"{Colors.F}[游눖] {nick_disc} se desconect칩.{Colors.E}"
                                     if 'port' in cdata: send_ipc(f"FWD_MSG{SEP}{cid}{SEP}{tag}{SEP}{msg}", cdata['port'])

                        for cid in to_close:
                            if 'port' in ACTIVE_CHATS[cid]: send_ipc("CMD_CLOSE_NOW", ACTIVE_CHATS[cid]['port'])
                            del ACTIVE_CHATS[cid]

                        if ip in PEERS: del PEERS[ip]
                        if ip in PEER_STATUSES: del PEER_STATUSES[ip]
                        refresh_ui()

                    elif cmd == "VER_CHECK" or cmd == "REQ_UPDATE" or cmd == "PUSH_UPDATE" or cmd == "VER_INFO":
                         pass # Deprecated P2P Update Commands
                        
                    elif cmd == "FILE_TRANSFER":
                        # args: FNAME, SIZE
                        if len(args) >= 2:
                            target_cid = None
                            pdata = PEERS.get(ip)
                            if pdata and isinstance(pdata, dict):
                                for cid in pdata.get('chats', set()):
                                     if cid in ACTIVE_CHATS: target_cid = cid; break

                            # SIEMPRE descargar el archivo. dl_file se encarga de notificar si corresponde.
                            safe_print(f"{Colors.W}[뼇 Recibiendo '{os.path.basename(args[0])}'...{Colors.E}")
                            threading.Thread(target=dl_file, args=(os.path.basename(args[0]), int(args[1]), c, get_peer_name(ip), ip)).start()
                            c = None # Prevent close in finally

                else:
                    # 2. NO ES COMANDO V27 -> Mensaje de Chat Privado (Texto Plano)
                    # Asumimos que es un mensaje de chat privado

                    # Identificar chat privado origen
                    target_cid = None
                    pdata = PEERS.get(ip)
                    if pdata:
                        for cid in pdata.get('chats', set()):
                             if cid in ACTIVE_CHATS and ACTIVE_CHATS[cid]['type'] == 'PRIV':
                                 target_cid = cid
                                 break

                    curr_nick = PEERS.get(ip, {}).get('nick', '?')
                    tag = f"[{get_col(curr_nick)}{curr_nick}{Colors.E}]"

                    if target_cid and 'port' in ACTIVE_CHATS[target_cid]:
                         send_ipc(f"FWD_MSG{SEP}{target_cid}{SEP}{tag}{SEP}{raw}", ACTIVE_CHATS[target_cid]['port'])
                         write_log(f"[{curr_nick}] (FWD {target_cid}): {raw}", "CHAT")
                    else:
                        safe_print(f"{tag}: {raw}"); popup(f"MSG: {curr_nick}", raw); write_log(f"[{curr_nick}]: {raw}", "CHAT")

            if c: c.close()
        except Exception as e:
            # safe_print(f"Err TCP: {e}")
            pass

def send_file(arg):
    path = os.path.expanduser(arg.strip().strip("'\""))
    if not os.path.isfile(path): return safe_print(f"{Colors.F}[X] No existe.{Colors.E}")

    # Target logic same as send_all
    targets = []
    if CURRENT_CHAT_ID:
        for ip, pdata in PEERS.items():
            if isinstance(pdata, dict) and CURRENT_CHAT_ID in pdata.get('chats', []):
                targets.append(ip)

    if not targets: return safe_print(f"{Colors.F}[X] Nadie en el chat actual.{Colors.E}")

    n, s = os.path.basename(path), os.path.getsize(path); safe_print(f"{Colors.W}[븋 Enviando '{n}'...{Colors.E}"); write_log(f"Send {n}", "FILE")

    cnt = 0
    for ip in [i for i in targets if i != MY_IP]:
        try:
            k = socket.socket(socket.AF_INET, socket.SOCK_STREAM); k.settimeout(2); k.connect((ip, TCP_PORT))
            k.send(build_packet("FILE_TRANSFER", n, s)); time.sleep(0.1)
            with open(path, "rb") as f:
                while True:
                    d = f.read(BUFFER);
                    if not d: break
                    k.sendall(d)
            k.close(); cnt += 1
        except: pass
    safe_print(f"{Colors.G}[九] Enviado a {cnt}.{Colors.E}")

def send_ipc(msg, port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # No necesario para enviar
        s.sendto(msg.encode(), ('127.0.0.1', port))
        s.close()
    except: pass

# --- ACTUALIZACI칍N DE SISTEMA (REPO APT) ---
VERSION_URL = "https://omarsaez.github.io/ghostwhisperchat-repo/version.txt"

def perform_system_update():
    """Ejecuta los comandos de sistema para actualizar"""
    safe_print(f"{Colors.M}[*] Ejecutando actualizaci칩n de sistema...{Colors.E}")
    try:
        # Encadenamos update e install
        # apt install --only-upgrade asegura que no instale cosas nuevas, solo actualice lo que hay
        cmd = "sudo apt update && sudo apt install ghostwhisperchat --only-upgrade -y"
        
        subprocess.run(cmd, shell=True, check=True)
        
        safe_print(f"{Colors.G}[九] Actualizaci칩n lista. Reiniciando...{Colors.E}")
        # Reiniciar el script autom치ticamente
        os.execv(sys.executable, ['python3'] + sys.argv)
        
    except subprocess.CalledProcessError:
        safe_print(f"{Colors.F}[X] Error en la actualizaci칩n (쮺ontrase침a incorrecta?){Colors.E}")
    except Exception as e:
        safe_print(f"{Colors.F}[X] Error inesperado: {e}{Colors.E}")

def check_repo_update():
    """Verifica silenciosamente si el repo tiene una versi칩n mayor"""
    if platform.system() != "Linux": return # Solo apt por ahora
    
    # safe_print(f"{Colors.W}[*] Buscando actualizaciones en repositorio...{Colors.E}")
    try:
        # 1. Bajar el numerito (timeout corto para no congelar la app)
        with urllib.request.urlopen(VERSION_URL, timeout=3) as response:
            content = response.read().decode().strip()
            # Manejar posibles saltos de linea o espacios
            latest_ver = float(content)
            
        # 2. Comparar con la constante local
        if latest_ver > APP_VER_NUM:
            safe_print(f"{Colors.W}[!] Nueva versi칩n disponible: v{latest_ver}{Colors.E}")
            # Preguntar al usuario - INPUT bloquea?
            # En run_lobby estamos en hilo principal antes del input loop.
            # Podemos usar input simple.
            try:
                # Flush input buffer
                if platform.system() == "Linux": subprocess.run("tcflush", shell=True, stderr=subprocess.DEVNULL) 
            except: pass
            
            raw_print(f"{Colors.G}쮻eseas actualizar ahora? se necesitaran permisos ROOT (sudo) [s/n]: {Colors.E}")
            # Usamos input builtin directo
            do_up = input()
            
            if do_up.lower().startswith('s'):
                perform_system_update()
            else:
                 safe_print(f"{Colors.W}[*] Actualizaci칩n pospuesta.{Colors.E}")

    except Exception as e:
        # Si falla internet o github, no hacemos nada, seguimos normal
        # safe_print(f"Update Check Fail: {e}")
        pass

# ... existing code ...

def toggle_autostart(enable):
    """Activa o desactiva el inicio autom치tico en Linux (.config/autostart)"""
    if platform.system() != "Linux":
        return safe_print(f"{Colors.F}[!] Solo disponible en Linux por ahora.{Colors.E}")
        
    autostart_dir = os.path.expanduser("~/.config/autostart")
    desktop_file = os.path.join(autostart_dir, "inter_chat_auto.desktop")
    
    if enable:
        try:
            if not os.path.exists(autostart_dir): os.makedirs(autostart_dir)
            
            # Obtener rutas absolutas
            exe = sys.executable
            script = os.path.abspath(sys.argv[0])
            
            content = f"""[Desktop Entry]
Type=Application
Name=InterChat Auto
Exec={exe} "{script}"
Terminal=true
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Comment=Auto-start InterChat Lobby
"""
            with open(desktop_file, "w") as f:
                f.write(content)
            
            # Dar permisos de ejecuci칩n al script por si acaso
            os.chmod(script, 0o755)
            safe_print(f"{Colors.G}[九] Autolevantado ACTIVADO (Inicio de sesi칩n).{Colors.E}")
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error activando autostart: {e}{Colors.E}")
    else:
        try:
            if os.path.exists(desktop_file):
                os.remove(desktop_file)
                safe_print(f"{Colors.W}[九] Autolevantado DESACTIVADO.{Colors.E}")
            else:
                safe_print(f"{Colors.W}[!] No estaba activado.{Colors.E}")
        except Exception as e:
            safe_print(f"{Colors.F}[!] Error desactivando: {e}{Colors.E}")

# --- COMANDOS LOBBY CENTRALIZADOS ---
def exec_lobby_cmd(inp, origin_cid=None):
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE, VISIBLE_IN_SCAN, LOG_ON, AUTO_DL, POPUP_ON, USER_OFF

    inp = inp.strip()
    if not inp: return

    parts = inp.split(" ", 1)
    cmd = parts[0]
    args = parts[1] if len(parts) > 1 else ""

    # --- COMANDOS DE CREACI칍N DE SESI칍N (Forcan hijos) ---
    if cmd in ["--chatgrupal", "--grupal", "--grupo", "--chatg", "--g", "--cg"]:
        gp_parts = args.split()
        if len(gp_parts) == 2:
            gid, gp = gp_parts[0], gp_parts[1]
            cid = str(uuid.uuid4())[:8]
            cdata = {'type': 'GROUP', 'remote_id': gid, 'pass': gp, 'created_at': time.time()}
            ACTIVE_CHATS[cid] = cdata
            spawn_child_process(cid, cdata)
            refresh_ui(f"{Colors.G}[*] Grupo creado/unido.{Colors.E}") # FIX BUG 1
        else: safe_print(f"{Colors.F}Falta ID o Clave.{Colors.E}")

    elif cmd in ["--chatpersonal", "--personal", "--chatp", "--p", "--cp", "--dm"]:
        t = find_global(args)
        if t:
            if t == MY_IP: safe_print(f"{Colors.F}Eres t칰.{Colors.E}")
            else:
                safe_print(f"{Colors.W}[*] Invitando...{Colors.E}"); send_cmd(t, "INVITE", MY_NICK, "PRIV", MY_STATUS)

    # --- COMANDOS GLOBALES / UTILIDADES ---
    elif cmd == "--ls":
         safe_print(f"{Colors.G}Sesiones Activas ({len(ACTIVE_CHATS)}):{Colors.E}")
         for cid, d in ACTIVE_CHATS.items():
             safe_print(f" - [{cid}] {d['type']}: {d['remote_id']}")

    elif cmd in ["--contactos", "--c", "--history"]:
        safe_print(f"{Colors.G}[*] Historial de Sesi칩n ({len(KNOWN_USERS)}):{Colors.E}")
        for ip, d in KNOWN_USERS.items(): safe_print(f"   - {d['nick']} ({ip}) [{d['status']}] (Visto: {time.strftime('%H:%M', time.localtime(d['t']))})")

    elif inp == "--quienes": scan_network()
    elif inp == "--quienes-si":
        VISIBLE_IN_SCAN=True; save_config()
        refresh_ui(f"{Colors.G}[九] Visible en esc치ner.{Colors.E}")
    elif inp == "--quienes-no":
        VISIBLE_IN_SCAN=False; save_config()
        refresh_ui(f"{Colors.W}[九] Oculto en esc치ner.{Colors.E}")

    elif cmd in ["--estado", "--status", "--e"]:
        MY_STATUS = args; save_config()
        refresh_ui(f"{Colors.G}[九] Estado actualizado.{Colors.E}")
        send_cmd_all("STATUS_UPDATE", MY_NICK, MY_STATUS)

    elif cmd in ["--nick", "--nombre", "--nickname", "--name"]:
        MY_NICK = args; save_config()
        refresh_ui(f"{Colors.G}[九] Nick cambiado.{Colors.E}")

    elif inp == "--log on": LOG_ON=True; save_config(); msg_print(f"{Colors.G}LOG ON{Colors.E}")
    elif inp == "--log off": LOG_ON=False; save_config(); msg_print(f"{Colors.W}LOG OFF{Colors.E}")
    elif inp == "--popno": POPUP_ON, USER_OFF = False, True; msg_print(f"{Colors.W}Mute Manual.{Colors.E}")
    elif inp == "--popsi": POPUP_ON, USER_OFF = True, False; msg_print(f"{Colors.G}Popups ON.{Colors.E}")
    
    # AutoStart Commands
    elif inp == "--autolevantado-si": toggle_autostart(True)
    elif inp == "--autolevantado-no": toggle_autostart(False)
    
    elif inp in ["--clear", "--limpieza", "--limpiar"]:
        global LOBBY_HISTORY
        LOBBY_HISTORY = [] # Reset total si pide clear manual
        refresh_ui()

    elif cmd == "--invite":
        if not origin_cid:
             safe_print(f"{Colors.F}[!] Comando disponible solo dentro de una ventana de chat.{Colors.E}")
        else:
             # L칩gica de invitaci칩n desde dentro del chat
             # --invite A B C ...
             args_list = [x.strip().replace(',','') for x in args.split()]
             if not args_list: return

             chat_data = ACTIVE_CHATS.get(origin_cid)
             if not chat_data: return

             safe_print(f"{Colors.W}[*] Procesando invitaciones para chat {origin_cid}...{Colors.E}")

             targets_map = {} # IP -> Nick (o 'Unknown')
             unknown_nicks = []

             for arg in args_list:
                 # Es IP? (regex simple o check de puntos)
                 is_ip = False
                 if arg.count('.') == 3 and arg.replace('.','').isdigit():
                     # Asumimos IP
                     targets_map[arg] = "Usuario IP"
                     is_ip = True

                 if not is_ip:
                     # Es un Nick.
                     # 1. Buscar en memoria (R치pido)
                     target_clean = normalize_str(arg)
                     found = False
                     
                     # Check Global Peers
                     for ip, pdata in PEERS.items():
                         if isinstance(pdata, dict) and normalize_str(pdata.get('nick', '')) == target_clean:
                             targets_map[ip] = pdata.get('nick')
                             found = True
                             break
                     
                     # Check History
                     if not found:
                         for ip, kdata in KNOWN_USERS.items():
                             if normalize_str(kdata['nick']) == target_clean:
                                 targets_map[ip] = kdata['nick']
                                 found = True
                                 break
                     
                     if not found:
                         unknown_nicks.append(arg)
             
             # 2. Escaneo Activo para desconocidos (Lento: 2s)
             if unknown_nicks:
                 safe_print(f"{Colors.W}[*] Escaneando red para: {', '.join(unknown_nicks)}...{Colors.E}")
                 global DISC_TEMP
                 DISC_TEMP = [] # Reset buffer discovery

                 # Enviar WHOIS broadcast por cada nick
                 u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                 u.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                 for unick in unknown_nicks:
                     u.sendto(build_packet("WHOIS", unick), ('255.255.255.255', UDP_PORT))
                 u.close()
                 
                 time.sleep(2) # Esperar respuestas (pobladas por udp_loop en DISC_TEMP)
                 
                 # Verificar resultados
                 for unick in unknown_nicks:
                     clean_target = normalize_str(unick)
                     found_scan = False
                     for d_ip, d_nick, d_st in DISC_TEMP:
                         if normalize_str(d_nick) == clean_target:
                             targets_map[d_ip] = d_nick
                             found_scan = True
                             safe_print(f"{Colors.G}[+] Encontrado: {d_nick} ({d_ip}){Colors.E}")
                             break

             if not targets_map:
                 safe_print(f"{Colors.F}[!] Ning칰n objetivo v치lido encontrado.{Colors.E}")
                 return

             # Enviar invitaciones finales
             if chat_data['type'] == 'GROUP':
                 gid = chat_data['remote_id']
                 gpass = chat_data['pass']

                 cnt = 0
                 for ip, nick in targets_map.items():
                     send_cmd(ip, "INVITE", MY_NICK, "GROUP", gid, gpass, "varios")
                     cnt += 1
                 safe_print(f"{Colors.G}[九] Invitaciones enviadas a {cnt} usuarios.{Colors.E}")
             else:
                 safe_print(f"{Colors.F}[!] Solo se puede invitar gente a grupos.{Colors.E}")

    elif cmd in ["--archivo", "--arch", "--file", "--a"]:
         safe_print(f"{Colors.F}[!] Env칤o de archivos disponible solo dentro de una ventana de chat.{Colors.E}")

    elif cmd in ["--exit", "--salir"]:
        if origin_cid:
            # Comando viene de una ventana hija -> Cerrar SOLO esa ventana
            leave_sess(target_cid=origin_cid)
        else:
            # Comando en el Lobby -> Apagar APP
            shutdown_lobby()

    elif cmd in ["--help", "--ayuda", "--comandos"]:
         show_help()

    # --- RESPUESTAS A INVITACIONES ---
    elif inp == "--y" and PENDING_INVITE:
         ip, nick, type, extra = PENDING_INVITE['ip'], PENDING_INVITE['nick'], PENDING_INVITE['type'], PENDING_INVITE.get('data')
         if type == "PRIV":
             st = PEER_STATUSES.get(ip, "?")
             cid = str(uuid.uuid4())[:8]
             cdata = {'type': 'PRIV', 'remote_id': ip, 'pass': None, 'created_at': time.time()}
             ACTIVE_CHATS[cid] = cdata

             # LINK ROUTING (CRITICAL FIX FOR WINDOWS/MANUAL ACCEPT)
             if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
             if isinstance(PEERS[ip], dict):
                 PEERS[ip]['chats'].add(cid)
             
             # TRUSTED PEERS (New Security)
             TRUSTED_PEERS.add(ip); save_config()

             cdata['remote_nick'] = nick
             send_cmd(ip, "INVITE_ACC", MY_NICK, MY_STATUS)
             spawn_child_process(cid, cdata)
             refresh_ui(f"{Colors.G}[*] Invitaci칩n a privado aceptada.{Colors.E}") # FIX BUG 1
             
             # TRIGGER UPDATE CHECK (Private Accept)
             # threading.Thread(target=lambda: (time.sleep(3), try_trigger_updates([ip]))).start()
             pass
             
         elif type in ["GRP", "GROUP"]:
             gid, gp, _ = extra
             cid = str(uuid.uuid4())[:8]
             cdata = {'type': 'GROUP', 'remote_id': gid, 'pass': gp, 'created_at': time.time()}
             ACTIVE_CHATS[cid] = cdata

             # LINK ROUTING
             if ip not in PEERS: PEERS[ip] = {'nick': nick, 'chats': set()}
             if isinstance(PEERS[ip], dict): PEERS[ip]['chats'].add(cid)

             send_cmd(ip, "GRP_INVITE_ACC", MY_NICK)
             spawn_child_process(cid, cdata)
             # FIX: El hijo hace el join_grp autom치ticamente en run_child.
             # No lo hacemos aqui porque CurrentID es None.

             refresh_ui(f"{Colors.G}[*] Invitaci칩n a grupo aceptada.{Colors.E}") # FIX BUG 1
         PENDING_INVITE=None
         
    elif inp == "--n" and PENDING_INVITE:
         send_cmd(PENDING_INVITE['ip'], "INVITE_REJ", MY_NICK, "Rechazado")
         PENDING_INVITE = None

# --- PROCESOS & LOBBY ---
def spawn_child_process(cid, cdata):
    # Asignar puerto 칰nico para este hijo (IPC)
    # Buscamos puerto libre o usamos hash/incremental
    # Simple incremental based on ACTIVE_CHATS len wont work if we delete keys.
    # Random range + check? IPC_PORT + 1 + len(ACTIVE_CHATS) may collide.
    # Usaremos socket bind check.
    child_port = IPC_PORT + 1
    while True:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.bind(('127.0.0.1', child_port))
            break # Free
        except: child_port += 1
    
    cdata['port'] = child_port
    
    # Extraer nick remoto si est치 disponible en data (para PRIV) o arg
    rnick = cdata.get('remote_nick', '?')

    script_path = os.path.abspath(sys.argv[0])
    cmd_args = [
        sys.executable, script_path, 
        "--child", cid,
        "--type", cdata['type'],
        "--remote", cdata['remote_id'],
        "--pass", str(cdata['pass']),
        "--nick", MY_NICK,
        "--status", MY_STATUS,
        "--port", str(child_port),
        "--rnick", rnick
    ]
    
    
    if SILENT_UPDATES_ALLOWED:
        pass 
        # Ya no pasamos flag, update es via repo
        # cmd_args.append("--updates-ok")

    # Detectar terminal
    if platform.system() == "Windows":
        subprocess.Popen(cmd_args, creationflags=subprocess.CREATE_NEW_CONSOLE)
        print(f"{Colors.G}[*] Abriendo ventana para chat {cid}...{Colors.E}")
        return

    # Linux / UNIX Checks
    try:
        terminal_cmd = None
        if shutil.which("gnome-terminal"):
            terminal_cmd = ["gnome-terminal", "--"] + cmd_args
        elif shutil.which("konsole"):
            terminal_cmd = ["konsole", "-e"] + cmd_args
        elif shutil.which("xfce4-terminal"):
             terminal_cmd = ["xfce4-terminal", "--"] + cmd_args
        elif shutil.which("xterm"):
             terminal_cmd = ["xterm", "-e"] + cmd_args
        elif shutil.which("x-terminal-emulator"):
             # Intentar pasar como argumentos separados, comportamiento est치ndar xterm
             terminal_cmd = ["x-terminal-emulator", "-e"] + cmd_args
        
        if terminal_cmd:
            subprocess.Popen(terminal_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            print(f"{Colors.F}[!] No se encontr칩 terminal compatible.{Colors.E}")
            print(f"{Colors.W}[*] Ejecutando en segundo plano (no ver치s el chat)...{Colors.E}")
            subprocess.Popen(cmd_args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return
        
        print(f"{Colors.G}[*] Abriendo ventana para chat {cid}...{Colors.E}")

    except Exception as e:
        print(f"{Colors.F}[!] Error lanzando terminal: {e}{Colors.E}")

def ipc_listen_parent():
    global ACTIVE_CHATS
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    u.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try: u.bind(('127.0.0.1', IPC_PORT))
    except: return print(f"{Colors.F}[!] Error binding IPC {IPC_PORT}{Colors.E}")
    
    while True:
        try:
            d, _ = u.recvfrom(4096); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "CHILD_EXIT":
                cid = p[1]
                if cid in ACTIVE_CHATS:
                    print(f"\n{Colors.W}[INFO] Sesi칩n {cid} finalizada.{Colors.E}")
                    del ACTIVE_CHATS[cid]
                    refresh_ui() # FIX BUG 1: Actualizar contador
            
            elif cmd == "FWD_CMD":
                if len(p) >= 3:
                     cstr = p[2]
                     print(f"\n{Colors.M}[IPC] Ejecutando comando remoto: {cstr}{Colors.E}")
                     exec_lobby_cmd(cstr, origin_cid=p[1])

        except: pass

def ipc_listen_child(my_port, lock_state):
    # lock_state es un dict compartido con el thread principal del hijo para leer/escribir estado de POPs
    global MY_CHILD_ID
    u = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try: u.bind(('127.0.0.1', int(my_port)))
    except Exception as e: 
        print(f"Error bind child IPC: {e}")
        return
    
    while True:
        try:
            d, _ = u.recvfrom(8192); msg = d.decode()
            p = msg.split(SEP)
            cmd = p[0]
            
            if cmd == "FWD_MSG":
                if len(p) >= 4:
                    cid, tag, text = p[1], p[2], p[3]
                    if cid == MY_CHILD_ID:
                        safe_print(f"{tag}: {text}") 
                        
                        # LOGICA SMART POPUP
                        now = time.time()
                        last_in = lock_state.get('last_input', 0)
                        last_rx = lock_state.get('last_rx', 0)
                        manual_off = lock_state.get('pop_off', False)
                        ctype = lock_state.get('type', 'PRIV')
                        
                        # Actualizamos last_rx AHORA (actividad reciente en el chat)
                        lock_state['last_rx'] = now
                        
                        should_pop = False

                        # 1. Chequeo Manual Override (Prioridad Alta)
                        if manual_off:
                            # Si activado 'mute', solo suena si pasaron 5 mins (300s) de TOTAL SILENCIO previo
                            # Ojo: last_rx se acaba de actualizar, asi que comparamos con el last_rx *antes* de este msg?
                            # El usuario dijo: "pasan 5 minutos sin actividad... se vuelven a activar".
                            # Significa que si entre el mensaje ANTERIOR y ESTE pasaron > 300s, reactivamos.
                            if (now - last_rx) > TIMERS['MANUAL']:
                                lock_state['pop_off'] = False # Reactivar
                                safe_print(f"{Colors.W}[i] Popups reactivados por inactividad prolongada.{Colors.E}")
                                should_pop = True
                        else:
                            # 2. Chequeo Smart (Solo si no escrib칤 yo recientemente)
                            limit = TIMERS['PRIV'] if ctype == 'PRIV' else TIMERS['GROUP']
                            if (now - last_in) > limit:
                                should_pop = True
                        
                        if should_pop:
                             # Limpiar colores (ANSI escape codes) PRIMERO
                             # Si quitamos corchetes antes, rompemos la secuencia \033[...m
                             ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                             
                             tag_clean = ansi_escape.sub('', tag)
                             text_clean = ansi_escape.sub('', text)
                             
                             # Ahora sacar los corchetes decorativos del tag
                             sender_clean = tag_clean.replace('[','').replace(']','')
                             
                             title = ""
                             if ctype == 'GROUP':
                                 # Necesitamos el ID del grupo
                                 rid = lock_state.get('remote_id', '?')
                                 title = f"Mensaje grupal ({rid}) de {sender_clean}"
                             else:
                                 title = f"Mensaje privado de {sender_clean}"

                             popup(title, text_clean)

            elif cmd == "FWD_FILE":
                if len(p) >= 4 and p[1] == MY_CHILD_ID:
                    safe_print(f"{Colors.W}[뼇 Archivo '{p[3]}' de {p[2]} recibido en Lobby.{Colors.E}")
            
            elif cmd == "FWD_PEER":
                if len(p) >= 4:
                    rmt_ip, rmt_nick, rmt_stat = p[1], p[2], p[3]
                    if rmt_ip not in PEERS: PEERS[rmt_ip] = {'nick': rmt_nick, 'chats': {MY_CHILD_ID}}
                    else: 
                         if isinstance(PEERS[rmt_ip], dict):
                             PEERS[rmt_ip]['nick'] = rmt_nick
                             PEERS[rmt_ip]['chats'].add(MY_CHILD_ID)
                    safe_print(f"{Colors.G}[+] Detectado: {rmt_nick}{Colors.E}")
            
            elif cmd == "CMD_CLOSE_NOW":
                # Fuerza cierre (ej: peer desconectado en privado)
                # Usamos global REMOTE_NICK seteada en run_child
                safe_print(f"\n{Colors.F}[游눖] {REMOTE_NICK} ha abandonado el chat.{Colors.E}")
                # print(f"\n{Colors.F}[!] Cierre remoto: {p[1] if len(p)>1 else ''}{Colors.E}")
                time.sleep(3)
                # No mandamos exit signal propia para evitar bucle, solo salimos
                os._exit(0)

        except: pass

def shutdown_lobby():
    print(f"\n{Colors.W}[*] Cerrando todas las sesiones y saliendo...{Colors.E}")
    
    # 1. Notificar a peers remotos (Global Disconnect)
    # Enviamos a todos los peers conocidos que estamos desconectando
    # Esto cerrar치 los privados en su lado y notificar치 en grupos
    # NOTA: Si queremos ser espec칤ficos, podr칤amos mandar LEAVE_GRP a grupos
    # y DISCONNECT_NOW a privados, pero un DISCONNECT_NOW global es m치s seguro para "apagar todo".
    # El receptor ya maneja DISCONNECT_NOW cerrando privados y notificando grupos.
    known_ips = list(PEERS.keys())
    # Filtrar solo IPs que tienen algun chat activo con nosotros
    # Para no mandar paquetes a gente que solo "vimos" en un scan pero no hablamos
    active_targets = []
    for ip, pdata in PEERS.items():
        if isinstance(pdata, dict) and pdata.get('chats'):
             # Tiene al menos 1 chat en comun con nosotros
             active_targets.append(ip)

    for ip in active_targets:
        send_cmd(ip, "DISCONNECT_NOW", MY_NICK)
        
    # 2. Cerrar hijos locales
    for cid, cdata in list(ACTIVE_CHATS.items()):
        if 'port' in cdata:
            # Mandar se침al de cierre suicida al hijo
            send_ipc("CMD_CLOSE_NOW", cdata['port'])
    
    time.sleep(1) # Dar tiempo a que salgan los mensajes
    restore_terminal()
    print(f"{Colors.G}[九] Todo cerrado. Hasta luego.{Colors.E}")
    sys.exit(0)

def restore_terminal():
    """Restaura el eco de la terminal en Linux si se perdi칩"""
    if platform.system() != "Windows":
        os.system("stty echo")

# Asegurar restauraci칩n al salir brusco
atexit.register(restore_terminal)


def liberate_ports():
    """Detecta y elimina procesos zombies ocupando nuestros puertos"""
    ports = [TCP_PORT, UDP_PORT]
    try:
        if platform.system() == "Linux":
            # Usar lsof o fuser
            # fuser -k 44494/tcp
            for p in ports:
                 subprocess.run(f"fuser -k {p}/tcp", shell=True, stderr=subprocess.DEVNULL)
                 subprocess.run(f"fuser -k {p}/udp", shell=True, stderr=subprocess.DEVNULL)
        elif platform.system() == "Windows":
             # Parsing netstat es doloroso, pero necesario
             # netstat -ano | findstr :44494
             for p in ports:
                 r = subprocess.check_output(f"netstat -ano | findstr :{p}", shell=True, stderr=subprocess.DEVNULL).decode(errors='ignore')
                 lines = r.strip().split('\n')
                 for line in lines:
                     parts = line.split()
                     if len(parts) > 4:
                         pid = parts[-1]
                         if pid != "0": # No matar System
                             subprocess.run(f"taskkill /F /PID {pid}", shell=True, stderr=subprocess.DEVNULL)
    except: pass

def enable_win_visuals():
    """Fuerza UTF-8 y ANSI Colors en consola de Windows"""
    if platform.system() == "Windows":
        try:
            # 1. UTF-8
            os.system("chcp 65001 > nul") 
            # 2. ANSI VT100
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except: pass

def run_lobby():
    global MY_NICK, MY_STATUS, MY_IP, LAST_ACT, PENDING_INVITE
    # atexit.register(lambda: print(f"{Colors.W}Lobby cerrado.{Colors.E}")) # Reemplazado por shutdown manual
    
    # Self-Healing Checks
    enable_win_visuals()
    liberate_ports()
    
    # Capturar Ctrl+C en Lobby para shutdown limpio
    import signal
    signal.signal(signal.SIGINT, lambda s, f: shutdown_lobby())

    os.system('cls' if os.name == 'nt' else 'clear'); fw_cfg(); MY_IP = get_ip()
    
    # Kali/Network Check
    if MY_IP.startswith("127.") and platform.system() == "Linux":
         print(f"{Colors.W}[!] ADVERTENCIA: IP local ({MY_IP}) detectada.{Colors.E}")
         print(f"{Colors.W}[!] Si usas Kali Linux, verifica que no est칠s en 'Modo Monitor' (airmon-ng stop wlan0).{Colors.E}")
         print(f"{Colors.W}[!] La visibilidad en red estar치 limitada.{Colors.E}")
         time.sleep(3)
    
    global LOBBY_HISTORY, PROMPT
    PROMPT = f"{Colors.B}Lobby > {Colors.E}"
    
    if not load_config():
        while True:
            try: 
                if n := input("Tu Nickname: ").strip(): MY_NICK = n; break
            except: sys.exit()
        save_config()
    
    # Check Network Security on Startup
    global SILENT_UPDATES_ALLOWED
    SILENT_UPDATES_ALLOWED = check_network_trust()
    if SILENT_UPDATES_ALLOWED:
        pass # safe_print(f"{Colors.G}[Sec] Actualizaciones silenciosas ACTIVAS en esta red.{Colors.E}")
    else:
        pass # safe_print(f"{Colors.W}[Sec] Actualizaciones silenciosas DESACTIVADAS.{Colors.E}")

    refresh_ui() # Clean start with Dashboard
    
    # Aseguramos limpieza al inicio tambi칠n por si acaso
    restore_terminal()
    
    threading.Thread(target=ipc_listen_parent, daemon=True).start()
    threading.Thread(target=tcp_loop, daemon=True).start() # Para recibir invitaciones
    threading.Thread(target=udp_loop, daemon=True).start() # Para discovery global
    
    check_repo_update()

    while True:
        try:
            inp = input(f"{Colors.B}Lobby > {Colors.E}").strip()
            if inp: LOBBY_HISTORY.append(f"{Colors.B}Lobby > {Colors.E}{inp}") # Guardar input usuario
            
            restore_from_afk()
            exec_lobby_cmd(inp)
        except KeyboardInterrupt: sys.exit()
        except Exception as e: safe_print(f"Err Lobby: {e}")

def handle_child_sigint(cid):
    # Enviar se침al de salida al lobby y morir
    try:
        send_ipc(f"CHILD_EXIT{SEP}{cid}", IPC_PORT)
    except: pass
    print(f"{Colors.W}[*] Cerrando chat...{Colors.E}")
    time.sleep(0.2)
    os._exit(0)

def run_child(cid, ctype, remote, password, mynick, mystatus, myport, rnick="?"):
    global MY_NICK, MY_STATUS, MY_IP, CURRENT_CHAT_ID, IS_CHILD, MY_CHILD_ID, PROMPT, REMOTE_NICK
    IS_CHILD = True
    MY_CHILD_ID = cid
    CURRENT_CHAT_ID = cid
    MY_NICK = mynick
    MY_STATUS = mystatus
    MY_IP = get_ip()
    REMOTE_NICK = rnick # Global para uso en IPC
    
    # Override Global Prompt for Child Windows
    PROMPT = f"\001{Colors.B}\002T칰: \001{Colors.E}\002"
    
    # Signals for Child
    signal.signal(signal.SIGINT, lambda s, f: handle_child_sigint(cid))
    
    # Estado compartido para Popups
    pop_state = {'last_input': 0, 'last_rx': time.time(), 'pop_off': False, 'type': ctype, 'remote_id': remote}

    # Configurar estado solo para este chat
    ACTIVE_CHATS[cid] = {'type': ctype, 'remote_id': remote, 'pass': password}
    CURRENT_CHAT_ID = cid
    
    print(f"{Colors.H}--- CHAT {ctype} ({cid}) IPC:{myport} ---{Colors.E}")
    
    # Iniciar listener IPC (Chat receive) en puerto UNICO, pasando el estado compartido
    threading.Thread(target=ipc_listen_child, args=(myport, pop_state), daemon=True).start()
    
    # NO iniciar tcp_loop ni udp_loop en hijo (conflicto de puertos)
    
    # Si es grupo, iniciar b칰squeda/anuncio inmediato
    if ctype == 'GROUP':
        threading.Thread(target=join_grp, args=(remote, password), daemon=True).start()
    elif ctype == 'PRIV':
        if remote not in PEERS: 
             PEERS[remote] = {'nick': rnick, 'chats': {cid}}
        else:
             if isinstance(PEERS[remote], dict): PEERS[remote]['chats'].add(cid)
        send_cmd(remote, "WHOIS", MY_IP) 

    while True:
        try:
            inp = input(PROMPT).strip()
            if not inp: continue
            
            restore_from_afk()
            
            # Actualizar last_input siempre
            pop_state['last_input'] = time.time()
            
            if inp in ["--exit", "--salir"]:
                print(f"{Colors.W}[*] Saliendo...{Colors.E}")
                # Enviar se침al de Leave al resto si es necesario
                # Pero la l칩gica central est치 en leave_sess del Lobby.
                # Aqu칤 simplemente matamos al hijo y el Lobby manejar치 CHILD_EXIT.
                
                # Pero espera, si matamos al hijo abruptamente, el Lobby solo sabe que muri칩.
                # Lo mejor es decir al Lobby "Quiero Salir".
                send_ipc(f"FWD_CMD{SEP}{cid}{SEP}--exit", IPC_PORT)
                time.sleep(0.5)
                os._exit(0)         # Comandos Locales de Popups
            if inp == "--popno":
                pop_state['pop_off'] = True
                print(f"{Colors.W}[i] Popups DESACTIVADOS (hasta nuevo aviso o 5 min inactividad).{Colors.E}")
                continue
            elif inp == "--popsi":
                pop_state['pop_off'] = False
                print(f"{Colors.G}[i] Popups ACTIVADOS.{Colors.E}")
                continue
            
            # Forward management commands to Lobby
            cmd_part = inp.split()[0]
            
            # Comandos Locales (Ejecutados AQU칈 en el hijo)
            if cmd_part in ["--archivo", "--arch", "--file", "--a"]:
                 arg = inp.split(" ", 1)[1] if " " in inp else ""
                 if arg: send_file(arg)
                 else: print(f"{Colors.F}Falta ruta del archivo.{Colors.E}")
                 continue
            
            if cmd_part == "--clear":
                os.system('cls' if os.name == 'nt' else 'clear')
                print(f"{Colors.H}--- CHAT {ctype} ({cid}) IPC:{myport} ---{Colors.E}")
                continue

            # Comandos Remotos (Reenviados al Lobby)
            # Lista ampliada con todos los settings globales
            valid_remote_cmds = [
                "--chatgrupal", "--grupal", "--grupo", "--chatg", "--g", "--cg",
                "--chatpersonal", "--personal", "--chatp", "--p", "--cp",
                "--quienes", "--contactos", "--c", "--history", "--invite",
                "--quienes-si", "--quienes-no", "--estado", "--status", "--e",
                "--nick", "--log", "--descarga-automatica-si", "--descarga-automatica-no",
                "--aceptar", "--accept", "--rechazar", "--deny"
            ]
            
            if cmd_part in valid_remote_cmds or (cmd_part == "--log" and len(inp.split())>1):
                 print(f"{Colors.W}[IPC] Enviando comando al Lobby...{Colors.E}")
                 send_ipc(f"FWD_CMD{SEP}{cid}{SEP}{inp}", IPC_PORT)
                 continue
            
            if inp == "--help":
                print(f"{Colors.C}--- AYUDA LOCAL ---{Colors.E}")
                # Mostramos un resumen breve de comandos 칰tiles en chat
                print(" --invite <nicks> : Invitar al grupo")
                print(" --archivo <ruta> : Enviar archivo")
                print(" --ls             : Ver miembros")
                print(" --popno / --popsi: Controlar popups")
                print(" --exit / --salir : Salir del chat")
                print(" --clear          : Limpiar pantalla")
                print(" (Comandos globales como --estado o --nick se sincronizan con Lobby)")
                continue

            if inp == "--ls":
                 print(f"{Colors.G}Miembros:{Colors.E}")
                 for ip, d in PEERS.items():
                     if isinstance(d, dict) and cid in d.get('chats', []):
                         print(f" - {d['nick']} ({ip})")
            
            else:
                if ctype == 'GROUP':
                    # Protocolo V2: GRP_MSG para evitar ambig칲edad de routing
                    send_cmd_all("GRP_MSG", remote, inp)
                else:
                    send_all(inp.encode())
                
        except KeyboardInterrupt: 
            if ctype == 'GROUP':
                send_cmd_all("LEAVE_GRP", remote, MY_NICK)
            else:
                send_cmd_all("DISCONNECT_NOW", MY_NICK)
            
            time.sleep(0.5)
            send_ipc(f"CHILD_EXIT{SEP}{cid}", IPC_PORT)
            sys.exit()

def main():
    # Parsing manual de args para no depender de argparse complejo
    if "--child" in sys.argv:
        try:
            idx = sys.argv.index("--child")
            cid = sys.argv[idx+1]
            
            ctype = sys.argv[sys.argv.index("--type")+1]
            remote = sys.argv[sys.argv.index("--remote")+1]
            passwd = sys.argv[sys.argv.index("--pass")+1]
            if passwd == "None": passwd = None
            
            mnick = sys.argv[sys.argv.index("--nick")+1]
            mstat = sys.argv[sys.argv.index("--status")+1]
            
            port = sys.argv[sys.argv.index("--port")+1]
            
            rnick = "?"
            if "--rnick" in sys.argv:
                 rnick = sys.argv[sys.argv.index("--rnick")+1]
            
            # Check for silent updates flag passed from parent
            global SILENT_UPDATES_ALLOWED
            # if "--updates-ok" in sys.argv: SILENT_UPDATES_ALLOWED = True 
            # Deprecated flag logic

            run_child(cid, ctype, remote, passwd, mnick, mstat, port, rnick)
        except Exception as e:
            print(f"Error iniciando hijo: {e}")
            time.sleep(5)
    else:
        run_lobby()

if __name__ == "__main__": main()
