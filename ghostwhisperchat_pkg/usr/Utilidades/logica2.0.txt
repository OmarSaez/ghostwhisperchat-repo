# Documentación de Arquitectura GhostWhisperChat v41.x - "Lógica 2.0"
# ==========================================================================

Esta documentación detalla el funcionamiento interno de la arquitectura modular y orientada a microservicios implementada en las versiones v38+ de GhostWhisperChat.

## 1. Visión General: Arquitectura Procesos (Lobby vs Hijos)

El sistema ya no es un solo script monolítico. Se divide en dos roles principales que corren como procesos independientes del sistema operativo, comunicándose entre sí.

### A. El Lobby (Proceso Padre / Orquestador)
- **Archivo**: `ghostwhisperchat` (binario/script principal).
- **Función**: Es el centro de control. Mantiene el estado global de la red ("quién está conectado"), maneja el descubrimiento (Discovery), recibe invitaciones entrantes y lanza los procesos hijos.
- **Persistencia**: Mantiene la lista de `PEERS` y `KNOWN_USERS` en memoria mientras la app está abierta.
- **Puertos**: Escucha en los puertos públicos predeterminados (UDP 44495, TCP 44494) para recibir peticiones del exterior.

### B. El Hijo (Proceso Chat / Sesión)
- **Archivo**: `gw_child.py`.
- **Función**: Es una instancia efímera dedicada a UNA sola conversación (ya sea Privada o Grupal).
- **Aislamiento**: Tiene su propia ventana de terminal, su propio bucle de entrada (`input()`) y su propia conexión TCP (para chats privados) o lógica de Mesh (para grupos).
- **Ciclo de Vida**: Nace cuando el usuario acepta una invitación o crea un chat, y muere (`os._exit`) cuando el usuario cierra esa conversación.

---

## 2. Descripción de Módulos (Librerías y Core)

El sistema se compone de un núcleo ejecutable y una serie de librerías especializadas ubicadas en `/usr/lib/ghostwhisperchat/`:

### 0. `ghostwhisperchat` (Módulo Core / Lobby)
- **Tipo**: Ejecutable principal (Entry Point).
- **Ubicación**: `/usr/bin/ghostwhisperchat`.
- **Responsabilidad**:
  - **Orquestación**: Inicia la aplicación, carga la configuración y decide si correr como Lobby o lanzar un proceso Hijo (si recibe flags `--child`).
  - **Gestión de Estado**: Mantiene el diccionario `ACTIVE_CHATS` (procesos hijos vivos) y `PEERS` (vecinos detectados).
  - **Servidor V2**: Implementa los `handlers` principales (`handle_v2_logic`) que deciden qué hacer con cada paquete recibido (enrutar al hijo, mostrar popup, guardar archivo, etc.).
  - **Interfaz TUI**: Renderiza el dashboard principal usando `gw_display`.

### 1. `gw_comm.py` (Capa de Comunicación)
- **Propósito**: Motor de networking de bajo nivel.
- **Funciones**:
  - `build_packet / parse_packet`: Protocolo de serialización (Header|Len|Payload).
  - `start_tcp_listener / start_udp_listener`: Hilos demonio que escuchan en los puertos 44494/44495/44496.
  - `send_cmd`: Facade para enviar comandos de forma agnóstica (elije TCP o UDP según el caso).
  - `Secure Sockets`: Maneja timeouts, reconexiones básicas y errores de socket.

### 2. `gw_shared.py` (Configuración y Constantes)
- **Propósito**: "Fuente de la Verdad" compartida.
- **Contenido**:
  - **Configuración Global**: Puertos, Versión (`APP_VER_NUM`), Constantes de Tiempo (Pop Timeout).
  - **Definiciones de Comandos**: Diccionario `COMMAND_DEFS` que mapea alias (`--ayuda`, `-h`) a acciones internas.
  - **Utilidades Puras**: `normalize_str`, `calculate_file_hash`, `get_ip`.

### 3. `gw_cmd.py` (Lógica de Comandos)
- **Propósito**: Controlador de Comandos de Usuario.
- **Patrón Diseño**: Usa Inyección de Dependencia (`adapter`).
- **Flujo**:
  1. El usuario escribe `/nick Batman`.
  2. `gw_cmd.process` recibe el string.
  3. Identifica la acción `NICK`.
  4. Llama a `adapter.set_config('nick', 'Batman')`.
  - Si el adapter es el **Lobby**, cambia la config global y notifica a la red.
  - Si el adapter es un **Hijo**, envía una señal IPC al Lobby para que haga el cambio.

### 4. `gw_child.py` (Adaptador de Hijo)
- **Propósito**: Módulo de Sesión de Chat Aislada.
- **Responsabilidad**:
  - Mantiene el estado de UNA conversación (`PEERS` locales del grupo).
  - Dibuja la interfaz del chat (Prompt, Mensajes entrantes coloreados).
  - Maneja la lógica **Mesh** para grupos: Al enviar, itera sobre sus peers y hace N envíos TCP.
  - `ChildAdapter`: Implementa la interfaz requerida por `gw_cmd` para ejecutar comandos locales (`cls`, `exit`).

### 5. `gw_pop.py` (Gestor de Notificaciones)
- **Propósito**: Interfaz con el sistema de ventanas del OS.
- **Implementación**: Wrapper sobre `zenity` (Linux).
- **API**:
  - `show(title, msg, duration)`: Lanza notificación efímera ("burbuja").
  - `ask(title, msg)`: Lanza diálogo modal Si/No (Invitaciones).

### 6. `gw_display.py` (Gestor de Interfaz / Buffer)
- **Propósito**: Manejo avanzado de la salida en terminal (TUI).
- **Problema que resuelve**: En el Lobby, llegan logs asíncronos (scans, debug) que romperían el prompt de entrada `Lobby >`.
- **Solución**: Mantiene un buffer de líneas y redibuja la pantalla limpiamente (`cls` + reimpresión) cada vez que hay nueva información, manteniendo el input del usuario intacto abajo.

### 7. `gw_complete.py` (Autocompletado)
- **Propósito**: Inteligencia de entrada (Tab-Completion).
- **Funciones**:
  - Se conecta con `readline` (librería estándar).
  - Sugiere comandos (`--...`) y, más importante, **Nicks e IPs**.
  - Contextual: Si escribes `--chatprivado `, te sugiere IPs de la lista de `KNOWN_USERS`.

---

## 3. Protocolos de Comunicación

El sistema utiliza tres capas de comunicación simultáneas:

### A. Capa Externa (Red LAN - Entre PCs)

1.  **UDP 44495 (Discovery Channel)**:
    -   **Uso**: Encontrar usuarios y grupos.
    -   **Comandos**:
        -   `WHOIS`: "Hola, ¿quién está ahí?".
        -   `I_EXIST`: "Aquí estoy" (Respuesta).
        -   `SEARCH_GROUP`: "¿Existe el grupo X?".
        -   `STATUS_UPDATE`: Notificar cambio de Nick/Estado.

2.  **TCP 44494 (Control & Private Data)**:
    -   **Uso**: Protocolo fiable para comandos críticos y chat 1-a-1.
    -   **Comandos**:
        -   `INVITE`: Iniciar una sesión.
        -   `CLOSE_PRIV`: Cerrar sesión formalmente (Protocolo Robustez).
        -   `FILE_TRANSFER`: Envío de flujo de bytes (Archivos).
        -   Mensajes de Chat Privado (Texto plano o encapsulado).

3.  **TCP 44496 (Group Mesh)**:
    -   **Uso**: Chat Grupal Descentralizado.
    -   **Lógica**: Cada miembro del grupo tiene la lista de IPs de los demás (`PEERS`). Al enviar un mensaje, el Hijo itera y envía copias Unicast TCP a cada miembro activo. No hay servidor central.

### B. Capa Interna (Localhost - IPC)

Como el Lobby y los Hijos son procesos separados de memoria, usan **UDP Localhost** para hablarse.
-   **Lobby**: Escucha en puerto estático `12345` (IPC_PORT).
-   **Hijo**: Escucha en puerto dinámico asignado al nacer (ej: `56001`).

**Mensajes IPC Comunes:**
-   `Lobby -> Hijo`:
    -   `FWD_MSG`: "Llegó un mensaje para ti desde internet".
    -   `CMD_ADD_PEER`: "He descubierto un nuevo usuario, añádelo a tu lista".
    -   `CMD_CLOSE_NOW`: "Cierra la ventana (Orden remota)".
-   `Hijo -> Lobby`:
    -   `CMD_ACTIVITY`: "El usuario está escribiendo (Resetea timer de Pop)".
    -   `FWD_CMD`: "El usuario escribió un comando global (ej: --autostart), ejecútalo tú".
    -   `CMD_SYNC_PEERS`: "Acabo de nacer, dame la lista de usuarios que conoces".

---

## 4. Flujos Lógicos Clave

### A. Smart Pop (Anti-Spam)
Para evitar ventanas molestas:
1.  Lobby mantiene un mapa `CHAT_ACTIVITY` con timestamps.
2.  Si llega un mensaje (`MSJ`):
    -   Calcula tiempo desde última interacción.
    -   Si es < 60s, incrementa contador de "Burst".
    -   Si Burst <= 2, muestra `gw_pop.show()`.
    -   Si Burst > 2, silencia el pop.
3.  Si el usuario responde (Hijo envía `CMD_ACTIVITY`), el Lobby actualiza el timestamp a "AHORA", manteniendo el estado "Activo" (y por tanto silenciado) para no interrumpir la conversación fluida.

### B. Robustez de Desconexión
Problema: Paquetes UDP desordenados podían cerrar chats nuevos.
Solución ("Robust Priv Disc"):
1.  Al cerrar un chat, se envía `CLOSE_PRIV` con un `TIMESTAMP` actual.
2.  El receptor compara ese timestamp con `created_at` de su chat activo.
3.  Si el paquete es más viejo que la creación del chat, se ignora (Zombie Packet).

### C. Transferencia de Archivos
1.  Sender (Hijo) comprime (si es carpeta) y obtiene Hash.
2.  Sender conecta al TCP 44494 del Receiver.
3.  Envía comando `FILE_TRANSFER` + Metadata.
4.  Lobby Receiver detecta comando, activa `handle_incoming_file`.
5.  Lobby toma control del socket, descarga stream a `~/Escritorio/GhostWhisper_Recibidos`.
6.  Al terminar, notifica al Hijo correspondiente via IPC `FWD_FILE`.
